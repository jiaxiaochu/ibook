{"./":{"url":"./","title":"吹花小筑工作室","keywords":"","body":"1. Introduction1. Introduction Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-24 17:59:51 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"introduction.html":{"url":"introduction.html","title":"导读","keywords":"","body":"1.1.1. 来，一起学Python呀！1.1.2. 为什么需要学习编程？1.1.3. 那么编程的核心是什么？1.1.4. 经得起时间考验的通识技能1.1.5. 关于本书的未来计划！1.1.6. 怎样找到我？1.1.7. 支持我1.1.1. 来，一起学Python呀！ 为什么写这本书？ 无需基础，循序渐进！ 2018年7月，有名网友给我发邮件说想添加我的微信，发给我一个红包，附言说在 Github 上看了我的爬虫和数据分析的案例代码，想交个学费。 2018年的年末和2019年年初的那段时间，我开始有写一个Python教程的想法，这名网友的行为让我的想法更加明晰。无奈琐碎事多加上2019年准备换工作离职，一直迟迟没有动手。 2019年8月31号从传智播客辞职换工作以后，便开始利用闲暇时间进行这项计划。当我认真思考这件事的时候，我清楚我没有能力把 Python 讲得很明白，但可以采用边讲解边实践的方式，让大家快速上手学习Python语言。 我是一个野生程序员（欢迎访问我的博客：贾志翔的博客），对没错，是野生的程序员！为什么这样说呢？那是因为我并非计算机科班出身(后来辅修了计算机)，而是半路出家。我热爱体育，熟悉各种球类运动，酷爱篮球和羽毛球，但是我这种爱折腾的人呢，当年报考却没有选择体育，而是选择去搞石油工程(一个很苦逼的专业)啦，毕业以后又折腾着搞起了IT！ 过程很曲折，非三言两语能言清。总之，我就是一个不浮躁、不偏激、不守旧、爱编程、爱后端、爱爬虫、爱新技术、爱运动、爱旅行、执行力和学习能力都很强野生程序员。 当你准备往下阅读时，这里有两件事要告诉你： 无需担心，在开始之前你不需要用有任何编程的基础 Python 很容易上手，适合各个阶段的你去学习 这是一个简短且详细的Python教程，用来帮助你学习编程和写自己的Python机器人。 1.1.2. 为什么需要学习编程？ 如今，学习编程的人分为两类，一类是程序员，另一类是期望成为程序员和对计算机编程感兴趣的人。 编程这个事儿，在大多数人眼中还是一种特定领域的、专门的技能，认为学的人都是需要以此谋生的。 其实，作为一个程序员，我是这样认为的：在不久的将来（也许三五年，也许十来年之后），编程将从一个职业技能逐步蜕变为职场通用技能。 对此，我们可以类比“识字”这个技能来看—— 百十年前，大多数老百姓都不认识母语文字。当年具备了“认字”这一技能的人，就可以获得比大多数人更优越的工作环境，报酬更高的职位。那时，识字无疑是一种必备的职业技能。 但到了今天，识字率已经差不多100%了，具备此技能已经不再是职场的加分项了。相反，如果在今天不认字，那恐怕注定只能从事低端工作了。而如今的职场环境，要比之前要求的多，除了基本的电脑办公软件，要求会编程，也在各个互联网公司的面试中开始蔓延开来。 类似的技能还有： 驾驶——汽车工业发展起来后，职业司机越来越少，驾驶逐渐成为人们的通用技能。 在未来，编程就会成为人人都会做的事情，作为势必要踏入职场中的一员，除了要具备听说读写本国语言的能力外，还需要能够读写代码。 不久的将来，职业写代码的人，将越来越少。取而代之的，编程将是每个职业人的必备技能，拥有更多技能的人，就更有拿到好offer，升职加薪的机会。 即便现在一时之间无法达到社会全员编程的地步，至少是朝着这个方向发展，未来3年或5年，编程将成为互联网从业者的必修课。所以，在此我们要把握这个机会，勇敢的迎上新时代的机遇，只有把握先机的人，才会在未来的发展中有一席之地。 1.1.3. 那么编程的核心是什么？ 从语言特征（词汇、语法等）的角度来讲，最复杂的编程语言远比最简单的自然语言简单得多。 我们学习各种自然语言是为了日常生活与人交流、收发信息，那么，学习编程语言又是为什么呢？ 其实是为了用编程语言来描述事物、概念，以及它们之间的相互关系和运行方式，将我们身处在的大千世界转化为一台计算机能够理解的电信号，驱动硅晶金属构造的计算机部件去完成任务！我们学会了这门语言，用来和计算机交流，在反过来作用于自己，创造更多的价值。 编程的核心在于通过各种各样的算法去实现具体的业务逻辑，把繁杂的过程抽象化、可计算化。 从纯粹软件的角度讲，甚至可以说：算法 + 数据 == 计算机程序。 受过计算机科班教育的人一定上过一门课：数据结构，这门课是计算机科学的基础，它的核心内容就是各式各样的算法，它们是几代计算机科学家从解决现实问题中提取出的套路——这些才是编程的核心。 1.1.4. 经得起时间考验的通识技能 计算机技术从诞生起就处在飞速发展之中。编程语言从无到有，从少到多，从最初的01代码，机器语言到后来百花齐放的高级语言，此消彼长，兴衰交替。 各种工具、框架更是日新月异，各领风骚三五年乃至三五月就被淘汰者成百上千。但是经由现实问题中提炼出来的经典算法，却经得起时间的考验。 这些经典算法是计算机发展过程中世界上最聪明的一小撮人千锤百炼出的，解决某些模式问题的方法和策略。 这些方法和策略基于人类几千年文明史的思维积淀，又经历了最严格的数学分析和验证，本身既是人类文明的结晶，同时又是一种有效的思维训练。这种逻辑思维能力，也能用于平时的生活中解决问题，当你的逻辑思维被打通，你会发现没什么难事，都会有解决方法。 用数值表达现实事物，用运算描述任务目标，再通过算法处理数据找到达到目标的最优化路径——这个思维的形成过程，远比学会模型本身更为难得。 经过这种思考训练内化出的思维能力，也是学习者可以相伴终身的助力。 1.1.5. 关于本书的未来计划！ 由于篇幅短小和时间仓促,若你发现了错误请告知我。希望我没有误导你，而是带你看了小小的新世界。 阅读过程中，有任何问题都可以使用邮箱找到我。 1.本书定稿以后，会录制配套的是视屏讲解教程 本书编辑期间，免费开放在线阅读接口，阅读过程中有任何问题都可以使用邮箱找到我，欢迎大家提出问题并指正。 本书定稿以后，除保留部分Python基础语法外，其他部分将会改为付费内容， 并会录制与本书配套的付费知识点讲解视屏； 目前暂定bilibili、网易云课堂以及淘宝教育三个平台。 2.计划创建分享交流群 我计划为本教程付费读者创建专门的技术交流群，以方便更有针对性地讨论课程相关问题。 阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向我提问（我会抽空回复）。 你的分享不仅帮助他人，更会提升自己。 入群方式：请发送入群申请至邮箱：zhixiang.jia@foxmail.com 1.1.6. 怎样找到我？ 邮箱联系我：zhixiang.jia@foxmail.com 阅读过程中，有任何疑问都可以使用 邮箱 找到我。 1.1.7. 支持我 微信 支付宝 特别说明： 赞赏并不是一种持续和健康的收入模式，我更希望我们之间是纯粹的金钱交易关系，你应该为了对得起定价的产品和服务付费，而不是为了情怀或者其他东西。 打赏-赞助请三思，虚拟产品赞助打赏后恕不退款 打赏 68元 以上可以加个人微信畅聊30分钟，非诚勿扰。 打赏 199元 以上可以一对一进行技术答疑。 打赏名单默认不会在网站上显示，如需显示请将付款截屏发送至邮箱:zhixiang.jia@foxmail.com Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-24 18:11:58 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"info.html":{"url":"info.html","title":"资源导航","keywords":"","body":"1. 资源导航1. 资源导航 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-08 23:36:47 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"contact.html":{"url":"contact.html","title":"联系方式","summary":"賈誌翔的联系方式","keywords":"","body":"1. 怎样找到我？2. 支持我1. 怎样找到我？ 邮箱联系我：zhixiang.jia@foxmail.com 阅读过程中，有任何疑问都可以使用邮箱找到我。 2. 支持我 微信 支付宝 特别说明： 赞赏并不是一种持续和健康的收入模式，我更希望我们之间是纯粹的金钱交易关系，你应该为了对得起定价的产品和服务付费，而不是为了情怀或者其他东西。 打赏-赞助请三思，虚拟产品赞助打赏后恕不退款 打赏 68元 以上可以加个人微信畅聊30分钟，非诚勿扰。 打赏 199元 以上可以一对一答疑。 打赏名单默认不会在网站上显示，如需显示请将付款截屏发送至邮箱:zhixiang.jia@foxmail.com Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-24 18:12:50 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"blog/":{"url":"blog/","title":"我的博客","keywords":"","body":"1. 我的博客2. 贾志翔的技术博客: https://www.jiazhixiang.xyz/2.1. 归档文章2.2. 捐赠1. 我的博客 个人博客 GitHub 知乎 主要涉及技术： Python后端开发 安全渗透测试 数据分析 爬虫 公众号开发 Linux 开源爱好者 博客将不定期更新，请小伙伴们随时关注哦！ 2. 贾志翔的技术博客: https://www.jiazhixiang.xyz/     欢迎来到贾志翔的技术博客，这里将深入探讨相关技术，包括行业动态，爬虫、设计模式，框架使用等。 博客集成了不蒜子访问量统计、404页面、百度提交收录链接、GitBook文档、评论系统Gitment、helper-live2d动态模型插件、背景音乐 （网易云音乐）、文章置顶功能 不浮躁、不偏激、不守旧、爱编程、爱后端、爱爬虫、爱新技术、爱运动、爱旅行、执行力和学习能力都很强！ 2.1. 归档文章 工欲善其事,必先利其器 Python Linux Vim MySQL Hexo 日记本 2.2. 捐赠     如果感觉对您有帮助，请作者喝杯咖啡吧! 请注明您的名字或者昵称，方便作者感谢o(￣︶￣)o 微信 支付宝 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-24 18:14:18 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"configuration/包含Windows、Mac、Linux三大系统详解视屏.html":{"url":"configuration/包含Windows、Mac、Linux三大系统详解视屏.html","title":"包含Windows、Mac、Linux三大系统","keywords":"","body":"1. 包含Windows、Mac、Linux三大系统1. 包含Windows、Mac、Linux三大系统 视屏讲解教程，请移步至我的哔哩哔哩bilibili主页面:https://space.bilibili.com/316347293 进行查看。 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-23 21:30:19 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"configuration/Mac系统Python、PyCharm安装及使用方法详解.html":{"url":"configuration/Mac系统Python、PyCharm安装及使用方法详解.html","title":"Mac系统Python、PyCharm安装及使用方法详解","keywords":"","body":"1.1. 一、下载安装Python3解释器1.2. 二、下载安装Pycharm社区版1.3. 三、mac上Pycharm使用教程1.3.1. 修改/调整python解释器1.1. 一、下载安装Python3解释器 使用Python3 Python之父Guido van Rossum在邮件列表上宣布 Python 2.7将于2020年1月1日终止支持。用户如果想要在这个日期之后继续得到与Python 2.7有关的支持，则需要付费给商业供应商。 **Guido van Rossum 表示：** Let's not play games with semantics.**The way I see the situation for 2.7 is that EOL is January 1st, 2020, and there will be no updates, not even source-only security patches, after that date.（Python 2.7提供的支持截止到2020年1月1日，并且在那之后将不会有更新，甚至没有源代码安全补丁。）**Support (from the core devs, the PSF, and python.org) stops completely on that date. If you want support for 2.7 beyond that day you will have to pay a commercial vendor. Of course it's open source so people are also welcome to fork it. But the core devs have toiled long enough, and the 2020 EOL date (an extension from the originally annouced 2015 EOL!) was announced with sufficient lead time and fanfare that I don't feel bad about stopping to support it at all. 1.mac环境安装Python3解释器 1.有linux系统命令基础的伙伴可以按照我下方教程步骤安装 2.无linux系统命令基础的伙伴请参考 百度经验：如何在Mac上安装Python3 百度经验连接：https://jingyan.baidu.com/article/4d58d54156e5069dd4e9c09b.html 1、查看 mac 自带系统版本 #查看系统自带的python open /System/Library/Frameworks/Python.framework/Versions #系统当前的python版本。 python -V 2、开始安装(这里我们使用神器homebrew) #安装前先搜索一下是否已经存在python3的包： brew search python3 #已经存在，我们可以直接安装了： brew install python3 #出现如下报错 Error: An unexpected error occurred during the `brew link` step The formula built, but is not symlinked into /usr/local Permission denied @ dir_s_mkdir - /usr/local/Frameworks Error: Permission denied @ dir_s_mkdir - /usr/local/Frameworks #手动创建一个这个目录 sudo mkdir /usr/local/Frameworks #再来解决权限问题： sudo chown $(whoami):admin /usr/local/Frameworks #手动执行一下安装时未完成的创建连接： brew link python3 #当前系统下的python3的信息： brew info python3 #系统当前的python版本。 python -V 2.修改mac当前系统的默认版本为Python3.*版本 #查找python3安装路径 brew info python3 #修改 Mac 系统配置文件 vi ~/.bash_profile #添加配置信息 # Setting PATH for Python 3.7 # Python3的环境变量 # The original version is saved in .bash_profile.pysave PATH=\"/Library/Frameworks/Python.framework/Versions/3.7/bin:${PATH}\" export PATH #编译系统配置文件 source ~/.bash_profile #系统当前的python版本。 python -V 下面是我的.bash_profile配置文件(避免有的伙伴看不懂，加了中文注释哦！) 虚拟环境、数据库的配置可以不用配置（不写上即可，没有安装写上会出错） # Setting PATH for Python 3.7 # Python3的环境变量 # The original version is saved in .bash_profile.pysave PATH=\"/Library/Frameworks/Python.framework/Versions/3.7/bin:${PATH}\" export PATH # ———————————下面的虚拟环境、数据库的配置可以不用配置（不写上即可，没有安装写上会出错）————————————————— # Setting virtualenv PATH for Python 3.7 # 虚拟环境的配置 export WORKON_HOME='~/workspace' export VIRTUALENVWRAPPER_SCRIPT=/Library/Frameworks/Python.framework/Versions/3.7/bin/virtualenvwrapper.sh export VIRTUALENVWRAPPER_PYTHON=/Library/Frameworks/Python.framework/Versions/3.7/bin/python3 export VIRTUALENVWRAPPER_VIRTUALENV=/Library/Frameworks/Python.framework/Versions/3.7/bin/virtualenv export VIRTUALENVWRAPPER_VIRTUALENV_ARGS='--no-site-packages' source /Library/Frameworks/Python.framework/Versions/3.7/bin/virtualenvwrapper.sh # setting MySQL PATH # MySQL数据库的环境变量配置 PATH=/usr/local/mysql/bin:$PATH export PATH 1.2. 二、下载安装Pycharm社区版 PyCharm官网点击【DOWNLOAD NOW】后，有看到分专业版（Professional）和社区版（Community），社区版是免费的，一般使用社区版的就可以了。 前往下载地址：https://www.jetbrains.com/pycharm/ 可以直接在首页中下载社区版 下载完成之后，双击打开，拖动到 mac 的应用列表中，和安装mac版其它软件是一样的操作。 若要使用专业付费版(土豪请随意)，请自行网上搜索。 下载完成后，安装过程和安装QQ等软件的过程是一样的，不要告诉我你不会，艹要是那样的话请出去补补课 1.3. 三、mac上Pycharm使用教程 Pycharm整体结构 工具栏中可以对IDE做一些设置 项目文件区主要是自己工程下的一些文件，还有Python依赖库 运行调试区可以用来运行、调试Python代码 代码区为自己编写代码的窗口 控制台主要用于显示一些打印信息，还有调试信息 创建项目 打开PyCharm，第一个按钮就是创建一个新的项目，第二个是选择打开已有的项目 接着选择创建一个Python项目，右边第一栏location是选择项目的存放地址，第二栏INterpreter是选择解释器，可以看到这里有两个Python版本，一个Python 2.7，一个是3.6，这取决你自己电脑里安装了几个Python 这里选择我们安装的Python3 下图是解释如何参看我们安装的Python3路径 项目创建成功后，还只是一个空的项目，需要向里面添加Python文件 创建文件名，点击OK 然后就可以在创建好的Python文件里，编写自己的代码了 1.3.1. 修改/调整python解释器 有时候拿到一个Python项目，可能不是自己想要的解释器版本，可以选择调整解释器版本 对整个项目调整其解释器 也可以对单独一个文件设置其解释器 执行Python文件 工具栏里选择执行run 右上角执行run 在代码区域右键选择run 在左边文件区域，选择要执行的文件，右键run 执行run之后，还可以在控制台重复执行run 如此，所示即表示安装完成 由于篇幅短小和时间仓促,若你发现了错误请告知我。 希望我没有误导你，而是带你看了小小的新世界。 更多资料欢迎访问我的博客：http://www.jiazhixiang.xyz Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-01-31 20:46:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"configuration/Windows系统Python解释器的安装配置.html":{"url":"configuration/Windows系统Python解释器的安装配置.html","title":"Windows系统Python解释器的安装配置","keywords":"","body":"1.1.1. 视屏教程：Windows系统Python解释器的安装配置1.1.1. 视屏教程：Windows系统Python解释器的安装配置 下载python解释器 如下图所示，在浏览器中打开python官方网站：https://www.python.org/ 点击Downloads进入下载页面 如下图所示： 目前Python解释器更新到了最新的Python3.8版本(Python3.8版本虽增加了一些新特性，但建议不要使用最新版本的)，想要下载早期的Python版本，向下滑动浏览器页面。 如下图所示：然后找到你想要安装的的Python解释器版本，点击对应版本的Download，跳转至下载页面 跳转页面后，继续向下滑动浏览器页面，找到如下图所示的对应位置下载你想要安装的的Python解释器版本 注：关于Python解释器版本的选择补充说明 附官方文档截图说明： 下载完成后选择软件包安装路径 注：路径最好不要出现中文 因为我的电脑只有一个C盘，所以为了方便管理安装的软件，我创建了一个software文件夹，然后再在software文件夹里创建对应安装包的安装文件夹 如下图：C:\\software\\python3.7 进行安装 出现如下安装界面 ​ 添加python解释器的环境变量 这里我们可以选择安装到自己指定的安装目录 ​ 点击进入指定目录安装，勾选的选项默认就好，不需修改 勾选的选项默认就好，不需修改 点击Browse修改Python解释器的默认安装路径 修改后的安装路径显示 点击Install进行安装 ​ ​ 如图所示即安装成功 测试是否安装成功 按下 win+R 组合键打开windows系统的命令终端 命令终端如下图所示 至此Python解释器即安装成功啦 由于篇幅短小和时间仓促,若你发现了错误请告知我。 希望我没有误导你，而是带你看了小小的新世界。 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-01-31 20:42:17 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"configuration/Windows系统安装配置Pycharm社区版.html":{"url":"configuration/Windows系统安装配置Pycharm社区版.html","title":"Windows系统安装配置Pycharm社区版","keywords":"","body":"1.1.1. 视屏教程：Windows系统安装配置Pycharm社区版1.1.2. 一、下载Pycharm社区版安装包1.1.1. 视屏教程：Windows系统安装配置Pycharm社区版 安装配置Pycharm前请先安装Python解释器 Windows系统Python解释器的安装配置视屏教程 使用Microsoft Store微软应用商店安装Python解释器视屏教程 1.1.2. 一、下载Pycharm社区版安装包 使⽤浏览器打开Pycharm官⽅⽹站：http://www.jetbrains.com/pycharm 跳转至如下页面 请选择对应的电脑操作系统进行下载 这里我们选择免费的社区版进行下载安装 找到下载的安装包进行安装 开始进行安装 修改默认的安装路径 等待安装完成 运行pycharm编辑器 主题设置——建议选择黑色（护眼） 如此，所示即表示安装完成 由于篇幅短小和时间仓促,若你发现了错误请告知我。 希望我没有误导你，而是带你看了小小的新世界。 更多资料欢迎访问我的博客：http://www.jiazhixiang.xyz Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-18 19:41:33 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"configuration/Windows系统安装配置Pycharm专业版.html":{"url":"configuration/Windows系统安装配置Pycharm专业版.html","title":"Windows系统安装配置Pycharm专业版","keywords":"","body":"1.1.1. 视屏教程：Windows系统安装配置Pycharm专业版1.1.2. 下载Pycharm1.1.3. 安装Pycharm1.1.4. 配置&激活Pycharm1.1.5. 激活Pycharm的两种方式1.1.6. 编写并运行你的第一个Python程序1.1.1. 视屏教程：Windows系统安装配置Pycharm专业版 安装配置Pycharm前请先安装Python解释器 Windows系统Python解释器的安装配置视屏教程 使用Microsoft Store微软应用商店安装Python解释器视屏教程 1.1.2. 下载Pycharm 使用浏览器打开Pycharm官方网站：http://www.jetbrains.com/pycharm 选择对应的系统安装包，点击DOWNLOAD进行下载(文档以Windows系统举例) 选择Pycharm软件包的安装位置 1.1.3. 安装Pycharm 运行Windows Denfender SmartScreen 更改Pycharm默认安装位置 选择自定义Pycharm安装位置 补充说明： 64-bit 表示跟64位操作系统相关(如下图所示) .py 表示关联后缀为.py的Python相关文件 等待安装完成 1.1.4. 配置&激活Pycharm 选择主题颜色 1.1.5. 激活Pycharm的两种方式 1.选择免费试用30天(如下图所示) 下面的『2.破解方法』已经失效，如需使用Pycharm专业版请移至官网或其他电商平台购买专业秘钥，Pycharm社区版是免费的，建议学习使用Pycharm社区版(请参考Windows系统安装配置Pycharm专业版社区版) 2.破解激活 通过搜索引擎搜索：lanyus 修改Windows系统的hosts文件 hosts文件所在路径：C:\\Windows\\System32\\drivers\\etc 获得’注册码‘ 如此即代表安装安装配置成功 1.1.6. 编写并运行你的第一个Python程序 修改程序的默认存放路径 修改完程序存放路径后，需要制定Python解释器 我的安装在C:\\software\\python3.7 找到 C:\\software\\python3.7 下的 python.exe > > 由于篇幅短小和时间仓促,若你发现了错误请告知我。 希望我没有误导你，而是带你看了小小的新世界。 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-18 19:41:42 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"configuration/Pycharm指定Python解释器配置说明.html":{"url":"configuration/Pycharm指定Python解释器配置说明.html","title":"Pycharm指定Python解释器配置说明","keywords":"","body":"1.1.1. 视屏教程：Pycharm指定Python解释器配置说明1.1.1. 视屏教程：Pycharm指定Python解释器配置说明 打开Pycharm编辑器 创建一个新程序 选择程序存放的位置 选择存放在桌面 创建first程序文件夹 指定Python解释器 创建单个程序 运行程序 如此，所示即表示安装完成 由于篇幅短小和时间仓促,若你发现了错误请告知我。 希望我没有误导你，而是带你看了小小的新世界。 更多资料欢迎访问我的博客：http://www.jiazhixiang.xyz Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-18 19:49:20 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"configuration/安装Ubuntu后要做的事.html":{"url":"configuration/安装Ubuntu后要做的事.html","title":"安装Ubuntu系统后要做的事","keywords":"","body":"1. 安装Ubuntu系统后要做的事1. 安装Ubuntu系统后要做的事 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 00:14:03 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"configuration/Ubuntu系统搭建配置Python虚拟开发环境.html":{"url":"configuration/Ubuntu系统搭建配置Python虚拟开发环境.html","title":"Ubuntu系统搭建配置Python虚拟开发环境","keywords":"","body":"1.1.1. 为什么使用 Virtualenv ？1.2. 搭建寻开发环境详细步骤1.2.1. 配置环境变量1.2.2. 创建虚拟开发环境1.1.1. 为什么使用 Virtualenv ？ 我们知道使用Python的过程中会安装各种库、包，甚至有时候还需要Python2和Python3两种环境混合使用，慢慢的你的Python运行环境会越来越臃肿，这倒还是其次，最可怕的是，有些应用会使用到某个Python包的特定版本，我们知道同一个Python运行环境里面是不能存在同一个包的不同版本的。所有这些都是你为什么要使用 Virtualenv的理由。 Virtualenv给你一个干净的Python运行环境，并能让你不同的应用,使用不同版本的包文件提供了可能，甚至使 用 它可以让Python2和Python3和谐地共存。对于我们来说，我们用它的原因主要有以下几点： 1.我们需要一个干净的Python环境，这个环境只针对我目前开发的应用； 2.我们不希望多安装一个和项目无关的包，也不希望出现和其它应用有包版本冲突的问题； 3.我们还需要生成一个requirements.txt用来告诉其他人我项目的依赖； 4.我们不希望使用pyinstaller打包发布的过程中，给我加进来一堆没有用处的文件。 1.搭建虚拟环境主要是为了保证环境得统一性，对于不同得应用建立专属得python环境，比如针对后台开发 得django可以建立一个虚拟环境，针对爬虫开发得应用可以在建立一个虚拟环境，避免环境之间产生冲突。 2.可以避免一个环境造成得安装包过的多，导致环境加载缓慢. 1.2. 搭建寻开发环境详细步骤 首先检查系统是否有安装pip 在终端输入如下命令： pip # 查看是否安装有pip pip --version# 查看安装的pip版本 ___________________________________ pip3 # 查看是否安装有pip pip3 --version # 查看安装的pip3版本 安装pip sudo apt install python-pip 安装pip3 sudo apt install python3-pip 安装 virtualenv 和 virtualenvwrapper 在终端输入如下命令： pip install virtualenv pip install virtualenvwrapper # 如果python2和python3共存，则需要同时安装 pip3 install virtualenv pip3 install virtualenvwrapper # virtualenvwrapper是virtualenv的扩展包，可以更⽅便的新增、删除、复制、切换虚 拟环境。 Python2的安装 Python3的安装 找到 virtualenvwrapper.sh 的路径 修改virtualenvwrapper.sh的路径 测试 python3 解释器能否正常导入 virtualenvwrapper 如下图所示即代表成功 1.2.1. 配置环境变量 修改 .bashrc 文件（mac电脑是 .bash_profile文件） 将下列内容添加到~/.bashrc 文件中 #Setting virtualenv PATH for python3 VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3 source /usr/local/bin/virtualenvwrapper.sh # virtualenvwrapper.sh的路径 export WORKON_HOME=\"/home/python/workspace\" # workspace是盛放虚拟环境的文件夹（根据自己的修改） # export WORKON_HOME=$HOME/.virtualenvs # 盛放虚拟环境的文件夹也可以设置为.virtualenvs 更新环境变量 执行source ~/.bashrc 1.2.2. 创建虚拟开发环境 Django虚拟环境 mkvitualenv -p python3 django_py3 AI虚拟环境 如此，虚拟环境即创建成功 由于篇幅短小和时间仓促,若你发现了错误请告知我。 希望我没有误导你，而是带你看了小小的新世界。 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-01-31 21:01:08 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"configuration/Vmware虚拟机安装和配置Ubuntu系统.html":{"url":"configuration/Vmware虚拟机安装和配置Ubuntu系统.html","title":"Vmware虚拟机安装和配置Ubuntu系统","keywords":"","body":"1.1.1. 一、Ubuntu的初步安装1.1.2. 二、Ubuntu系统安装设置1.1.3. 三、安装Vmware Tools1.1.4. 四、设置共享文件夹1.1.5. 五、修改Ubuntu系统的更新源1.1.6. 六、安装VIM编辑器1.1.7. 七、安装谷歌浏览器1.1.8. 八、安装Pycharm1.1.9. 九、安装MySQL数据库创建带有 SCSI 控制器类型、虚拟机磁盘类型以及与旧版 VMware 产品兼容性等高级选项的虚拟机 安装前准备： 安装好VMwareWorkstation Ubuntu16.04镜像文件 （下载地址链接：https://pan.baidu.com/s/1MSBBv9NOh7_cFgTMUQPEhQ 提取码：w6g7 ） Ubuntu18.04镜像文件 （下载地址链接：链接：https://pan.baidu.com/s/1uhPj0ttM9M7QxpR3Z4LI5g 提取码：il08 ） 若连接失效，请邮箱联系我 1.1.1. 一、Ubuntu的初步安装 创建新的虚拟机 点击下一步，如下图所示 选择兼容性版本 注意修改的信息 修改处理器配置信息，如下图所示 虚拟机内存配置，最低要求2GB,可以根据自己的需求修改，后期也可以再更改 此时，切记千万不要手快点开电源！！！ 1.1.2. 二、Ubuntu系统安装设置 设置加载镜像 这些完成后就可以直接开启虚拟机了 拖动窗口，点 continue 继续下一步 设置自己的用户名和密码 : 安装进行中，等待安装 点击 Restart Now 进行重启， 如果出现如下图所示的状况，导致无法进入系统界面，需要点击Vmware的重新启动客户机按钮进行重新启动 如下图所示： 如果出现如下情况，切记千万不要选择更新 在安装好的Ubuntu系统中鼠标右键选择 Open Terminal，打开Ubuntu系统的命令终端 然后，修改hosts文件 etc目录下的hosts文件 使用vim修改编辑hosts文件 sudo vi /etc/hosts 使用gedit修改编辑hosts文件 sudo gedit /etc/hosts 如此，即代表系统安装成功 1.1.3. 三、安装Vmware Tools 为了让系统能像下图一样适应客户机，需要安装Vmware Tools 在安装好的Ubuntu系统中鼠标右键选择 Open Terminal，打开Ubuntu系统的命令终端 获取管理员权限 输入以下命令，来获取管理员权限，密码是你在上面设置的密码：sudo passwd 前面我设置的密码是chuanzhi 如果上面你设置的密码不是chuanzhi,请输入你自己设置的密码 切换到 root 最高权限用户 安装Vmware tools工具 选择Vmware顶部工具栏里的 安装Vmware Tools（T）选项 在安装好的Ubuntu系统中鼠标右键选择 Open Terminal，打开Ubuntu系统的命令终端 打开终端后，进行下面设置 复制CD中的 VMwareTools-10.0.10-4301679.tar.gz 文件到根目录下： cp /media/user/VMware\\ Tools/VMwareTools-10.0.10-4301679.tar.gz / 然到移动到根目录： cd / 解压 VMwareTools-10.0.10-4301679.tar.gz： tar -zxvf VMwareTools-10.0.10-4301679.tar.gz 按下回车，执行解压 如下如所示 解压完成后进入解压文件夹vmware-tools-distrib cd vmware-tools-distrib 运行安装程序： ./vmware-install.pl 一路 y 加 回车 如下图所示 1.1.4. 四、设置共享文件夹 设置共享文件夹，可以实现Windows系统和Ubuntu系统的复制粘贴功能 在菜单栏找到虚拟机->设置，添加自己的共享文件夹 如此，即完成了Ubuntu系统的初步设置 1.1.5. 五、修改Ubuntu系统的更新源 更改apt源为国内源方法早就有了，内容大同小异，我们应当掌握其规律了，其实每一版内容不同的地方就是版本号（或者官方一点的说：系统代号），所以我们先了解下新版本的系统代号： 使用命令：lsb_release -c 得到本系统的系统代号，如下图所示： 同样的我们也可以得到之前任意版本的系统代号： Ubuntu 12.04 (LTS)代号为precise。 Ubuntu 14.04 (LTS)代号为trusty。 Ubuntu 15.04 代号为vivid。 Ubuntu 15.10 代号为wily。 Ubuntu 16.04 (LTS)代号为xenial。 所以这也就解释了为什么利用搜索引擎搜出来的那么多方案里面内容不尽相同的原因，因为大家更改apt安装源时用的系统不一样。 查看系统版本代号 lsb_release -a 注意：一定要对准自己的Ubuntu系统版本代号，检查是Ubuntu16.04还是Ubuntu18.04 下面分别提供Ubuntu16.04和ubuntu 18.04两个不同系统版本的阿里源 Ubuntu16.04对应阿里源 # deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricted deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties deb http://mirrors.aliyun.com/ubuntu/ xenial universe deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties deb http://archive.canonical.com/ubuntu xenial partner deb-src http://archive.canonical.com/ubuntu xenial partner deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse Ubuntu18.04对应阿里源 如果是Ubuntu18.04系统可以参照我的简书配置：https://www.jianshu.com/p/e5677ebd5341 deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse 修改系统更新源方法步骤如下： 首先备份Ubuntu系统的官方源文件 打开Ubuntu的命令终端，进入源文件 sources.list 所在的目录： 然后执行备份命令，执行 sudo cp sources.list sources.list.backup 对源文件内容进行备份，以防万一。 cd /etc/apt sudo cp sources.list sources.list.backup 修改源文件内容 将上述对应系统版本的阿里源的文件内容全部复制，使用 sudo vim sources.list 打开文件，输入 ggdG（vim操作指令）删除所有内容（这句指令可以理解为删除第一行到最后一行的的全部内容） sudo vim sources.list # 在 /etc/apt 目录下 ggdG # 使用vim打开 sources.list 文件后执行此命令 将复制的阿里源文件内容全部粘贴到文件中后，输入 : 然后再输入wq 保存退出。 值得注意的是 sources.list 文件的条目都是有格式的（通过上面的内容大家也看的出来），一般有如下形式： deb http://site.example.com/debian distribution component1 component2 component3 deb-src http://site.example.com/debian distribution component1 component2 component3 所以后面几个参数是对软件包的分类（Ubuntu下是main， restricted，universe ，multiverse这四个） 所以你把内容写成: deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed universe multiverse 上面之类的也是可以的，之前我有这个疑惑，所以在这里一并告知和我有一样疑惑的朋友。 更新源 使用 sudo apt-get update 即可更新获取阿里软件源 提供的软件列表 sudo apt-get update 更新软件 使用 sudo apt-get upgrade 即可跟新软件 sudo apt-get upgrade 如下图所示，即代表更新成功 1.1.6. 六、安装VIM编辑器 在Ubuntu系统的命令终端输入 sudo apt-get install vim 进行下载 检测是否安装成功 在命令终端输入 vim 回车 如上图所示，即代表安装成功 退出 vim 1.按下 ESC 键 2.再输入 ： 3.最后输入 q 或 wq 即可 4.回车 安装完成后的 vim 是默认不显示行号的 上图中在 /etc/vim/ 目录下打开的 输入 sudo vi vimrc后是不显示行号的，如下图所示 进入编辑界面后，按下 G 键（这是大写的 G）直接跳转到文件的最后一行 再次按下 i 键，进行编辑，输入 set number 如下图所示 退出 vim 1.按下 ESC 键 2.再输入 ： 3.最后输入 q 或 wq 即可 4.回车 检查设置行号是否生效 如此，即代表安装好修改配置成功 1.1.7. 七、安装谷歌浏览器 先下载谷歌浏览器的deb安装包 下载地址如下： https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 等待下载完成 安装谷歌浏览器需执行以下两步，回到终端输入以下命令 sudo apt install libappindicator1 libindicator7 关闭终端，打开下载的存放deb包的文件夹，空白处右键在这里打开终端 输入以下命令 sudo dpkg -i google-chrome-stable_current_amd64.deb 最后在终端中输入以下命令，修复依赖关系 sudo apt -f install 至此谷歌浏览器就安装好了，现在把它设置在快速启动栏 最后将其移动到快速启动栏的合适位置，右键点击图标锁定到启动器，左键拖动选择合适位置！ 至此，谷歌浏览器即安装成功 1.1.8. 八、安装Pycharm 下载地址：https://www.jetbrains.com/pycharm/download/#section=linux 右键安装包，点击“Extract Here”意思是提取到这里，相当于解压 提取完成后，会生成一个 pycharm-2019.1.1 的文件夹，然后双击进入该文件夹 ，空白处右键在这里打开终端 选择主题 到这里，我选择秘钥激活的方法 百度：lanyus http://idea.lanyus.com/ 修改 hosts 文件（hosts文件在 /etc 目录下） 0.0.0.0 account.jetbrains.com 0.0.0.0 www.jetbrains.com 将上面两行代码添加到，hosts文件中 添加后如下图所示 退出 vim 1.按下 ESC 键 2.再输入 ： 3.最后输入 q 或 wq 即可 4.回车 获取注册码后输入 指定Python3解释器（1） 指定Python3解释器（2） 可以通过在命令终端输入：whereis python找到系统的Python解释器路径 如此，Python3的解释器便指定完成 添加Pycharm桌面快捷方式 第一步 创建Pycharm.desktop文件并用gedit的打开 sudo gedit /usr/share/applications/Pycharm.desktop 然后就会弹出一个新框 第二步 粘贴下面的代码输入并保存 [Desktop Entry] Type=Application Name=Pycharm GenericName=Pycharm3 Comment=Pycharm3:The Python IDE Exec=sh /home/python/Downloads/pycharm-2019.1.1/bin/pycharm.sh Icon=/home/python/Downloads/pycharm-2019.1.1/bin/pycharm.png Terminal=pycharm Categories=Pycharm 注意一定要将Desktop Entry复制进去，也就是上面的全部都要复制进去 Exec 的路径是 pycharm.sh 的所在路径，即 pycharm 的启动文件 Icon 的路径是 pycharm.png 的所在路径，即 pycharm 的图标 我下载解压后的路径，如下图 路径：/home/python/Downloads/pycharm-2019.1.1/bin Exec 的路径是 pycharm.sh 的所在路径，即 pycharm 的启动文件 /home/python/Downloads/pycharm-2019.1.1/bin/pycharm.sh Icon 的路径是 pycharm.png 的所在路径，即 pycharm 的图标 /home/python/Downloads/pycharm-2019.1.1/bin/pycharm.png 创建的Pycharm.desktop文件如下 [Desktop Entry] Type=Application Name=Pycharm GenericName=Pycharm3 Comment=Pycharm3:The Python IDE Exec=sh /home/python/Downloads/pycharm-2019.1.1/bin/pycharm.sh Icon=/home/python/Downloads/pycharm-2019.1.1/bin/pycharm.png Terminal=pycharm Categories=Pycharm 修改完成后，即可发现Pycharm的快捷方式 如此，即表示配置成功 1.1.9. 九、安装MySQL数据库 有两种安装方法，请将两种方法都阅读完后，再选择其中的一种方式进行安装 方法一 使用命令安装MySQL数据库 安装前先更新软件包列表： 在终端执行如下命令： sudo apt-get update ../assets/data/Vmware虚拟机安装和配置Ubuntu系统/ 在Ubuntu16.04上安装MySQL： 在终端执行如下命令： sudo apt-get install mysql-server mysql-client 在安装过程中需要你输入MySQL管理员用户（root）密码，如下图 如上即代表安装完成 方法二 通过APT方式安装 说明：此种方式完全参考官方提供的教程: 地址：https://dev.mysql.com/doc/mysql-apt-repo-quick-guide/en/ 注意：通过APT方式安装的版本都是现在最新的版本，现在我安装的是5.7.18。通过这种方式安装好之后开机自启动都已经配置好，和命令行上的环境变量，无需手动配置。 下载官方提供的mysql-apt-config.deb包进行APT源设置，下载地址：https://dev.mysql.com/downloads/repo/apt/ 找到下载的包路径 输入如下命令： sudo dpkg -i mysql-apt-config_0.8.12-1_all.deb 运行之后会出现如下界面： 一般只需要默认，按方向键选择OK回车即可。 完成后使用以下命令从MySQL APT存储库更新包信息（此步骤是必需的）： sudo apt-get update 说明：官方说通过这个工具这样操作之后，安装MySQL时就是按照上面选择的来进行。 安装 通过以下命令安装MySQL sudo apt-get install mysql-server 这将安装MySQL服务器的包，以及客户端和数据库公共文件的包。 此时如果提示依赖不足，如下所示： 如果没出现依赖问题，那么就不需要使用此命令。 ​ 那么需要运行下面命令解决依赖问题 ​ sudo apt-get install -f ​ 安装MySQL时会一并安装如下所示的软件： 完成后再次运行 sudo apt-get install mysql-server 如果没出现依赖问题，那么就不需要使用此命令。 在安装过程中，系统会要求您为MySQL安装的root用户提供密码,输入即可,如下所示： 重要 确保记住您设置的root密码。想要稍后设置密码的用户可以在对话框中将 密码字段留空，只需按确定即可 ; 在这种情况下，对于使用Unix套接字文件的连接，将通过Socket Peer-Credential Pluggable Authentication对服务器的root访问进行身份 验证。您可以稍后使用程序mysql_secure_installation设置root密码 。 我这里密码设置为：mysql (为了避免忘记密码，建议设置为:mysql) MySQL8.0采用了新的加密方式，一定要注意，正是因为这个加密方式才导致Ubuntu18.04用设置的root密码登录不了MySQL，因为Ubuntu18.04的终端可能有问题，并不支持这个新的加密方式。幸好有界面可以让我们选择使用旧版本5.x的加密方式，所以果断选择采用5.x的加密方式。 确认密码 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-01-31 20:56:33 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Computer_Basics/":{"url":"Computer_Basics/","title":"计算机基础","keywords":"","body":"1. 1.计算机基础1. 1.计算机基础 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-01-31 14:41:36 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Computer_Basics/计算机组成原理.html":{"url":"Computer_Basics/计算机组成原理.html","title":"计算机组成原理","keywords":"","body":"1.1. 什么是计算机？1.2. 计算机是由什么组成的？1.2.1. 一、硬件系统：1.2.2. 二、软件系统：1.3. 三、计算机是如何处理程序的？1.4. 四、编程语言是什么？1.5. 五、什么是Python？1.1. 什么是计算机？ 计算机（computer）俗称电脑，是现代一种用于高速计算的电子机器，可以进行数值计算，又可以进行逻辑判断，还具有存储记忆功能，且能够按照程序的运行，自动、高速处理数据。 计算机是20世纪最先进的科学技术发明之一。 1.2. 计算机是由什么组成的？ 一个完整的计算机系统，是由硬件系统和软件系统两大部分组成的。 1.2.1. 一、硬件系统： 主要分为主机和外设两部分，是指那些构成计算机系统的物理实体，它们主要由各种各样的电子器件和机电装置组成。 从ENIAC(世界上第一台计算机)到当前最先进的计算机，硬件系统的设计采用的都是 冯·诺依曼体系结构。 运算器:　负责数据的算术运算和逻辑运算，即数据的加工处理。 控制器:　是整个计算机的中枢神经，分析程序规定的控制信息，并根据程序要求进行控制，协调计算机各部分组件工作及内存与外设的访问等。 运算器和控制器统称中央处理器（即CPU) 存储器:　实现记忆功能的部件，用来存储程序、数据和各种信号、命令等信息，并在需要时提供这些信息。 输入设备:　实现将程序、原始数据、文字、字符、控制命令或现场采集的数据等信息输入到计算机。 输出设备:　实现将计算机处理后生成的中间结果或最后结果（各种数据符号及文字或各种控制信号等信息）输出出来。 1.2.2. 二、软件系统： 主要分为系统软件和应用软件，是指计算机证运行所需的各种各样的计算机程序。 系统软件的任务是既要保证计算机硬件的正常工作，又要使计算机硬件的性能得到充分发挥，并且为计算机用户提供一个比较直观、方便和友好的使用界面。 操作系统：是一种方便用户管理和控制计算机软硬件资源的系统软件，同时也是一个大型的软件系统，其功能复杂，体系庞大，在整个计算机系统中具有承上启下的地位。我们操作计算机实际上是通过操作系统来进行的，它是所有软件的基础和核心。 语言处理程序：也称为编译程序，作用是把程序员用某种编程语言(如Python)所编写的程序，翻译成计算机可执行的机器语言。机器语言也被称为机器码，是可以通过CPU进行分析和执行的指令集。 1.3. 三、计算机是如何处理程序的？ 按照冯·诺依曼存储程序的原理，计算机的工作流程大致如下： 用户打开程序，程序开始执行； 操作系统将程序内容和相关数据送入计算机的内存； CPU根据程序内容从内存中读取指令； CPU分析、处理指令，并为取下一条指令做准备； 取下一条指令并分析、处理，如此重复操作，直至执行完程序中全部指令，最后将计算的结果放入指令指定的存储器地址中。 1.4. 四、编程语言是什么？ 是用来定义 计算机程序 的形式语言。我们通过编程语言来编写程序代码，再通过语言处理程序执行向计算机发送指令，让计算机完成对应的工作。 简单来说，编程语言就是人类和计算机进行交流的语言。 1.5. 五、什么是Python？ Python就是一门编程语言，而且是现在世界上最流行的编程语言之一。 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 15:08:10 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/":{"url":"python_basics/","title":"Python基础","keywords":"","body":"1. 2.Python基础1. 2.Python基础 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-01-31 14:41:37 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/认识Python.html":{"url":"python_basics/认识Python.html","title":"认识Python","keywords":"","body":"1. 认识python(了解)1.1. 一、Python发展背景1.2. 二、Python语言的诞生1.3. 三、关键点常识1.4. 四、Python优缺点1.4.1. 优点1.4.2. 缺点1.5. 五、Python应用场景1. 认识python(了解) 1.1. 一、Python发展背景 Python的作者，Guido von Rossum（吉多·范·罗苏姆，中国Python程序员都叫他 龟叔），荷兰人。1982年，龟叔从阿姆斯特丹大学获得了数学和计算机硕士学位。然而，尽管他算得上是一位数学家，但他更加享受计算机带来的乐趣。用他的话说，虽然拥有数学和计算机双料资质，他总趋向于做计算机相关的工作，并热衷于做任何和编程相关的事情。 在那个时候，龟叔接触并使用过诸如Pascal、C、Fortran等语言。这些语言的基本设计原则是让机器能更快运行。在80年代，虽然IBM和苹果已经掀起了个人电脑浪潮，但这些个人电脑的配置很低。比如早期的Macintosh，只有8MHz的CPU主频和128KB的RAM，一个大的数组就能占满内存。所有的编译器的核心是做优化，以便让程序能够运行。为了增进效率，语言也迫使程序员像计算机一样思考，以便能写出更符合机器口味的程序。在那个时代，程序员恨不得用手榨取计算机每一寸的能力。有人甚至认为C语言的指针是在浪费内存。至于动态类型，内存自动管理，面向对象…… 别想了，那会让你的电脑陷入瘫痪。 这种编程方式让龟叔感到苦恼。龟叔知道如何用C语言写出一个功能，但整个编写过程需要耗费大量的时间，即使他已经准确的知道了如何实现。他的另一个选择是shell。Bourne Shell作为UNIX系统的解释器已经长期存在。UNIX的管理员们常常用shell去写一些简单的脚本，以进行一些系统维护的工作，比如定期备份、文件系统管理等等。shell可以像胶水一样，将UNIX下的许多功能连接在一起。许多C语言下上百行的程序，在shell下只用几行就可以完成。然而，shell的本质是调用命令。它并不是一个真正的语言。比如说，shell没有数值型的数据类型，加法运算都很复杂。总之，shell不能全面的调动计算机的功能。 龟叔希望有一种语言，这种语言能够像C语言那样，能够全面调用计算机的功能接口，又可以像shell那样，可以轻松的编程。ABC语言让龟叔看到希望。ABC是由荷兰的数学和计算机研究所开发的。龟叔在该研究所工作，并参与到ABC语言的开发。ABC语言以教学为目的。与当时的大部分语言不同，ABC语言的目标是“让用户感觉更好”。ABC语言希望让语言变得容易阅读，容易使用，容易记忆，容易学习，并以此来激发人们学习编程的兴趣。比如下面是一段来自Wikipedia的ABC程序，这个程序用于统计文本中出现的词的总数： HOW TO RETURN words document: PUT {} IN collection FOR line IN document: FOR word IN split line: IF word not.in collection: INSERT word IN collection RETURN collection HOW TO用于定义一个函数。一个Python程序员应该很容易理解这段程序。ABC语言使用冒号和缩进来表示程序块。行 尾没有分号。for和if结构中也没有括号() 。赋值采用的是PUT，而不是更常见的等号。这些改动让ABC程序读起来像一段文字。 尽管已经具备了良好的可读性和易用性，ABC语言最终没有流行起来。在当时，ABC语言编译器需要比较高配置的电脑才能运行。而这些电脑的使用者通常精通计算机，他们更多考虑程序的效率，而非它的学习难度。除了硬件上的困难外，ABC语言的设计也存在一些致命的问题： 可拓展性差。ABC语言不是模块化语言。如果想在ABC语言中增加功能，比如对图形化的支持，就必须改动很多地方。 不能直接进行IO。ABC语言不能直接操作文件系统。尽管你可以通过诸如文本流的方式导入数据，但ABC无法直接读写文 件。输入输出的困难对于计算机语言来说是致命的。你能想像一个打不开车门的跑车么？ 过度革新。ABC用自然语言的方式来表达程序的意义，比如上面程序中的HOW TO 。然而对于程序员来说，他们更习惯 用function或者define来定义一个函数。同样，程序员更习惯用等号来分配变量。尽管ABC语言很特别，但学习难度 也很大。 传播困难。ABC编译器很大，必须被保存在磁带上。当时龟叔在访问的时候，就必须有一个大磁带来给别人安装ABC编 译器。 这样，ABC语言就很难快速传播。 1989年，为了打发圣诞节假期，龟叔开始写Python语言的编译器。Python这个名字，来自龟叔所挚爱的电视剧Monty Python's Flying Circus。他希望这个新的叫做Python的语言，能符合他的理想：创造一种C和shell之间，功能全面，易学易用，可拓展的语言。龟叔作为一个语言设计爱好者，已经有过设计语言的尝试。这一次，也不过是一次纯粹的hacking行为。 1.2. 二、Python语言的诞生 1991年，第一个Python编译器诞生。它是用C语言实现的，并能够调用C语言的库文件。从一出生，Python已经具有了 ：类，函数，异常处理，包含表和词典在内的核心数据类型，以及模块为基础的拓展系统。 Python语法很多来自C，但又受到ABC语言的强烈影响。来自ABC语言的一些规定直到今天还富有争议，比如强制缩进。 但这些语法规定让Python容易读。另一方面，Python聪明的选择服从一些惯例，特别是C语言的惯例，比如回归等号赋值。龟叔认为，如果“常识”上确立的东西，没有必要过度纠结。 Python从一开始就特别在意可拓展性。Python可以在多个层次上拓展。从高层上，你可以直接引入. py文件。在底层，你可以引用C语言的库。Python程序员可以快速的使用Python写. py文件作为拓展模块。但当性能是考虑的重要因素时，Python程序员可以深入底层，写C程序，编译为.so文件引入到Python中使用。Python就好像是使用钢构建房一样，先规定好大的框架。而程序员可以在此框架下相当自由的拓展或更 改。 最初的Python完全由龟叔本人开发。Python得到龟叔同事的欢迎。他们迅速的反馈使用意见，并参与到Python的改进。龟叔和一些同事构成Python的核心团队。他们将自己大部分的业余时间用于hack Python。随后，Python拓 展到研究所之外。Python将许多机器层面上的细节隐藏，交给编译器处理，并凸显出逻辑层面的编程思考。Python程 序员可以花更多的时间用于思考程序的逻辑，而不是具体的实现细节。这一特征吸引了广大的程序员。Python开始流行。 人生苦短，我用python 计算机硬件越来越强大，Python又容易使用，所以许多人开始转向Python。龟叔维护了一个mail list，Python用户就通过邮件进行交流。Python用户来自许多领域，有不同的背景，对Python也有不同的需求。Python相当的开放，又容 易拓展，所以当用户不满足于现有功能，很容易对Python进行拓展或改造。随后，这些用户将改动发给龟叔，并由龟叔决定是否将新的特征加入到Python或者标准库中。如果代码能被纳入Python自身或者标准库，这将极大的荣誉。由于龟叔至高无上的决定权，他因此被称为“终身的仁慈独裁者”。 Python以及其标准库的功能强大。这些是整个社区的贡献。Python的开发者来自不同领域，他们将不同领域的优点带给Python。比如Python标准库中的正则表达是参考Perl，而lambda, map, filter, reduce等函数参考了Lisp。Python本身的一些功能以及大部分的标准库来自于社区。Python的社 区不断扩大，进而拥有了自己的newsgroup，网站，以及基金。从Python 2.0开始，Python也从mail list的开发方式，转为完全开源的开发方式。社区气氛已经形成，工作被整个社区分担，Python也获得了更加高速的发展。 到今天，Python的框架已经确立。Python语言以对象为核心组织代码，支持多种编程范式，采用动态类型，自动进行内存回收。Python支持解释运行，并能调用C库进行拓展。Python有强大的标准库。由于标准库的体系已经稳定，所以Python的生态系统开始拓展到第三方包。这些包，如Django、web.py、wxpython、numpy、matplotlib、PIL，将Python升级成了物种丰富的热带雨林。 Python崇尚优美、清晰、简单，是一个优秀并广泛使用的语言。Python在TIOBE排行榜中排行第八，它是Google的第三大开发语言，Dropbox的基础语言，豆瓣的服务器语言。Python的发展史可以作为一个代表，带给我许多启示。 在Python的开发过程中，社区起到了重要的作用。龟叔自认为自己不是全能型的程序员，所以他只负责制订框架。如果问题太复杂，他会选择绕过去，也就是cut the corner。这些问题最终由社区中的其他人解决。社区中的人才是异常丰富的，就连创建网站，筹集基金这样与开发稍远的事情，也有人乐意于处理。如今的项目开发越来越复杂，越来越庞大，合作以及开放的心态成为项目最终成功的关键。 Python从其他语言中学到了很多，无论是已经进入历史的ABC，还是依然在使用的C和Perl，以及许多没有列出的其他 语言。可以说，Python的成功代表了它所有借鉴的语言的成功。同样，Ruby借鉴了Python，它的成功也代表了Python某些方面的成功。每个语言都是混合体，都有它优秀的地方，但也有各种各样的缺陷。同时，一个语言“好与不好”的评判，往往受制于平台、硬件、时代等等外部原因。程序员经历过许多语言之争。其实，以开放的心态来接受各个语言，说不定哪一天，程序员也可以如龟叔那样，混合出自己的语言。 1.3. 三、关键点常识 Python的发音与拼写 Python的作者是Guido van Rossum（龟叔） Python正式诞生于1991年 Python的解释器如今有多个语言实现，我们常用的是CPython（官方版本的C语言实现），其他还有Jython（可以运行在Java平台）、IronPython（可以运行在.NET和Mono平台）、PyPy（Python实现的，支持JIT即时编译） Python目前有两个版本，Python2和Python3，最新版分别为2.7和3.8 Life is shot, you need Python. 人生苦短，我用Python。 （TIOBE 编程语言流行排行榜） 1.4. 四、Python优缺点 1.4.1. 优点 简单：Python是一种代表简单主义思想的语言。阅读一个良好的Python程序就感觉像是在读英语一样，尽管这个英语的要求非常严格！Python的这种伪代码本质是它最大的优点之一。它使你能够专注于解决问题而不是去搞明白语言本身。 易学：就如同你即将看到的一样，Python极其容易上手。前面已经提到了，Python有极其简单的语法。 免费、开源：Python是FLOSS（自由/开放源码软件）之一。简单地说，你可以自由地发布这个软件的拷贝、阅读它的源代码、对它做改动、把它的一部分用于新的自由软件中。FLOSS是基于一个团体分享知识的概念。这是为什么Python如此优秀的原因之一——它是由一群希望看到一个更加优秀的Python的人创造并经常改进着的。 高层语言：当你用Python语言编写程序的时候，你无需考虑诸如如何管理你的程序使用的内存一类的底层细节。 可移植性：由于它的开源本质，Python已经被移植在许多平台上（经过改动使它能够工作在不同平台上）。如果你小心地避免使用依赖于系统的特性，那么你的所有Python程序无需修改就可以在下述任何平台上面运行。这些平台包括Linux、Windows、FreeBSD、Macintosh、Solaris、OS/2、Amiga、AROS、AS/400、BeOS、OS/390、z/OS、Palm OS、QNX、VMS、Psion、Acom RISC OS、VxWorks、PlayStation、Sharp Zaurus、Windows CE甚至还有PocketPC、Symbian以及Google基于linux开发的Android平台！ 解释型语言：一个用编译型语言比如C或C++写的程序可以从源文件（即C或C++语言）转换到一个你的计算机使用的语言（二进制代码，即0和1）。这个过程通过编译器和不同的标记、选项完成。当你运行你的程序的时候，连接/转载器软件把你的程序从硬盘复制到内存中并且运行。而Python语言写的程序不需要编译成二进制代码。你可以直接从源代码运行程序。在计算机内部，Python解释器把源代码转换成称为字节码的中间形式，然后再把它翻译成计算机使用的机器语言并运行。事实上，由于你不再需要担心如何编译程序，如何确保连接转载正确的库等等，所有这一切使得使用Python更加简单。由于你只需要把你的Python程序拷贝到另外一台计算机上，它就可以工作了，这也使得你的Python程序更加易于移植。 面向对象：Python既支持面向过程的编程也支持面向对象的编程。在“面向过程”的语言中，程序是由过程或仅仅是可重用代码的函数构建起来的。在“面向对象”的语言中，程序是由数据和功能组合而成的对象构建起来的。与其他主要的语言如C++和Java相比，Python以一种非常强大又简单的方式实现面向对象编程。 可扩展性：如果你需要你的一段关键代码运行得更快或者希望某些算法不公开，你可以把你的部分程序用C或C++编写，然后在你的Python程序中使用它们。 丰富的库：Python标准库确实很庞大。它可以帮助你处理各种工作，包括正则表达式、文档生成、单元测试、线程、数据库、网页浏览器、CGI、FTP、电子邮件、XML、XML-RPC、HTML、WAV文件、密码系统、GUI（图形用户界面）、Tk和其他与系统有关的操作。记住，只要安装了Python，所有这些功能都是可用的。这被称作Python的“功能齐全”理念。除了标准库以外，还有许多其他高质量的库，如wxPython、Twisted和Python图像库等等。 规范的代码：Python采用强制缩进的方式使得代码具有极佳的可读性。 1.4.2. 缺点 Python语言非常完善，没有明显的短板和缺点，唯一的缺点就是执行效率慢，这个是解释型语言所通有的，同时这个缺点也将被计算机越来越强大的性能所弥补。 1.5. 五、Python应用场景 Web应用开发 Python经常被用于Web开发。比如，通过mod_wsgi模块，Apache可以运行用Python编写的Web程序。Python定义了WSGI标准应用接口来协调Http服务器与基于Python的Web程序之间的通信。一些Web框架，如Django,TurboGears,web2py,Zope等，可以让程序员轻松地开发和管理复杂的Web程序。 操作系统管理、服务器运维的自动化脚本 在很多操作系统里，Python是标准的系统组件。 大多数Linux发行版以及NetBSD、OpenBSD和Mac OS X都集成了Python，可以在终端下直接运行Python。有一些Linux发行版的安装器使用Python语言编写，比如Ubuntu的Ubiquity安装器,Red Hat Linux和Fedora的Anaconda安装器。Gentoo Linux使用Python来编写它的Portage包管理系统。Python标准库包含了多个调用操作系统功能的库。通过pywin32这个第三方软件 包，Python能够访问Windows的COM服务及其它Windows API。使用IronPython，Python程序能够直接调用.Net Framework。一般说来，Python编写的系统管理脚本在可读性、性能、代码重用度、扩展性几方面都优于普通的shell脚本。 网络爬虫 Python有大量的HTTP请求处理库和HTML解析库，并且有成熟高效的爬虫框架Scrapy和分布式解决方案scrapy-redis，在爬虫的应用方面非常广泛。 科学计算 NumPy、SciPy、Pandas、Matplotlib可以让Python程序员编写科学计算程序。 桌面软件 PyQt、PySide、wxPython、PyGTK是Python快速开发桌面应用程序的利器。 服务器软件（网络软件） Python对于各种网络协议的支持很完善，因此经常被用于编写服务器软件、网络爬虫。第三方库Twisted支持异步网络编程和多数标准的网络协议(包含客户端和服务器)，并且提供了多种工具，被广泛用于编写高性能的服务器软件。 游戏 很多游戏使用C++编写图形显示等高性能模块，而使用Python或者Lua编写游戏的逻辑、服务器。相较于Python，Lua的功能更简单、体积更小；而Python则支持更多的特性和数据类型。 构思实现，产品早期原型和迭代 Google、NASA、Facebook都在内部大量地使用Python。 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 15:22:06 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/第一个Python程序.html":{"url":"python_basics/第一个Python程序.html","title":"第一个Python程序","keywords":"","body":"1.1. 使用Pycharm编写第一个python程序1.2. 练一练1.1. 使用Pycharm编写第一个python程序 在继续阅读之前，请确保你已经成功的安装并配置好了Python的相关开发环境。 打开 Pycharm，选择 Create New Project，创建一个新项目 选择Pure Python表示创建一个纯Python程序项目, Location 表示该项目保存的路径，Interpreter 表示使用的Python解释器版本，最后点击Create 创建项目。 右击项目，选择New，再选择Python File 在弹出的对话框中输入的文件名HelloPython，点击OK，表示创建一个Python程序的文本文件，文本文件后缀名默认.py 输入以下代码，并右击空白处，选择Run运行，表示打印一个字符串\"Hello World!\"。 print(\"Hello World!\") 运行成功后，Pycharm Console窗口将显示我们的输出结果。 1.2. 练一练 要求：编写一个程序，输出你好啊，Python，这是我的第一个Python程序 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-25 18:53:11 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/注释.html":{"url":"python_basics/注释.html","title":"注释的使用","keywords":"","body":"1.1. 1. 注释的引入1.1.1. 看以下程序示例（未使用注释）1.1.2. 看以下程序示例（使用注释）1.1.3. 小总结（注释的作用）1.2. 2. 注释的分类1.2.1. 单行注释1.2.2. 多行注释1.2.3. python程序中，中文支持1.1. 1. 注释的引入 1.1.1. 看以下程序示例（未使用注释） 1.1.2. 看以下程序示例（使用注释） 1.1.3. 小总结（注释的作用） 通过用自己熟悉的语言，在程序中对某些代码进行标注说明，这就是注释的作用，能够大大增强程序的可读性 1.2. 2. 注释的分类 1.2.1. 单行注释 以#开头，#右边的所有东西当做说明，而不是真正要执行的程序，起辅助说明作用 # 我是注释，可以在里写一些功能说明之类的哦 print('hello world') 1.2.2. 多行注释 ''' 我是多行注释，可以写很多很多行的功能说明 下面的代码完成 ，打印一首诗 名字叫做：春江花月夜 ''' print('╔═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╗') print('║　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│ ║') print('║　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　║') print('║　│春│滟│江│空│江│江│人│不│白│谁│可│玉│此│鸿│昨│江│斜│不│　║') print('║　│江│滟│流│里│天│畔│生│知│云│家│怜│户│时│雁│夜│水│月│知│　║') print('║　│潮│随│宛│流│一│何│代│江│一│今│楼│帘│相│长│闲│流│沉│乘│　║') print('║　│水│波│转│霜│色│人│代│月│片│夜│上│中│望│飞│潭│春│沉│月│　║') print('║　│连│千│绕│不│无│初│无│待│去│扁│月│卷│不│光│梦│去│藏│几│　║') print('║春│海│万│芳│觉│纤│见│穷│何│悠│舟│徘│不│相│不│落│欲│海│人│　║') print('║江│平│里│甸│飞│尘│月│已│人│悠│子│徊│去│闻│度│花│尽│雾│归│　║') print('║花│，│，│，│，│，│，│，│，│，│，│，│，│，│，│，│，│，│，│　║') print('║月│海│何│月│汀│皎│江│江│但│青│何│应│捣│愿│鱼│可│江│碣│落│　║') print('║夜│上│处│照│上│皎│月│月│见│枫│处│照│衣│逐│龙│怜│潭│石│月│　║') print('║　│明│春│花│白│空│何│年│长│浦│相│离│砧│月│潜│春│落│潇│摇│　║') print('║　│月│江│林│沙│中│年│年│江│上│思│人│上│华│跃│半│月│湘│情│　║') print('║　│共│无│皆│看│孤│初│望│送│不│明│妆│拂│流│水│不│复│无│满│　║') print('║　│潮│月│似│不│月│照│相│流│胜│月│镜│还│照│成│还│西│限│江│　║') print('║　│生│明│霰│见│轮│人│似│水│愁│楼│台│来│君│文│家│斜│路│树│　║') print('║　│。│。│。│。│。│？│。│。│。│？│。│。│。│。│。│。│。│。│　║') print('║　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　║') print('║　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　║') print('╚═╧═╧═╧═╧═╧═╧═╧═╧═╧═╧═╧═╧═╧═╧═╧═╧═╧═╧═╧═╝') 1.2.3. python程序中，中文支持 python3中，是默认支持中文的，但是在python2中就需要一定的额外操作才可以 python2中，如果直接在程序中用到了中文，比如 print('你好') 如果直接运行输出，程序可能会出错： # 报错如下： SyntaxError: Non-ASCII character ‘\\xe4 ’ in file TestPy3/t.py 解决的办法为：在程序的开头写入如下代码，这就是中文注释 #coding=utf-8 修改之后的程序: #coding=utf-8 print('你好') 运行结果: 你好 注意： 在python的语法规范中推荐使用的方式： # -*- coding:utf-8 -*- Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-27 21:06:31 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/变量以及数据类型.html":{"url":"python_basics/变量以及数据类型.html","title":"变量以及类型","keywords":"","body":"1. 变量以及类型1.1. 变量的定义1.2. 变量的类型1. 变量以及类型 1.1. 变量的定义 在程序中，有时我们需要对2个数据进行求和，那么该怎样做呢？ 大家类比一下现实生活中，比如去超市买东西，往往咱们需要一个菜篮子，用来进行存储物品，等到所有的物品都购买完成后，在收银台进行结账即可 如果在程序中，需要把2个数据，或者多个数据进行求和的话，那么就需要把这些数据先存储起来，然后把它们累加起来即可 在Python中，存储一个数据，需要一个叫做变量的东西，如下示例: num1 = 100 # num1就是一个变量，就好比如一个小菜篮子 num2 = 87 # num2也是一个变量 result = num1 + num2 # 把num1和num2这两个\"菜篮子\"中的数据进行累加，然后放到 result变量中 说明: 所谓变量，可以理解为菜篮子，如果需要存储多个数据，最简单的方式是有多个变量，当然了也可以使用一个 程序就是用来处理数据的，而变量就是用来存储数据的 想一想：我们应该让变量占用多大的空间，保存什么样的数据？ 1.2. 变量的类型 生活中的“类型”的例子: 程序中: 为了更充分的利用内存空间以及更有效率的管理内存，变量是有不同的类型的，如下所示: 怎样知道一个变量的类型呢？ 在python中，只要定义了一个变量，而且它有数据，那么它的类型就已经确定了，不需要咱们开发者主动的去说明它的类型，系统会自动辨别 可以使用type()函数：type(变量的名字)，来查看变量的类型 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-25 19:32:58 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/标识符和关键字.html":{"url":"python_basics/标识符和关键字.html","title":"标识符和关键字","keywords":"","body":"1. 标识符和关键字1.1. 标识符1.2. 标识符的规则1.3. 命名规则1.4. 关键字1. 标识符和关键字 1.1. 标识符 什么是标识符，看下图: 开发人员在程序中自定义的一些符号和名称 标识符是自己定义的,如变量名 、函数名等 1.2. 标识符的规则 标识符由字母、下划线和数字组成，且数字不能开头 思考：下面的标识符哪些是正确的，哪些不正确为什么 fromNo12 from#12 my_Boolean my-Boolean Obj2 2ndObj myInt test1 Mike2jack My_tExt _test test!32 haha(da)tt int jack_rose jack&rose GUI G.U.I python中的标识符是区分大小写的 1.3. 命名规则 见名知意 起一个有意义的名字，尽量做到看一眼就知道是什么意思(提高代码可读性) 比如: 名字 就定义为 name , 学生 就用 student 定义 驼峰命名法 小驼峰式命名法（lower camel case）： 第一个单词以小写字母开始；第二个单词的首字母大写，例如：myName、aDog 大驼峰式命名法（upper camel case）： 每一个单字的首字母都采用大写字母，例如：FirstName、LastName 还有一种命名法是用下划线“_”来连接所有的单词，比如send_buf， Python的命令规则遵循PEP8标准，这个在后面会慢慢讲到。 1.4. 关键字 什么是关键字 python一些具有特殊功能的标识符，这就是所谓的关键字 关键字，是python已经使用的了，所以不允许开发者自己定义和关键字相同的名字的标识符 查看关键字: and as assert break class continue def del elif else except exec finally for from global if in import is lambda not or pass print raise return try while with yield 可以在Python Shell通过以下命令进行查看当前系统中python的关键字 >>> import keyword >>> keyword.kwlist 关键字的学习以及使用，咱们会在后面的课程中依一一进行学习。 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-25 19:37:12 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/输出.html":{"url":"python_basics/输出.html","title":"输出","keywords":"","body":"1. 输出1.1. 1. 普通的输出1.2. 2. 格式化输出1.2.1. 格式化操作的目的1.2.2. 什么是格式化1.2.3. 常用的格式符号1.3. 3. 换行输出1.4. 4. 练一练1. 输出 1.1. 1. 普通的输出 生活中的“输出” 软件中的“输出” python中变量的输出 # 打印提示 print('hello world') print('萨瓦迪卡---泰语，你好的意思') 1.2. 2. 格式化输出 1.2.1. 格式化操作的目的 比如有以下代码: pirnt(\"我今年10岁\") pirnt(\"我今年11岁\") pirnt(\"我今年12岁\") ... 想一想: 在输出年龄的时候，用了多次\"我今年xx岁\"，能否简化一下程序呢？？？ 答: 字符串格式化 1.2.2. 什么是格式化 看如下代码: age = 10 print(\"我今年%d岁\" % age) age += 1 print(\"我今年%d岁\" % age) age += 1 print(\"我今年%d岁\" % age) ... 在程序中，看到了%这样的操作符，这就是Python中格式化输出。 age = 18 name = \"xiaoming\" print(\"我的姓名是%s, 年龄是%d\" % (name, age)) 1.2.3. 常用的格式符号 下面是完整的，它可以与％符号使用列表: 格式符号 转换 %c 字符 %s 字符串 %d 有符号十进制整数 %u 无符号十进制整数 %o 八进制整数 %x 十六进制整数（小写字母0x） %X 十六进制整数（大写字母0X） %f 浮点数 %e 科学计数法（小写'e'） %E 科学计数法（大写“E”） %g ％f和％e 的简写 %G ％f和％E的简写 1.3. 3. 换行输出 \\n转义字符 在输出的时候，如果有\\n那么，此时\\n后的内容会在另外一行显示 print(\"1234567890-------\") # 会在一行显示 print(\"1234567890\\n-------\") # 一行显示1234567890，另外一行显示------- 1.4. 4. 练一练 编写代码完成以下名片的显示 ==========我的名片========== 姓名: python QQ:xxxxxxx 手机号:155xxxxxx 公司地址:北京市xxxx =========================== Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-25 19:47:28 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/输入.html":{"url":"python_basics/输入.html","title":"输入","keywords":"","body":"1. 输入1.1. 1. python2版本中1.1.1. 1.1 raw_input()1.1.2. 1.2 input()1.2. 2. python3版本中1. 输入 1.1. 1. python2版本中 咱们在银行ATM机器前取钱时，肯定需要输入密码，对不？ 那么怎样才能让程序知道咱们刚刚输入的是什么呢？？ 大家应该知道了，如果要完成ATM机取钱这件事情，需要先从键盘中输入一个数据，然后用一个变量来保存，是不是很好理解啊 1.1.1. 1.1 raw_input() 注意：raw_input()是在Python2版本中的输入函数 在Python2中，获取键盘输入的数据的方法是采用 raw_input 函数（至于什么是函数，咱们以后的章节中讲解），那么这个 raw_input 怎么用呢? 看如下示例: password = raw_input(\"请输入密码:\") # 小括号中放入的是，提示信息 print'您刚刚输入的密码是:%d' % password 运行结果: >>> password = raw_input() 请输入密码:123456 >>> print password 您刚刚输入的密码是:123456 注意: raw_input()的小括号中放入的是，提示信息，用来在获取数据之前给用户的一个简单提示 raw_input()在从键盘获取了数据以后，会存放到等号右边的变量中 raw_input()会把用户输入的任何值都作为字符串来对待 1.1.2. 1.2 input() Python3版本中的输入函数 input()函数与raw_input()类似，但其接受的输入必须是表达式。 >>> a = input() 123 >>> a 123 >>> type(a) >>> a = input() abc Traceback (most recent call last): File \"\", line 1, in File \"\", line 1, in NameError: name 'abc' is not defined >>> a = input() \"abc\" >>> a 'abc' >>> type(a) >>> a = input() 1+3 >>> a 4 >>> a = input() \"abc\"+\"def\" >>> a 'abcdef' >>> value = 100 >>> a = input() value >>> a 100 input()接受表达式输入，并把表达式的结果赋值给等号左边的变量 1.2. 2. python3版本中 没有raw_input()函数，只有input() 并且 python3中的input与python2中的raw_input()功能一样 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-29 19:43:36 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/运算符.html":{"url":"python_basics/运算符.html","title":"运算符","keywords":"","body":"1. 运算符1.1.1. 1. 算术运算符1.1.2. 2. 赋值运算符1. 运算符 python支持以下几种运算符 1.1.1. 1. 算术运算符 下面以a=10 ,b=20为例进行计算 运算符 描述 实例 + 加 两个对象相加 a + b 输出结果 30 - 减 得到负数或是一个数减去另一个数 a - b 输出结果 -10 * 乘 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 200 / 除 b / a 输出结果 2 // 取整除 返回商的整数部分 9//2 输出结果 4 , 9.0//2.0 输出结果 4.0 % 取余 返回除法的余数 b % a 输出结果 0 ** 指数 a**b 为10的20次方， 输出结果 100000000000000000000 注意：混合运算时，优先级顺序为： ** 高于 * / % // 高于 + - ，为了避免歧义，建议使用 () 来处理运算符优先级。 并且，不同类型的数字在进行混合运算时，整数将会转换成浮点数进行运算。 >>> 10 + 5.5 * 2 21.0 >>> 10 + (5.5 * 2) 21.0 1.1.2. 2. 赋值运算符 运算符 描述 实例 = 赋值运算符 把 = 号右边的结果 赋给 左边的变量，如 num = 1 + 2 * 3，结果num的值为7 # 单个变量赋值 >>> num = 10 >>> num 10 # 多个变量赋值 >>> num1, num2, f1, str1 = 100, 200, 3.14, \"hello\" >>> num1 100 >>> num2 200 >>> f1 3.14 >>> str1 \"hello\" 复合赋值运算符 运算符 描述 实例 += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c = a 等效于 c = c a /= 除法赋值运算符 c /= a 等效于 c = c / a %= 取模赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c = a 等效于 c = c a //= 取整除赋值运算符 c //= a 等效于 c = c // a Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 16:05:54 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/数据类型转换.html":{"url":"python_basics/数据类型转换.html","title":"数据类型转换","keywords":"","body":"1. 常用的数据类型转换1.1. 举例1. 常用的数据类型转换 函数 说明 int(x [,base ]) 将x转换为一个整数 float(x ) 将x转换为一个浮点数 complex(real [,imag ]) 创建一个复数，real为实部，imag为虚部 str(x ) 将对象 x 转换为字符串 repr(x ) 将对象 x 转换为表达式字符串 eval(str ) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s ) 将序列 s 转换为一个元组 list(s ) 将序列 s 转换为一个列表 chr(x ) 将一个整数转换为一个Unicode字符 ord(x ) 将一个字符转换为它的ASCII整数值 hex(x ) 将一个整数转换为一个十六进制字符串 oct(x ) 将一个整数转换为一个八进制字符串 bin(x ) 将一个整数转换为一个二进制字符串 1.1. 举例 >>> # int(): 将数据转换为 int 类型 ... >>> str1 = \"10\" >>> # int() 默认按10进制转换后显示 ... num1 = int(str1) >>> >>> # int() 处理浮点数，只留下整数部分，舍弃小数部分（并不是四舍五入操作） ... num2 = int(3.74) >>> print(num2) 3 >>> >>> \"\"\" ... num1 = int(str1, 8) # 第二个参数为8，表示按8进制转换后显示，结果为 8 ... num1 = int(str1, 16) # # 第二个参数为16，表示按16进制转换后显示，结果为 16 ... #01 02 03 04 05 06 07 10 ... #01 02 ... 0B 0C 0D 0E 0F 10 ... print(num1) ... \"\"\" >>> >>> # float() 将数据转化为浮点数 ... str2 = \"3.14\" >>> f1 = float(str2) >>> print(type(f1)) >>> >>> f2 = float(10) >>> print(f2) 10.0 >>> >>> # complex() 创建复数: 第一个参数是复数的实部，第二个参数是复数的虚部 ... c1 = 10 + 4j >>> c2 = complex(10, 4) >>> >>> print(c1) (10+4j) >>> print(c2) # 等同与c1 (10+4j) >>> >>> # str() : 转换为 字符串类型 ... num1 = 10 >>> f1 = 3.14 >>> >>> print(type(str(num1))) >>> print(type(str(f1))) >>> >>> # repr()： 转换为表达式字符串 ... num1 = 10 >>> print(type(repr(num1))) >>> >>> >>> # eval(): 将字符串形式的数据，转换为原本的类型 ... str1 = \"3.14\" >>> print(type(eval(str1))) >>> >>> str2 = \"[10, 20, 30]\" >>> l = eval(str2) >>> print(type(l)) >>> >>> >>> # chr: 将一个整数转换为对应的 Unicode 字符 ... s = chr(1065) >>> print(s) Щ >>> >>> # ord ：将一个字符转换为对应的字符编码数字 ... n = ord(\"A\") >>> print(n) 65 >>> >>> # bin: 将一个整数转换为二进制 ... print(bin(1024)) # 0b 开头表示二进制数 0b10000000000 >>> >>> # oct：将一个整数转换为八进制 ... print(oct(1024)) # 0o 开头表示八进制数 0o2000 >>> >>> # hex: 将一个整数转换为十六进制 ... print(hex(1024)) # 0x 开头表示十六进制 0x400 >>> 附录：常用字符与ASCII码对照表 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 16:06:29 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/判断语句介绍.html":{"url":"python_basics/判断语句介绍.html","title":"判断语句介绍","keywords":"","body":"1. 判断语句介绍1.1. 生活中的判断场景1. 判断语句介绍 1.1. 生活中的判断场景 火车站安检 上网吧 密码判断 小总结： 如果某些条件满足，才能做某件事情；条件不满足时，则不能做，这就是所谓的判断。 不仅生活中有，在软件开发中\"判断\"功能也经常会用到 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 16:20:00 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/if语句.html":{"url":"python_basics/if语句.html","title":"if语句","keywords":"","body":"if判断语句 if判断语句介绍 if语句是用来进行判断的，其使用格式如下： if 要判断的条件: 条件成立时，要做的事情 demo1:（demo的中文意思：演示、案例） age = 30 print(\"------if判断开始------\") if age >= 18: print(\"我已经成年了\") print(\"------if判断结束------\") 运行结果: ------if判断开始------ 我已经成年了 ------if判断结束------ demo2: age = 16 print(\"------if判断开始------\") if age >= 18: print(\"我已经成年了\") print(\"------if判断结束------\") 运行结果: ------if判断开始------ ------if判断结束------小总结： 以上2个demo仅仅是age变量的值不一样，导致结果却不同；能够看得出if判断语句的作用：就是当满足一定条件时才会执行代码块语句，否则就不执行代码块语句。 注意：代码的缩进为一个tab键，或者4个空格 练一练 要求：从键盘获取自己的年龄，判断是否大于或者等于18岁，如果满足就输出“哥，已成年，网吧可以去了” 使用input从键盘中获取数据，并且存入到一个变量中 使用if语句，来判断 age>=18是否成立 想一想 判断age大于或者等于18岁使用的是 >=，如果是其他判断，还有哪些呢？ Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-03 20:07:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/比较、关系运算符.html":{"url":"python_basics/比较、关系运算符.html","title":"比较、关系运算符","keywords":"","body":"1. 比较(即关系)运算符2. 逻辑运算符1. 比较(即关系)运算符 python中的比较运算符如下表 运算符 描述 示例 == 检查两个操作数的值是否相等，如果是则条件变为真。 如a=3,b=3，则（a == b) 为 True != 检查两个操作数的值是否相等，如果值不相等，则条件变为真。 如a=1,b=3，则(a != b) 为 True > 检查左操作数的值是否大于右操作数的值，如果是，则条件成立。 如a=7,b=3，则(a > b) 为 True 检查左操作数的值是否小于右操作数的值，如果是，则条件成立。 如a=7,b=3，则(a >= 检查左操作数的值是否大于或等于右操作数的值，如果是，则条件成立。 如a=3,b=3，则(a >= b) 为 True 检查左操作数的值是否小于或等于右操作数的值，如果是，则条件成立。 如a=3,b=3，则(a >>> ## 关系运算符 ... >>> # == 等于：表示左右两个操作数是否相等，如果相等则整个表达式的值为 True；不相等则为False ... num1 = 15 >>> num2 = 20 >>> >>> print(num1 == num2) False >>> >>> # != 不等于 ... print(num1 != num2) True >>> >>> # > 大于 ... print(num1 > num2) False >>> >>> # >> >>> # >= 大于等于: num1 大于 或者 等于 num2 ，条件都成立 ... print(num1 >= num2) False >>> >>> # >> >>> if num1 >= num2: ... print(\"条件成立！\") ... >>> 2. 逻辑运算符 运算符 逻辑表达式 描述 实例 and x and y 布尔\"与\"：如果 x 为 False，x and y 返回 False，否则它返回 y 的值。 True and False， 返回 False。 or x or y 布尔\"或\"：如果 x 是 True，它返回 True，否则它返回 y 的值。 False or True， 返回 True。 not not x 布尔\"非\"：如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not True 返回 False, not False 返回 True >>> ## 逻辑运算符 ... >>> # and : 左右表达式都为True，整个表达式结果才为 True ... if (1 == 1) and (10 > 3): ... print(\"条件成立！\") ... 条件成立！ >>> # or : 左右表达式有一个为True，整个表达式结果就为 True ... if (1 == 2) or (10 > 3): ... print(\"条件成立！\") ... 条件成立！ >>> # not：将右边表达式的逻辑结果取反，Ture变为False，False变为True ... if not (1 == 2): ... print(\"条件成立！\") ... 条件成立！ >>> Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-08 22:12:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/if-else.html":{"url":"python_basics/if-else.html","title":"if-else","keywords":"","body":"1. if-else1.1. if-else的使用格式1.2. 练一练1. if-else 想一想：在使用if的时候，它只能做到满足条件时要做的事情。那万一需要在不满足条件的时候，做某些事，该怎么办呢？ 答：使用 if-else 1.1. if-else的使用格式 if 条件: 满足条件时要做的事情1 满足条件时要做的事情2 满足条件时要做的事情3 ...(省略)... else: 不满足条件时要做的事情1 不满足条件时要做的事情2 不满足条件时要做的事情3 ...(省略)... demo1 chePiao = 1 # 用1代表有车票，0代表没有车票 if chePiao == 1: print(\"有车票，可以上火车\") print(\"终于可以见到Ta了，美滋滋~~~\") else: print(\"没有车票，不能上车\") print(\"亲爱的，那就下次见了\"） 结果1：有车票的情况 有车票，可以上火车 终于可以见到Ta了，美滋滋~~~ 结果2：没有车票的情况 没有车票，不能上车 亲爱的，那就下次见了 1.2. 练一练 要求：从键盘输入身高，如果身高没有超过150cm，则进动物园不用买票，否则需要买票。 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 16:23:46 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/elif.html":{"url":"python_basics/elif.html","title":"elif","keywords":"","body":"1. elif1.1. elif的功能1.2. 注意点1. elif 想一想: if能完成当xxx时做事情 if-else能完成当xxx时做事情1，否则做事情2 如果有这样一种情况：当xxx1满足时做事情1；当xxx1不满足、xxx2满足时做事情2；当xxx2不满足、xxx3满足时做事情3，那该怎么实现呢？ 答: elif 1.1. elif的功能 elif的使用格式如下: if xxx1: 事情1 elif xxx2: 事情2 elif xxx3: 事情3 说明: 当xxx1满足时，执行事情1，然后整个if结束 当xxx1不满足时，那么判断xxx2，如果xxx2满足，则执行事情2，然后整个if结束 当xxx1不满足时，xxx2也不满足，如果xxx3满足，则执行事情3，然后整个if结束 demo: score = 77 if score>=90 and score=80 and score=70 and score=60 and score=0 and score 1.2. 注意点 可以和else一起使用 if 性别为男性: 输出男性的体重 ... elif 性别为女性: 输出女性的体重 ... else: 第三种性别的体重 ... 说明: 当 “性别为男性” 满足时，执行 “输出男性的体重”的相关代码 当 “性别为男性” 不满足时，如果 “性别为女性”满足，则执行 “输出女性的体重”的相关代码 当 “性别为男性” 不满足，“性别为女性”也不满足，那么久默认执行else后面的代码，即 “第三种性别的体重”相关代码 elif必须和if一起使用，否则出错 else 一般用在最后，即所有条件都不满足时使用 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 16:24:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/if嵌套.html":{"url":"python_basics/if嵌套.html","title":"if嵌套","keywords":"","body":"1. if嵌套1.1. if嵌套的格式1.2. if嵌套的应用1.3. 练一练1. if嵌套 通过学习if的基本用法，已经知道了 当需要满足条件去做事情的这种情况需要使用if 当满足条件时做事情A，不满足条件做事情B的这种情况使用if-else 想一想： 坐火车或者地铁的实际情况是：先进行安检如果安检通过才会判断是否有车票，或者是先检查是否有车票之后才会进行安检，即实际的情况某个判断是再另外一个判断成立的基础上进行的，这样的情况该怎样解决呢？ 答： if嵌套 1.1. if嵌套的格式 if 条件1: 满足条件1 做的事情1 满足条件1 做的事情2 if 条件2: 满足条件2 做的事情1 满足条件2 做的事情2 说明 外层的if判断，也可以是if-else 内层的if判断，也可以是if-else 根据实际开发的情况，进行选择 1.2. if嵌套的应用 demo： chePiao = 1 # 用1代表有车票，0代表没有车票 daoLenght = 9 # 刀子的长度，单位为cm if chePiao == 1: print(\"有车票，可以进站\") if daoLenght 结果1：chePiao = 1;daoLenght = 9 有车票，可以进站 通过安检 终于可以见到Ta了，美滋滋~~~ 结果2：chePiao = 1;daoLenght = 20 有车票，可以进站 没有通过安检 刀子的长度超过规定，等待警察处理... 结果3：chePiao = 0;daoLenght = 9 没有车票，不能进站 亲爱的，那就下次见了 结果4：chePiao = 0;daoLenght = 20 没有车票，不能进站 亲爱的，那就下次见了 想一想:为什么结果3和结果4相同？？？ 1.3. 练一练 情节描述：上公交车，并且可以有座位坐下 要求：输入公交卡当前的余额，只要超过2元，就可以上公交车；如果车上有空座位，就可以坐下。 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 16:24:16 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/if应用：猜拳游戏.html":{"url":"python_basics/if应用：猜拳游戏.html","title":"if应用：猜拳游戏","keywords":"","body":"1. 应用:猜拳游戏1.1. 运行效果:1.2. 参考代码:1. 应用:猜拳游戏 1.1. 运行效果: 1.2. 参考代码: import random player = input('请输入：剪刀(0) 石头(1) 布(2):') player = int(player) # 产生随机整数：0、1、2 中的某一个 computer = random.randint(0,2) # 用来进行测试 #print('player=%d,computer=%d',(player,computer)) if ((player == 0) and (computer == 2)) or ((player ==1) and (computer == 0)) or ((player == 2) and (computer == 1)): print('获胜，哈哈，你太厉害了') elif player == computer: print('平局，要不再来一局') else: print('输了，不要走，洗洗手接着来，决战到天亮') Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 16:24:51 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/循环语句介绍.html":{"url":"python_basics/循环语句介绍.html","title":"循环语句介绍","keywords":"","body":"1. 循环介绍1.1. 生活中的循环场景1.2. 软件开发中循环的使用场景1.3. 小总结1. 循环介绍 1.1. 生活中的循环场景 跑道 风扇 CF加特林 1.2. 软件开发中循环的使用场景 跟媳妇承认错误，说一万遍\"媳妇儿，我错了\" print(\"媳妇儿，我错了\") print(\"媳妇儿，我错了\") print(\"媳妇儿，我错了\") ...(还有99997遍)... 使用循环语句一句话搞定 i = 0 while i 1.3. 小总结 while和if的用法基本类似，区别在于：if 条件成立，则执行一次； while 条件成立，则重复执行，直到条件不成立为止。 一般情况下，需要多次重复执行的代码，都可以用循环的方式来完成 循环不是必须要使用的，但是为了提高代码的重复使用率，所以有经验的开发者都会采用循环 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 16:25:53 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/while循环.html":{"url":"python_basics/while循环.html","title":"while循环","keywords":"","body":"1. while循环1.1. while循环的格式1. while循环 1.1. while循环的格式 while 条件: 条件满足时，做的事情1 条件满足时，做的事情2 条件满足时，做的事情3 ...(省略)... demo i = 0 while i 结果: 当前是第1次执行循环 i=0 当前是第2次执行循环 i=1 当前是第3次执行循环 i=2 当前是第4次执行循环 i=3 当前是第5次执行循环 i=4 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 16:26:58 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/while循环应用.html":{"url":"python_basics/while循环应用.html","title":"while循环应用","keywords":"","body":"1. while循环应用1.1. 1. 计算1~100的累积和（包含1和100）1.2. 2. 计算1~100之间偶数的累积和（包含1和100）1. while循环应用 1.1. 1. 计算1~100的累积和（包含1和100） 参考代码如下: #encoding=utf-8 i = 1 sum = 0 while i 1.2. 2. 计算1~100之间偶数的累积和（包含1和100） 参考代码如下: #encoding=utf-8 i = 1 sum = 0 while i Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 16:29:55 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/while循环的嵌套以及应用[重难点].html":{"url":"python_basics/while循环的嵌套以及应用[重难点].html","title":"while循环的嵌套以及应用(重难点)","keywords":"","body":"1. while循环嵌套1.1. while嵌套的格式1.2. while嵌套应用一1.3. while嵌套应用二：九九乘法表1. while循环嵌套 前面学习过if的嵌套了，想一想if嵌套是什么样子的？ 类似if的嵌套，while嵌套就是：while里面还有while 1.1. while嵌套的格式 while 条件1: 条件1满足时，做的事情1 条件1满足时，做的事情2 条件1满足时，做的事情3 ...(省略)... while 条件2: 条件2满足时，做的事情1 条件2满足时，做的事情2 条件2满足时，做的事情3 ...(省略)... 1.2. while嵌套应用一 要求：打印如下图形： * * * * * * * * * * * * * * * 参考代码： i = 1 while i 1.3. while嵌套应用二：九九乘法表 参考代码： i = 1 while i Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 16:30:26 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/for循环.html":{"url":"python_basics/for循环.html","title":"for循环","keywords":"","body":"1. for循环1.1. for循环的格式1.1.1. demo11.1.2. demo21.1.3. demo31. for循环 像while循环一样，for可以完成循环的功能。 在Python中 for循环可以遍历任何序列的项目，如一个列表或者一个字符串等。 1.1. for循环的格式 for 临时变量 in 列表或者字符串等可迭代对象: 循环满足条件时执行的代码 1.1.1. demo1 name = 'itheima' for x in name: print(x) 运行结果如下: i t h e i m a 1.1.2. demo2 >>> for x in name: print(x) if x == 'l': print(\"Hello world!\") 运行结果如下: h e l Hello world! l Hello world! o 1.1.3. demo3 # range(5) 在python就业班中进行讲解会牵扯到迭代器的知识， # 作为刚开始学习python的我们，此阶段仅仅知道range(5)表示可以循环5次即可 for i in range(5): print(i) ''' 效果等同于 while 循环的： i = 0 while i 运行结果如下: 0 1 2 3 4 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 16:30:56 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/break和continue.html":{"url":"python_basics/break和continue.html","title":"break和continue","keywords":"","body":"1. break和continue1.1. 1. break1.1.1. for循环1.1.2. while循环1.1.3. 小结:1.2. 2. continue1.2.1. for循环1.2.2. while循环1.2.3. 小结:1.3. 3. 注意点1. break和continue 1.1. 1. break 1.1.1. for循环 普通的循环示例如下： name = 'itheima' for x in name: print('----') print(x) else: print(\"==for循环过程中，如果没有执行break退出，则执行本语句==\") 运行结果: ---- i ---- t ---- h ---- e ---- i ---- m ---- a ==for循环过程中，如果没有break则执行== 带有break的循环示例如下: name = 'itheima' for x in name: print('----') if x == 'e': break print(x) else: print(\"==for循环过程中，如果没有执行break退出，则执行本语句==\") 运行结果: ---- i ---- t ---- h ---- 1.1.2. while循环 普通的循环示例如下： i = 0 while i 运行结果: ---- 1 ---- 2 ---- 3 ---- 4 ---- 5 ==while循环过程中，如果没有break则执行== 带有break的循环示例如下: i = 0 while i 运行结果: ---- 1 ---- 2 ---- 1.1.3. 小结: break的作用：立刻结束break所在的循环 1.2. 2. continue 1.2.1. for循环 带有continue的循环示例如下: name = 'itheima' for x in name: print('----') if x == 'e': continue print(x) else: print(\"==while循环过程中，如果没有break则执行==\") 运行结果: ---- i ---- t ---- h ---- ---- i ---- m ---- a ==while循环过程中，如果没有break则执行== 1.2.2. while循环 带有continue的循环示例如下: i = 0 while i 运行结果: ---- 1 ---- 2 ---- ---- 4 ---- 5 1.2.3. 小结: continue的作用：用来结束本次循环，紧接着执行下一次的循环 1.3. 3. 注意点 break/continue只能用在循环中，除此以外不能单独使用 break/continue在嵌套循环中，只对最近的一层循环起作用 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 16:31:08 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/字符串介绍.html":{"url":"python_basics/字符串介绍.html","title":"字符串介绍","keywords":"","body":"1. 字符串介绍1.1. python中字符串的格式1. 字符串介绍 1.1. python中字符串的格式 如下定义的变量a，存储的是数字类型的值 a = 100 如下定义的变量b，存储的是字符串类型的值 b = \"hello world\" 或者 b = 'hello world' # b = '''hello world''' 小总结： 双引号或者单引号中的数据，就是字符串 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 20:55:37 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/字符串输出.html":{"url":"python_basics/字符串输出.html","title":"字符串输出","keywords":"","body":"1. 字符串输出1. 字符串输出 demo name = 'jiaxiaochu' position = '讲师' address = '北京市' print('--------------------------------------------------') print(\"姓名：%s\" % name) print(\"职位：%s\" % position) print(\"公司地址：%s\" % address) print('--------------------------------------------------') 结果: -------------------------------------------------- 姓名： jiaoxiaochu 职位： 讲师 公司地址： 北京市 -------------------------------------------------- Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 20:56:08 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/字符串输入.html":{"url":"python_basics/字符串输入.html","title":"字符串输入","keywords":"","body":"1. 字符串输入1. 字符串输入 之前在学习input的时候，通过它能够完成从键盘获取数据，然后保存到指定的变量中； 注意：input获取的数据，都以字符串的方式进行保存，即使输入的是数字，那么也是以字符串方式保存 demo: userName = input('请输入用户名:') print(\"用户名为：%s\" % userName) password = input('请输入密码:') print(\"密码为：%s\" % password) 结果：（根据输入的不同结果也不同） 请输入用户名:jiaxiaochu 用户名为： jiaxiaochu 请输入密码:haohaoxuexitiantianxiangshang 密码为： haohaoxuexitiantianxiangshang Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 20:57:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/下标和切片.html":{"url":"python_basics/下标和切片.html","title":"下标和切片","keywords":"","body":"1. 下标和切片1.1. 1. 下标索引1.2. 2. 切片1.2.1. 想一想1. 下标和切片 1.1. 1. 下标索引 所谓“下标”，就是编号，就好比超市中的存储柜的编号，通过这个编号就能找到相应的存储空间 生活中的 \"下标\" 超市储物柜 高铁二等座 高铁一等座 绿皮车 字符串中\"下标\"的使用 列表与元组支持下标索引好理解，字符串实际上就是字符的数组，所以也支持下标索引。 如果有字符串:name = 'abcdef'，在内存中的实际存储如下: 如果想取出部分字符，那么可以通过下标的方法，（注意python中下标从 0 开始） name = 'abcdef' print(name[0]) print(name[1]) print(name[2]) 运行结果: a b c 1.2. 2. 切片 切片是指对操作的对象截取其中一部分的操作。字符串、列表、元组都支持切片操作。 切片的语法：[起始:结束:步长] 注意：选取的区间从\"起始\"位开始，到\"结束\"位的前一位结束（不包含结束位本身)，步长表示选取间隔。 我们以字符串为例讲解。 如果取出一部分，则可以在中括号[]中，使用: name = 'abcdef' print(name[0:3]) # 取 下标0~2 的字符 运行结果: name = 'abcdef' print(name[0:5]) # 取 下标为0~4 的字符 运行结果: name = 'abcdef' print(name[3:5]) # 取 下标为3、4 的字符 运行结果: name = 'abcdef' print(name[2:]) # 取 下标为2开始到最后的字符 运行结果: name = 'abcdef' print(name[1:-1]) # 取 下标为1开始 到 最后第2个 之间的字符 运行结果: >>> a = \"abcdef\" >>> a[:3] 'abc' >>> a[::2] 'ace' >>> a[5:1:2] '' >>> a[1:5:2] 'bd' >>> a[::-2] 'fdb' >>> a[5:1:-2] 'fd' 1.2.1. 想一想 （面试题）给定一个字符串aStr, 请反转字符串 # 索引是通过下标取某一个元素 # 切片是通过下标去某一段元素 s = 'Hello World!' print(s[4]) print(s) print(s[:]) # 取出所有元素（没有起始位和结束位之分），默认步长为1 print(s[1:]) # 从下标为1开始，取出 后面所有的元素（没有结束位） print(s[:5]) # 从起始位置开始，取到 下标为5的前一个元素（不包括结束位本身） print(s[:-1]) # 从起始位置开始，取到 倒数第一个元素（不包括结束位本身） print(s[-4:-1]) # 从倒数第4个元素开始，取到 倒数第1个元素（不包括结束位本身） print(s[1:5:2]) # 从下标为1开始，取到下标为5的前一个元素，步长为2（不包括结束位本身） # python 字符串快速逆置 print(s[::-1]) # 从后向前，按步长为1进行取值 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 20:59:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/字符串常见操作.html":{"url":"python_basics/字符串常见操作.html","title":"字符串常见操作","keywords":"","body":"1. 字符串常见操作1. 字符串常见操作 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 20:50:30 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/列表介绍.html":{"url":"python_basics/列表介绍.html","title":"列表介绍","keywords":"","body":"1. 列表介绍1.1. 列表的格式1.2. 打印列表1. 列表介绍 想一想： 前面学习的字符串可以用来存储一串信息，那么想一想，怎样存储咱们班所有同学的名字呢？ 定义100个变量，每个变量存放一个学生的姓名可行吗？有更好的办法吗？ 答： 列表 1.1. 列表的格式 变量A的类型为列表 namesList = ['xiaoWang','xiaoZhang','xiaoHua'] 比C语言的数组强大的地方在于列表中的元素可以是不同类型的 testList = [1, 'a'] 1.2. 打印列表 demo: namesList = ['xiaoWang','xiaoZhang','xiaoHua'] print(namesList[0]) print(namesList[1]) print(namesList[2]) 结果： xiaoWang xiaoZhang xiaoHua Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 21:03:39 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/列表的循环遍历.html":{"url":"python_basics/列表的循环遍历.html","title":"列表的循环遍历","keywords":"","body":"1. 列表的循环遍历1.1. 1. 使用for循环1.2. 2. 使用while循环1. 列表的循环遍历 1.1. 1. 使用for循环 为了更有效率的输出列表的每个数据，可以使用循环来完成 demo: namesList = ['xiaoWang','xiaoZhang','xiaoHua'] for name in namesList: print(name) 结果: xiaoWang xiaoZhang xiaoHua 1.2. 2. 使用while循环 为了更有效率的输出列表的每个数据，可以使用循环来完成 demo: namesList = ['xiaoWang','xiaoZhang','xiaoHua'] length = len(namesList) i = 0 while i 结果: xiaoWang xiaoZhang xiaoHua Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 21:03:54 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/列表的常见操作.html":{"url":"python_basics/列表的常见操作.html","title":"列表的常见操作","keywords":"","body":"1. 列表的相关操作1.1. 添加元素(\"增\"append, extend, insert)1.2. 修改元素(\"改\")1.3. 查找元素(\"查\"in, not in, index, count)1.4. 删除元素(\"删\"del, pop, remove)1.5. 排序(sort, reverse)1. 列表的相关操作 列表中存放的数据是可以进行修改的，比如\"增\"、\"删\"、\"改\"、\"查\" 1.1. 添加元素(\"增\"append, extend, insert) append 通过append可以向列表添加元素 demo: #定义变量A，默认有3个元素 A = ['xiaoWang','xiaoZhang','xiaoHua'] print(\"-----添加之前，列表A的数据-----\") for tempName in A: print(tempName) #提示、并添加元素 temp = input('请输入要添加的学生姓名:') A.append(temp) print(\"-----添加之后，列表A的数据-----\") for tempName in A: print(tempName) 结果: extend 通过extend可以将另一个集合中的元素逐一添加到列表中 >>> a = [1, 2] >>> b = [3, 4] >>> a.append(b) >>> a [1, 2, [3, 4]] >>> a.extend(b) >>> a [1, 2, [3, 4], 3, 4] insert insert(index, object) 在指定位置index前插入元素object >>> a = [0, 1, 2] >>> a.insert(1, 3) >>> a [0, 3, 1, 2] 1.2. 修改元素(\"改\") 修改元素的时候，要通过下标来确定要修改的是哪个元素，然后才能进行修改 demo: #定义变量A，默认有3个元素 A = ['xiaoWang','xiaoZhang','xiaoHua'] print(\"-----修改之前，列表A的数据-----\") for tempName in A: print(tempName) #修改元素 A[1] = 'xiaoLu' print(\"-----修改之后，列表A的数据-----\") for tempName in A: print(tempName) 结果: -----修改之前，列表A的数据----- xiaoWang xiaoZhang xiaoHua -----修改之后，列表A的数据----- xiaoWang xiaoLu xiaoHua 1.3. 查找元素(\"查\"in, not in, index, count) 所谓的查找，就是看看指定的元素是否存在 in, not in python中查找的常用方法为： in（存在）,如果存在那么结果为true，否则为false not in（不存在），如果不存在那么结果为true，否则false demo #待查找的列表 nameList = ['xiaoWang','xiaoZhang','xiaoHua'] #获取用户要查找的名字 findName = input('请输入要查找的姓名:') #查找是否存在 if findName in nameList: print('在字典中找到了相同的名字') else: print('没有找到') 结果1：(找到) 结果2：(没有找到) 说明： in的方法只要会用了，那么not in也是同样的用法，只不过not in判断的是不存在 index, count index和count与字符串中的用法相同 >>> a = ['a', 'b', 'c', 'a', 'b'] >>> a.index('a', 1, 3) # 注意是左闭右开区间 Traceback (most recent call last): File \"\", line 1, in ValueError: 'a' is not in list >>> a.index('a', 1, 4) 3 >>> a.count('b') 2 >>> a.count('d') 0 1.4. 删除元素(\"删\"del, pop, remove) 类比现实生活中，如果某位同学调班了，那么就应该把这个条走后的学生的姓名删除掉；在开发中经常会用到删除这种功能。 列表元素的常用删除方法有： del：根据下标进行删除 pop：删除最后一个元素 remove：根据元素的值进行删除 demo:(del) movieName = ['加勒比海盗','骇客帝国','第一滴血','指环王','霍比特人','速度与激情'] print('------删除之前------') for tempName in movieName: print(tempName) del movieName[2] print('------删除之后------') for tempName in movieName: print(tempName) 结果: ------删除之前------ 加勒比海盗 骇客帝国 第一滴血 指环王 霍比特人 速度与激情 ------删除之后------ 加勒比海盗 骇客帝国 指环王 霍比特人 速度与激情 demo:(pop) movieName = ['加勒比海盗','骇客帝国','第一滴血','指环王','霍比特人','速度与激情'] print('------删除之前------') for tempName in movieName: print(tempName) movieName.pop() print('------删除之后------') for tempName in movieName: print(tempName) 结果: ------删除之前------ 加勒比海盗 骇客帝国 第一滴血 指环王 霍比特人 速度与激情 ------删除之后------ 加勒比海盗 骇客帝国 第一滴血 指环王 霍比特人 demo:(remove) movieName = ['加勒比海盗','骇客帝国','第一滴血','指环王','霍比特人','速度与激情'] print('------删除之前------') for tempName in movieName: print(tempName) movieName.remove('指环王') print('------删除之后------') for tempName in movieName: print(tempName) 结果: ------删除之前------ 加勒比海盗 骇客帝国 第一滴血 指环王 霍比特人 速度与激情 ------删除之后------ 加勒比海盗 骇客帝国 第一滴血 霍比特人 速度与激情 1.5. 排序(sort, reverse) sort方法是将list按特定顺序重新排列，默认为由小到大，参数reverse=True可改为倒序，由大到小。 reverse方法是将list逆置。 >>> a = [1, 4, 2, 3] >>> a [1, 4, 2, 3] >>> a.reverse() >>> a [3, 2, 4, 1] >>> a.sort() >>> a [1, 2, 3, 4] >>> a.sort(reverse=True) >>> a [4, 3, 2, 1] Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 21:04:09 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/列表的嵌套.html":{"url":"python_basics/列表的嵌套.html","title":"列表的嵌套","keywords":"","body":"1. 列表的嵌套1.1. 1. 列表嵌套1.2. 2. 应用1. 列表的嵌套 1.1. 1. 列表嵌套 类似while循环的嵌套，列表也是支持嵌套的 一个列表中的元素又是一个列表，那么这就是列表的嵌套 schoolNames = [['北京大学','清华大学'], ['南开大学','天津大学','天津师范大学'], ['山东大学','中国海洋大学']] 1.2. 2. 应用 一个学校，有3个办公室，现在有8位老师等待工位的分配，请编写程序，完成随机的分配 #encoding=utf-8 import random # 定义一个列表用来保存3个办公室 offices = [[],[],[]] # 定义一个列表用来存储8位老师的名字 names = ['A','B','C','D','E','F','G','H'] i = 0 for name in names: index = random.randint(0,2) offices[index].append(name) i = 1 for tempNames in offices: print('办公室%d的人数为:%d'%(i,len(tempNames))) i+=1 for name in tempNames: print(\"%s\"%name,end='') print(\"\\n\") print(\"-\"*20) 运行结果如下: 办公室的1的人数为：4 ABCE 办公室的2的人数为：3 DGH 办公室的3的人数为：1 F Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 21:06:57 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/元组.html":{"url":"python_basics/元组.html","title":"元组","keywords":"","body":"1. 元组1. 元组 Python的元组与列表类似，不同之处在于元组的元素不能修改。元组使用小括号，列表使用方括号。 >>> aTuple = ('et',77,99.9) >>> aTuple ('et',77,99.9) 访问元组 修改元组 说明： python中不允许修改元组的数据，包括不能删除其中的元素。 count, index index和count与字符串和列表中的用法相同 >>> a = ('a', 'b', 'c', 'a', 'b') >>> a.index('a', 1, 3) # 注意是左闭右开区间 Traceback (most recent call last): File \"\", line 1, in ValueError: tuple.index(x): x not in tuple >>> a.index('a', 1, 4) 3 >>> a.count('b') 2 >>> a.count('d') 0 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 21:07:48 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/字典介绍.html":{"url":"python_basics/字典介绍.html","title":"字典介绍","keywords":"","body":"1. 字典介绍1.1. 生活中的字典1.2. 软件开发中的字典1.3. 根据键访问值1. 字典介绍 想一想： 如果有列表 nameList = ['xiaoZhang', 'xiaoWang', 'xiaoLi']; 需要对\"xiaoWang\"这个名字写错了，通过代码修改： nameList[1] = 'xiaoxiaoWang' 如果列表的顺序发生了变化，如下 nameList = ['xiaoWang', 'xiaoZhang', 'xiaoLi']; 此时就需要修改下标，才能完成名字的修改 nameList[0] = 'xiaoxiaoWang' 有没有方法，既能存储多个数据，还能在访问元素的很方便就能够定位到需要的那个元素呢？ 答： 字典 另一个场景： 学生信息列表，每个学生信息包括学号、姓名、年龄等，如何从中找到某个学生的信息？ >>> studens = [[1001, \"王bao强\", 24], [1002, \"马rong\", 23], [1005, \"宋x\"，24], ...] 循环遍历？ No！ 1.1. 生活中的字典 1.2. 软件开发中的字典 变量info为字典类型： info = {'name':'班长', 'id':100, 'sex':'f', 'address':'地球亚洲中国北京'} 说明： 字典和列表一样，也能够存储多个数据 列表中找某个元素时，是根据下标进行的 字典中找某个元素时，是根据'名字'（就是冒号:前面的那个值，例如上面代码中的'name'、'id'、'sex'） 字典的每个元素由2部分组成，键:值。例如 'name':'班长' ,'name'为键，'班长'为值 1.3. 根据键访问值 info = {'name':'班长', 'id':100, 'sex':'f', 'address':'地球亚洲中国北京'} print(info['name']) print(info['address']) 结果: 班长 地球亚洲中国北京 若访问不存在的键，则会报错： >>> info['age'] Traceback (most recent call last): File \"\", line 1, in KeyError: 'age' 在我们不确定字典中是否存在某个键而又想获取其值时，可以使用get方法，还可以设置默认值： >>> age = info.get('age') >>> age #'age'键不存在，所以age为None >>> type(age) >>> age = info.get('age', 18) # 若info中不存在'age'这个键，就返回默认值18 >>> age 18 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 21:08:34 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/字典的常见操作1.html":{"url":"python_basics/字典的常见操作1.html","title":"字典的常见操作1","keywords":"","body":"1. 字典的常见操作11.1. 查看元素1.2. 修改元素1.3. 添加元素1.4. 删除元素1. 字典的常见操作1 1.1. 查看元素 除了使用key查找数据，还可以使用get来获取数据 demo: info = {'name':'吴彦祖','age':18} print(info['age']) # 获取年龄 # print(info['sex']) # 获取不存在的key，会发生异常 print(info.get('sex')) # 获取不存在的key，获取到空的内容，不会出现异常 1.2. 修改元素 字典的每个元素中的数据是可以修改的，只要通过key找到，即可修改 demo: info = {'name':'班长', 'id':100, 'sex':'f', 'address':'地球亚洲中国北京'} newId = input('请输入新的学号') info['id'] = int(newId) print('修改之后的id为%d:'%info['id']) 结果: 1.3. 添加元素 demo:访问不存在的元素 info = {'name':'班长', 'sex':'f', 'address':'地球亚洲中国北京'} print('id为:%d'%info['id']) 结果: 如果在使用 变量名['键'] = 数据 时，这个“键”在字典中，不存在，那么就会新增这个元素 demo:添加新的元素 info = {'name':'班长', 'sex':'f', 'address':'地球亚洲中国北京'} # print('id为:%d'%info['id'])#程序会终端运行，因为访问了不存在的键 newId = input('请输入新的学号') info['id'] = newId print('添加之后的id为:%d'%info['id']) 结果: 请输入新的学号188 添加之后的id为: 188 1.4. 删除元素 对字典进行删除操作，有一下几种： del clear() demo:del删除指定的元素 info = {'name':'班长', 'sex':'f', 'address':'地球亚洲中国北京'} print('删除前,%s'%info['name']) del info['name'] print('删除后,%s'%info['name']) 结果 demo:del删除整个字典 info = {'name':'monitor', 'sex':'f', 'address':'China'} print('删除前,%s'%info) del info print('删除后,%s'%info) 结果 demo:clear清空整个字典 info = {'name':'monitor', 'sex':'f', 'address':'China'} print('清空前,%s'%info) info.clear() print('清空后,%s'%info) 结果 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 21:26:56 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/字典的常见操作2.html":{"url":"python_basics/字典的常见操作2.html","title":"字典的常见操作2","keywords":"","body":"1. 字典的常见操作21.1.1. len()1.1.2. keys1.1.3. values1.1.4. items1.1.5. has_key （Python3 已取消）1. 字典的常见操作2 1.1.1. len() 测量字典中，键值对的个数 1.1.2. keys 返回一个包含字典所有KEY的列表 1.1.3. values 返回一个包含字典所有value的列表 1.1.4. items 返回一个包含所有（键，值）元祖的列表 1.1.5. has_key （Python3 已取消） dict.has_key(key)如果key在字典中，返回True，否则返回False Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 21:28:00 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/字典的遍历.html":{"url":"python_basics/字典的遍历.html","title":"字典的遍历","keywords":"","body":"1. 遍历1.1. 字符串遍历1.2. 列表遍历1.3. 元组遍历1.4. 字典遍历1.5. 想一想，如何实现带下标索引的遍历1.6. enumerate()1. 遍历 通过for ... in ... 我们可以遍历字符串、列表、元组、字典等 注意python语法的缩进 1.1. 字符串遍历 >>> a_str = \"hello world\" >>> for char in a_str: ... print(char,end=' ') ... h e l l o w o r l d 1.2. 列表遍历 >>> a_list = [1, 2, 3, 4, 5] >>> for num in a_list: ... print(num,end=' ') ... 1 2 3 4 5 1.3. 元组遍历 >>> a_turple = (1, 2, 3, 4, 5) >>> for num in a_turple: ... print(num,end=\" \") 1 2 3 4 5 1.4. 字典遍历 遍历字典的key（键） 遍历字典的value（值） 遍历字典的项（元素） 遍历字典的key-value（键值对） 1.5. 想一想，如何实现带下标索引的遍历 >>> chars = ['a', 'b', 'c', 'd'] >>> i = 0 >>> for chr in chars: ... print(\"%d %s\"%(i, chr)) ... i += 1 ... 0 a 1 b 2 c 3 d 1.6. enumerate() enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。 >>> chars = ['a', 'b', 'c', 'd'] >>> for i, chr in enumerate(chars): ... print i, chr ... 0 a 1 b 2 c 3 d Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-03 11:30:22 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/集合.html":{"url":"python_basics/集合.html","title":"集合(扩展)","keywords":"","body":"1. 集合介绍1.1. 定义一个空集合1.2. 添加元素(add，update)1.2.1. add1.2.2. update1.3. 删除元素(remove，pop，discard)1.3.1. remove1.3.2. pop1.3.3. discard1.4. 交集和并集( & 和 | )1.4.1. 交集1.4.2. 并集1. 集合介绍 集合是无序的，集合中的元素是唯一的，集合一般用于元组或者列表中的元素去重。 1.1. 定义一个空集合 set1 = set() # 注意以下写法为一个空字典 set2 = {} 1.2. 添加元素(add，update) 1.2.1. add set1 = {1, 2, 4, 5} #添加元素 set1.add(8) 1.2.2. update set1 = {1, 2, 4, 5} #是把要传入的元素拆分，做为个体传入到集合中 set1.update(\"abcd\") 1.3. 删除元素(remove，pop，discard) 1.3.1. remove set1 = {1, 2, 4, 5} # 使用remove删除集合中的元素 如果有 直接删除 如果没有 程序报错 set1.remove(22) 1.3.2. pop set1 = {1, 2, 4, 5} # 使用pop删除是随机删除集合中的元素 如果set1没有元素讲程序报错 set1.pop() 1.3.3. discard set1 = {1, 2, 4, 5} # 使用discard删除 如果元素存在 直接删除 如果元素不存在 不做任何操作 set1.discard(2) 1.4. 交集和并集( & 和 | ) 1.4.1. 交集 set1 = {1, 2, 3, 4} set2 = {3, 4, 5, 6} new_set = set1 & set2 print(new_set) # {3, 4} 1.4.2. 并集 set1 = {1, 2, 3, 4} set2 = {3, 4, 5, 6} new_set = set1 | set2 print(new_set) # {1, 2, 3, 4, 5, 6} Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 21:29:14 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics/公共方法.html":{"url":"python_basics/公共方法.html","title":"公共方法","keywords":"","body":"1. 公共方法1.1. 运算符1.2. python内置函数1.3. 多维列表/元祖访问的示例1. 公共方法 1.1. 运算符 运算符 Python 表达式 结果 描述 支持的数据类型 + [1, 2] + [3, 4] [1, 2, 3, 4] 合并 字符串、列表、元组 * ['Hi!'] * 4 ['Hi!', 'Hi!', 'Hi!', 'Hi!'] 复制 字符串、列表、元组 in 3 in (1, 2, 3) True 元素是否存在 字符串、列表、元组、字典 not in 4 not in (1, 2, 3) True 元素是否不存在 字符串、列表、元组、字典 + >>> \"hello \" + \"itcast\" 'hello itcast' >>> [1, 2] + [3, 4] [1, 2, 3, 4] >>> ('a', 'b') + ('c', 'd') ('a', 'b', 'c', 'd') * >>> 'ab' * 4 'ababab' >>> [1, 2] * 4 [1, 2, 1, 2, 1, 2, 1, 2] >>> ('a', 'b') * 4 ('a', 'b', 'a', 'b', 'a', 'b', 'a', 'b') in >>> 'itc' in 'hello itcast' True >>> 3 in [1, 2] False >>> 4 in (1, 2, 3, 4) True >>> \"name\" in {\"name\":\"Delron\", \"age\":24} True 注意，in在对字典操作时，判断的是字典的键 1.2. python内置函数 Python包含了以下内置函数 序号 方法 描述 1 len(item) 计算容器中元素个数 2 max(item) 返回容器中元素最大值 3 min(item) 返回容器中元素最小值 4 del(item) 删除变量 len >>> len(\"hello itcast\") 12 >>> len([1, 2, 3, 4]) 4 >>> len((3,4)) 2 >>> len({\"a\":1, \"b\":2}) 2 注意：len在操作字典数据时，返回的是键值对个数。 max >>> max(\"hello itcast\") 't' >>> max([1,4,522,3,4]) 522 >>> max({\"a\":1, \"b\":2}) 'b' >>> max({\"a\":10, \"b\":2}) 'b' >>> max({\"c\":10, \"b\":2}) 'c' del del有两种用法，一种是del加空格，另一种是del() >>> a = 1 >>> a 1 >>> del a >>> a Traceback (most recent call last): File \"\", line 1, in NameError: name 'a' is not defined >>> a = ['a', 'b'] >>> del a[0] >>> a ['b'] >>> del(a) >>> a Traceback (most recent call last): File \"\", line 1, in NameError: name 'a' is not defined 1.3. 多维列表/元祖访问的示例 >>> tuple1 = [(2,3),(4,5)] >>> tuple1[0] (2, 3) >>> tuple1[0][0] 2 >>> tuple1[0][2] Traceback (most recent call last): File \"\", line 1, in IndexError: tuple index out of range >>> tuple1[0][1] 3 >>> tuple1[2][2] Traceback (most recent call last): File \"\", line 1, in IndexError: list index out of range >>> tuple2 = tuple1+[(3)] >>> tuple2 [(2, 3), (4, 5), 3] >>> tuple2[2] 3 >>> tuple2[2][0] Traceback (most recent call last): File \"\", line 1, in TypeError: 'int' object is not subscriptable Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-01 21:29:43 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics_2/":{"url":"python_basics_2/","title":"函数(一)","keywords":"","body":"1. 函数一2. 函数介绍1. 函数一 2. 函数介绍 持续交付更新 . . . ! 后续内容正在编辑和审定中，请耐心等待。 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-25 17:42:28 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics_2/函数介绍.html":{"url":"python_basics_2/函数介绍.html","title":"函数介绍","keywords":"","body":"1.1. 函数介绍1.1.1. 什么是函数1.1. 函数介绍 1.1.1. 什么是函数 请看如下代码: print(\" _ooOoo_ \") print(\" o8888888o \") print(\" 88 . 88 \") print(\" (| -_- |) \") print(\" O\\\\ = /O \") print(\" ____/`---'\\\\____ \") print(\" . ' \\\\| |// `. \") print(\" / \\\\||| : |||// \\\\ \") print(\" / _||||| -:- |||||- \\\\ \") print(\" | | \\\\\\\\\\\\ - /// | | \") print(\" | \\\\_| ''\\\\---/'' | | \") print(\" \\\\ .-\\\\__ `-` ___/-. / \") print(\" ___`. .' /--.--\\\\ `. . __ \") print(\" .\"\" '_/___.' >'\"\". \") print(\" | | : `- \\\\`.;`\\\\ _ /`;.`/ - ` : | | \") print(\" \\\\ \\\\ `-. \\\\_ __\\\\ /__ _/ .-` / / \") print(\" ======`-.____`-.___\\\\_____/___.-`____.-'====== \") print(\" `=---=' \") print(\" \") print(\" ............................................. \") print(\" 佛祖镇楼 BUG辟易 \") print(\" 佛曰: \") print(\" 写字楼里写字间，写字间里程序员； \") print(\" 程序人员写程序，又拿程序换酒钱。 \") print(\" 酒醒只在网上坐，酒醉还来网下眠； \") print(\" 酒醉酒醒日复日，网上网下年复年。 \") print(\" 但愿老死电脑间，不愿鞠躬老板前； \") print(\" 奔驰宝马贵者趣，公交自行程序员。 \") print(\" 别人笑我忒疯癫，我笑自己命太贱； \") print(\" 不见满街漂亮妹，哪个归得程序员？\") 运行后的现象: 想一想： 如果一个程序在不同的地方需要输出“佛祖镇楼”，程序应该怎样设计？ if 条件1: 输出‘佛祖镇楼’ ...(省略)... if 条件2: 输出‘佛祖镇楼’ ...(省略)... 如果需要输出多次，是否意味着要编写这块代码多次呢？ 小总结: 如果在开发程序时，需要某块代码多次，但是为了提高编写的效率以及代码的重用，所以把具有独立功能的代码块组织为一个小模块，这就是函数 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-26 20:32:11 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics_2/函数定义和调用.html":{"url":"python_basics_2/函数定义和调用.html","title":"函数定义和调用","keywords":"","body":"1.1. 函数定义和调用1.1.1. 定义函数1.1.2. 调用函数1.1.3. 注意:1.1.4. 练一练1.1. 函数定义和调用 1.1.1. 定义函数 定义函数的格式如下： def 函数名(): 代码 demo: # 定义一个函数，能够完成打印信息的功能 def printInfo(): print('------------------------------------') print(' 人生苦短，我用Python') print('------------------------------------') 1.1.2. 调用函数 定义了函数之后，就相当于有了一个具有某些功能的代码，想要让这些代码能够执行，需要调用它 调用函数很简单的，通过 函数名() 即可完成调用 demo: # 定义完函数后，函数是不会自动执行的，需要调用它才可以 printInfo() 1.1.3. 注意: 每次调用函数时，函数都会从头开始执行，当这个函数中的代码执行完毕后，意味着调用结束了 当然了如果函数中执行到了return也会结束函数 1.1.4. 练一练 要求：定义一个函数，能够输出自己的姓名和年龄，并且调用这个函数让它执行 使用def定义函数 编写完函数之后，通过 函数名() 进行调用 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-25 17:47:42 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics_2/函数的文档说明.html":{"url":"python_basics_2/函数的文档说明.html","title":"函数的文档说明","keywords":"","body":"1.1. 函数的文档说明1.1. 函数的文档说明 >>> def test(a,b): ... \"用来完成对2个数求和\" ... print(\"%d\"%(a+b)) ... >>> >>> test(11,22) 33 如果执行，以下代码 >>> help(test) 能够看到test函数的相关说明 Help on function test in module __main__: test(a, b) 用来完成对2个数求和 (END) Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-25 17:49:14 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics_2/函数参数一.html":{"url":"python_basics_2/函数参数一.html","title":"函数参数一","keywords":"","body":"1.1. 函数参数(一)1.1.1. 定义带有参数的函数1.1.2. 调用带有参数的函数1.1.3. 练一练1.1.4. 调用函数时参数的顺序1.1.5. 小总结1.1. 函数参数(一) 思考一个问题，如下： 现在需要定义一个函数，这个函数能够完成2个数的加法运算，并且把结果打印出来，该怎样设计？下面的代码可以吗？有什么缺陷吗？ def add2num(): a = 11 b = 22 c = a+b print c 为了让一个函数更通用，即想让它计算哪两个数的和，就让它计算哪两个数的和，在定义函数的时候可以让函数接收数据，就解决了这个问题，这就是 函数的参数 1.1.1. 定义带有参数的函数 示例如下： def add2num(a, b): c = a+b print c 1.1.2. 调用带有参数的函数 以调用上面的add2num(a, b)函数为例: def add2num(a, b): c = a+b print c add2num(11, 22) # 调用带有参数的函数时，需要在小括号中，传递数据 调用带有参数函数的运行过程： 1.1.3. 练一练 要求：定义一个函数，完成前2个数完成加法运算，然后对第3个数，进行减法；然后调用这个函数 使用def定义函数，要注意有3个参数 调用的时候，这个函数定义时有几个参数，那么就需要传递几个参数 1.1.4. 调用函数时参数的顺序 >>> def test(a,b): ... print(a,b) ... >>> test(1,2) 1 2 >>> test(b=1,a=2) 2 1 >>> >>> test(b=1,2) File \"\", line 1 SyntaxError: positional argument follows keyword argument >>> >>> 1.1.5. 小总结 定义时小括号中的参数，用来接收参数用的，称为 “形参” 调用时小括号中的参数，用来传递给函数用的，称为 “实参” Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-26 20:37:23 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics_2/函数返回值一.html":{"url":"python_basics_2/函数返回值一.html","title":"函数返回值一","keywords":"","body":"1.1. 函数返回值(一)1.1.1. “返回值”介绍1.1.2. 带有返回值的函数1.1.3. 保存函数的返回值1.1. 函数返回值(一) 1.1.1. “返回值”介绍 现实生活中的场景: 我给儿子10块钱，让他给我买包烟。这个例子中，10块钱是我给儿子的，就相当于调用函数时传递到参数，让儿子买烟这个事情最终的目标是，让他把烟给你带回来然后给你对么，，，此时烟就是返回值 开发中的场景： 定义了一个函数，完成了获取室内温度，想一想是不是应该把这个结果给调用者，只有调用者拥有了这个返回值，才能够根据当前的温度做适当的调整 综上所述： 所谓“返回值”，就是程序中函数完成一件事情后，最后给调用者的结果 1.1.2. 带有返回值的函数 想要在函数中把结果返回给调用者，需要在函数中使用return 如下示例: def add2num(a, b): c = a+b return c 或者 def add2num(a, b): return a+b 1.1.3. 保存函数的返回值 在本小节刚开始的时候，说过的“买烟”的例子中，最后儿子给你烟时，你一定是从儿子手中接过来 对么，程序也是如此，如果一个函数返回了一个数据，那么想要用这个数据，那么就需要保存 保存函数的返回值示例如下: #定义函数 def add2num(a, b): return a+b #调用函数，顺便保存函数的返回值 result = add2num(100,98) #因为result已经保存了add2num的返回值，所以接下来就可以使用了 print(result) 结果: 198 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-25 17:58:34 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics_2/4种函数的类型.html":{"url":"python_basics_2/4种函数的类型.html","title":"4种函数的类型","keywords":"","body":"1.1. 4种函数的类型1.1.1. 无参数，无返回值的函数1.1.2. 无参数，有返回值的函数1.1.3. 有参数，无返回值的函数1.1.4. 有参数，有返回值的函数1.1.5. 小总结1.1. 4种函数的类型 函数根据有没有参数，有没有返回值，可以相互组合，一共有4种 无参数，无返回值 无参数，有返回值 有参数，无返回值 有参数，有返回值 1.1.1. 无参数，无返回值的函数 此类函数，不能接收参数，也没有返回值，一般情况下，打印提示灯类似的功能，使用这类的函数 def printMenu(): print('--------------------------') print(' xx涮涮锅 点菜系统') print('') print(' 1. 羊肉涮涮锅') print(' 2. 牛肉涮涮锅') print(' 3. 猪肉涮涮锅') print('--------------------------') 结果: 1.1.2. 无参数，有返回值的函数 此类函数，不能接收参数，但是可以返回某个数据，一般情况下，像采集数据，用此类函数 # 获取温度 def getTemperature(): # 这里是获取温度的一些处理过程 # 为了简单起见，先模拟返回一个数据 return 24 temperature = getTemperature() print('当前的温度为:%d'%temperature) 结果: 当前的温度为: 24 1.1.3. 有参数，无返回值的函数 此类函数，能接收参数，但不可以返回数据，一般情况下，对某些变量设置数据而不需结果时，用此类函数 1.1.4. 有参数，有返回值的函数 此类函数，不仅能接收参数，还可以返回某个数据，一般情况下，像数据处理并需要结果的应用，用此类函数 # 计算1~num的累积和 def calculateNum(num): result = 0 i = 1 while i 结果: 1~100的累积和为: 5050 1.1.5. 小总结 函数根据有没有参数，有没有返回值可以相互组合 定义函数时，是根据实际的功能需求来设计的，所以不同开发人员编写的函数类型各不相同 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-25 17:53:03 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics_2/函数的嵌套调用.html":{"url":"python_basics_2/函数的嵌套调用.html","title":"函数的嵌套调用","keywords":"","body":"1.1. 函数的嵌套调用1.1. 函数的嵌套调用 def testB(): print('---- testB start----') print('这里是testB函数执行的代码...(省略)...') print('---- testB end----') def testA(): print('---- testA start----') testB() print('---- testA end----') testA() 结果： ---- testA start---- ---- testB start---- 这里是testB函数执行的代码...(省略)... ---- testB end---- ---- testA end---- 小总结： 一个函数里面又调用了另外一个函数，这就是所谓的函数嵌套调用 如果函数A中，调用了另外一个函数B，那么先把函数B中的任务都执行完毕之后才会回到上次 函数A执行的位置 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-25 17:53:45 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics_2/函数应用：打印图形和数学计算.html":{"url":"python_basics_2/函数应用：打印图形和数学计算.html","title":"函数应用：打印图形和数学计算","keywords":"","body":"1.1. 函数应用：打印图形和数学计算1.1.1. 目标1.1.2. 思考&实现11.1.3. 参考代码11.1.4. 思考&实现21.1.5. 参考代码21.1. 函数应用：打印图形和数学计算 1.1.1. 目标 感受函数的嵌套调用 感受程序设计的思路,复杂问题分解为简单问题 1.1.2. 思考&实现1 写一个函数打印一条横线 打印自定义行数的横线 1.1.3. 参考代码1 # 打印一条横线 def printOneLine(): print(\"-\"*30) # 打印多条横线 def printNumLine(num): i=0 # 因为printOneLine函数已经完成了打印横线的功能， # 只需要多次调用此函数即可 while i 1.1.4. 思考&实现2 写一个函数求三个数的和 写一个函数求三个数的平均值 1.1.5. 参考代码2 # 求3个数的和 def sum3Number(a,b,c): return a+b+c # return 的后面可以是数值，也可是一个表达式 # 完成对3个数求平均值 def average3Number(a,b,c): # 因为sum3Number函数已经完成了3个数的就和，所以只需调用即可 # 即把接收到的3个数，当做实参传递即可 sumResult = sum3Number(a,b,c) aveResult = sumResult/3.0 return aveResult # 调用函数，完成对3个数求平均值 result = average3Number(11,2,55) print(\"average is %d\"%resu Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-25 17:54:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics_3/":{"url":"python_basics_3/","title":"函数(二)","keywords":"","body":"1. 函数(二)1. 函数(二) Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-26 11:50:40 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics_3/局部变量.html":{"url":"python_basics_3/局部变量.html","title":"局部变量","keywords":"","body":"1.1. 局部变量1.1.1. 什么是局部变量1.1.2. 小总结1.1. 局部变量 1.1.1. 什么是局部变量 如下图所示: 1.1.2. 小总结 局部变量，就是在函数内部定义的变量 其作用范围是这个函数内部，即只能在这个函数中使用，在函数的外部是不能使用的 因为其作用范围只是在自己的函数内部，所以不同的函数可以定义相同名字的局部变量（打个比方，把你、我是当做成函数，把局部变量理解为每个人手里的手机，你可有个iPhone8，我当然也可以有个iPhone8了， 互不相关） 局部变量的作用，为了临时保存数据需要在函数中定义变量来进行存储 当函数调用时，局部变量被创建，当函数调用完成后这个变量就不能够使用了 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-25 21:04:04 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics_3/全局变量.html":{"url":"python_basics_3/全局变量.html","title":"全局变量","keywords":"","body":"1.1. 全局变量1.1.1. 什么是全局变量1.1.2. 总结1:1.1.3. 全局变量和局部变量名字相同问题1.1.4. 总结2:1.1.5. 修改全局变量1.1.6. 总结3:1.1. 全局变量 1.1.1. 什么是全局变量 如果一个变量，既能在一个函数中使用，也能在其他的函数中使用，这样的变量就是全局变量 打个比方：有2个兄弟 各自都有手机，各自有自己的小秘密在手机里，不让另外一方使用（可以理解为局部变量）；但是家里的电话是2个兄弟都可以随便使用的（可以理解为全局变量） demo如下: # 定义全局变量 a = 100 def test1(): print(a) # 虽然没有定义变量a但是依然可以获取其数据 def test2(): print(a) # 虽然没有定义变量a但是依然可以获取其数据 # 调用函数 test1() test2() 运行结果: 1.1.2. 总结1: 在函数外边定义的变量叫做全局变量 全局变量能够在所有的函数中进行访问 1.1.3. 全局变量和局部变量名字相同问题 看如下代码: 1.1.4. 总结2: 当函数内出现局部变量和全局变量相同名字时，函数内部中的 变量名 = 数据 此时理解为定义了一个局部变量，而不是修改全局变量的值 1.1.5. 修改全局变量 函数中进行使用时可否进行修改呢？ 代码如下: 1.1.6. 总结3: 如果在函数中出现global 全局变量的名字 那么这个函数中即使出现和全局变量名相同的变量名 = 数据 也理解为对全局变量进行修改，而不是定义局部变量 如果在一个函数中需要对多个全局变量进行修改，那么可以使用 # 可以使用一次global对多个全局变量进行声明 global a, b # 还可以用多次global声明都是可以的 # global a # global b Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-25 21:05:40 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics_3/多函数程序的基本使用流程.html":{"url":"python_basics_3/多函数程序的基本使用流程.html","title":"多函数程序的基本使用流程","keywords":"","body":"1.1. 多函数程序的基本使用流程1.1.1. 1. 使用全局变量1.1.2. 2. 使用函数的返回值、参数1.1.3. 3. 函数嵌套调用1.1. 多函数程序的基本使用流程 一般在实际开发过程中，一个程序往往由多个函数（后面知识中会讲解类）组成，并且多个函数共享某些数据，这种场景是经常出现的，因此下面来总结下，多个函数中共享数据的几种方式 1.1.1. 1. 使用全局变量 g_num = 0 def test1(): global g_num # 将处理结果存储到全局变量g_num中..... g_num = 100 def test2(): # 通过获取全局变量g_num的值, 从而获取test1函数处理之后的结果 print(g_num) # 1. 先调用test1得到数据并且存到全局变量中 test1() # 2. 再调用test2，处理test1函数执行之后的这个值 test2() 1.1.2. 2. 使用函数的返回值、参数 def test1(): # 通过return将一个数据结果返回 return 50 def test2(num): # 通过形参的方式保存传递过来的数据，就可以处理了 print(num) # 1. 先调用test1得到数据并且存到变量result中 result = test1() # 2. 调用test2时，将result的值传递到test2中，从而让这个函数对其进行处理 test2(result) 1.1.3. 3. 函数嵌套调用 def test1(): # 通过return将一个数据结果返回 return 20 def test2(): # 1. 先调用test1并且把结果返回来 result = test1() # 2. 对result进行处理 print(result) # 调用test2时，完成所有的处理 test2() Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-25 21:06:42 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics_3/函数返回值二.html":{"url":"python_basics_3/函数返回值二.html","title":"函数返回值二","keywords":"","body":"1.1. 函数返回值(二)1.1.1. 多个return?1.1.2. 一个函数返回多个数据的方式1.1. 函数返回值(二) 在python中我们怎样返回多个值？ 1.1.1. 多个return? def create_nums(): print(\"---1---\") return 1 # 函数中下面的代码不会被执行，因为return除了能够将数据返回之外，还有一个隐藏的功能：结束函数 print(\"---2---\") return 2 print(\"---3---\") 总结1： 一个函数中可以有多个return语句，但是只要有一个return语句被执行到，那么这个函数就会结束了，因此后面的return没有什么用处 如果程序设计为如下，是可以的因为不同的场景下执行不同的return def create_nums(num): print(\"---1---\") if num == 100: print(\"---2---\") return num+1 # 函数中下面的代码不会被执行，因为return除了能够将数据返回之外，还有一个隐藏的功能：结束函数 else: print(\"---3---\") return num+2 print(\"---4---\") result1 = create_nums(100) print(result1) # 打印101 result2 = create_nums(200) print(result2) # 打印202 1.1.2. 一个函数返回多个数据的方式 def divid(a, b): shang = a//b yushu = a%b return shang, yushu #默认是元组 result = divid(5, 2) print(result) # 输出(2, 1) 总结2： return后面可以是元组，列表、字典等，只要是能够存储多个数据的类型，就可以一次性返回多个数据 def function(): # return [1, 2, 3] # return (1, 2, 3) return {\"num1\": 1, \"num2\": 2, \"num3\": 3} 如果return后面有多个数据，那么默认是元组 In [1]: a = 1, 2 In [2]: a Out[2]: (1, 2) In [3]: In [3]: b = (1, 2) In [4]: b Out[4]: (1, 2) In [5]: Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-25 21:06:59 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics_3/函数参数二.html":{"url":"python_basics_3/函数参数二.html","title":"函数参数二","keywords":"","body":"1.1. 函数参数(二)1.1.1. . 缺省参数1.1.2. . 不定长参数1.1.3. . 缺省参数在*args后面1.1. 函数参数(二) 1.1.1. . 缺省参数 调用函数时，缺省参数的值如果没有传入，则取默认值。 下例会打印默认的age，如果age没有被传入： def printinfo(name, age=35): # 打印任何传入的字符串 print(\"name: %s\" % name) print(\"age %d\" % age) # 调用printinfo函数 printinfo(name=\"miki\") # 在函数执行过程中 age去默认值35 printinfo(age=9 ,name=\"miki\") 以上实例输出结果： name: miki age: 35 name: miki age: 9 总结： 在形参中默认有值的参数，称之为缺省参数 注意：带有默认值的参数一定要位于参数列表的最后面 >>> def printinfo(name, age=35, sex): ... print name ... File \"\", line 1 SyntaxError: non-default argument follows default argument 1.1.2. . 不定长参数 有时可能需要一个函数能处理比当初声明时更多的参数, 这些参数叫做不定长参数，声明时不会命名。 基本语法如下： def functionname([formal_args,] *args, **kwargs): \"\"\"函数_文档字符串\"\"\" function_suite return [expression] 注意： 加了星号（*）的变量args会存放所有未命名的变量参数，args为元组 而加**的变量kwargs会存放命名参数，即形如key=value的参数， kwargs为字典. >>> def fun(a, b, *args, **kwargs): ... \"\"\"可变参数演示示例\"\"\" ... print(\"a =%d\" % a) ... print(\"b =%d\" % b) ... print(\"args:\") ... print(args) ... print(\"kwargs: \") ... for key, value in kwargs.items(): ... print(\"key=%s\" % value) ... >>> fun(1, 2, 3, 4, 5, m=6, n=7, p=8) # 注意传递的参数对应 a = 1 b = 2 args: (3, 4, 5) kwargs: p = 8 m = 6 n = 7 >>> >>> >>> >>> c = (3, 4, 5) >>> d = {\"m\":6, \"n\":7, \"p\":8} >>> fun(1, 2, *c, **d) # 注意元组与字典的传参方式 a = 1 b = 2 args: (3, 4, 5) kwargs: p = 8 m = 6 n = 7 >>> >>> >>> >>> fun(1, 2, c, d) # 注意不加星号与上面的区别 a = 1 b = 2 args: ((3, 4, 5), {'p': 8, 'm': 6, 'n': 7}) kwargs: >>> >>> 1.1.3. . 缺省参数在*args后面 def sum_nums_3(a, *args, b=22, c=33, **kwargs): print(a) print(b) print(c) print(args) print(kwargs) sum_nums_3(100, 200, 300, 400, 500, 600, 700, b=1, c=2, mm=800, nn=900) 说明： 如果很多个值都是不定长参数，那么这种情况下，可以将缺省参数放到 args的后面， 但如果有*kwargs的话，kwargs必须是最后的 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-25 21:07:15 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics_3/拆包、交换变量的值.html":{"url":"python_basics_3/拆包、交换变量的值.html","title":"拆包、交换变量的值","keywords":"","body":"1.1. 拆包、交换变量的值1.1.1. 对返回的数据直接拆包1.1.2. 交换2个变量的值1.1. 拆包、交换变量的值 1.1.1. 对返回的数据直接拆包 def get_my_info(): high = 178 weight = 100 age = 18 return high, weight, age # result = get_my_info() # print(result) my_high, my_weight, my_age = get_my_info() print(my_high) print(my_weight) print(my_age) 总结： 拆包时要注意，需要拆的数据的个数要与变量的个数相同，否则程序会异常 除了对元组拆包之外，还可以对列表、字典等拆包 In [17]: a, b = (11, 22) In [18]: a Out[18]: 11 In [19]: b Out[19]: 22 In [20]: a, b = [11, 22] In [21]: a Out[21]: 11 In [22]: b Out[22]: 22 In [23]: a, b = {\"m\":11, \"n\":22} # 取出来的是key，而不是键值对 In [24]: a Out[24]: 'm' In [25]: b Out[25]: 'n' 1.1.2. 交换2个变量的值 # 第1种方式 # a = 4 # b = 5 # c = 0 # # c = a # a = b # b = c # # print(a) # print(b) # 第2种方式 # a = 4 # b = 5 # a = a+b # a=9, b=5 # b = a-b # a=9, b=4 # a = a-b # a=5, b=4 # print(a) # print(b) # 第3种方式 a, b = 4, 5 a, b = b, a print(a) print(b) Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-25 21:07:29 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics_3/引用一.html":{"url":"python_basics_3/引用一.html","title":"引用一","keywords":"","body":"1.1. 引用(一)1.1.1. 想一想1.1.2. 引用1.1. 引用(一) 1.1.1. 想一想 >>> a = 1 >>> b = a >>> b 1 >>> a = 2 >>> a 2 请问此时b的值为多少？ >>> a = [1, 2] >>> b = a >>> b [1, 2] >>> a.append(3) >>> a [1, 2, 3] 请问此时b的值又是多少？ 1.1.2. 引用 在python中，值是靠引用来传递来的。 我们可以用id()来判断两个变量是否为同一个值的引用。 我们可以将id值理解为那块内存的地址标示。 >>> a = 1 >>> b = a >>> id(a) 13033816 >>> id(b) # 注意两个变量的id值相同 13033816 >>> a = 2 >>> id(a) # 注意a的id值已经变了 13033792 >>> id(b) # b的id值依旧 13033816 >>> a = [1, 2] >>> b = a >>> id(a) 139935018544808 >>> id(b) 139935018544808 >>> a.append(3) >>> a [1, 2, 3] >>> id(a) 139935018544808 >>> id(b) # 注意a与b始终指向同一个地址 139935018544808 总结： 之前为了更好的理解变量，咱们可以把a=100理解为变量a中存放了100，事实上变量a存储是100的引用（可理解为在内存中的一个编号） Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-26 11:52:47 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics_3/引用二.html":{"url":"python_basics_3/引用二.html","title":"引用二","keywords":"","body":"1.1. 引用(二)1.1.1. 引用当做实参1.1. 引用(二) 1.1.1. 引用当做实参 可变类型与不可变类型的变量分别作为函数参数时，会有什么不同吗？ Python有没有类似C语言中的指针传参呢？ def test1(b): # 变量b一定是一个局部变量，就看它指向的是谁？可变还是不可变 b += b # += 是直接对b指向的空间进行修改,而不是让b指向一个新的 # b = b+b # xx = xx+yyy 先把=号右边的结果计算出来,然后让b指向这个新的地方,不管原来b指向谁 # 现在b一定指向这个新的地方 # a = [11, 22] a = 100 test1(a) print(a) 总结： Python中函数参数是引用传递（注意不是值传递） 对于不可变类型，因变量不能修改，所以运算不会影响到变量自身 而对于可变类型来说，函数体中的运算有可能会更改传入的参数变量 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-25 21:07:52 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics_3/可变、不可变类型.html":{"url":"python_basics_3/可变、不可变类型.html","title":"可变、不可变类型","keywords":"","body":"1.1. 可变、不可变类型1.1.1. 总结1.1. 可变、不可变类型 1.1.1. 总结 所谓可变类型与不可变类型是指：数据能够直接进行修改，如果能直接修改那么就是可变，否则是不可变 可变类型有： 列表、字典、集合 不可变类型有： 数字、字符串、元组 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-25 21:08:27 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics_3/函数使用注意事项.html":{"url":"python_basics_3/函数使用注意事项.html","title":"函数使用注意事项","keywords":"","body":"1.1. 函数使用注意事项1.1.1. 1. 自定义函数1.1.2. 2. 调用函数1.1.3. 3. 作用域1.1. 函数使用注意事项 1.1.1. 1. 自定义函数 无参数、无返回值 def 函数名(): 语句 无参数、有返回值 def 函数名(): 语句 return 需要返回的数值 注意: 一个函数到底有没有返回值，就看有没有return，因为只有return才可以返回数据 在开发中往往根据需求来设计函数需不需要返回值 函数中，可以有多个return语句，但是只要执行到一个return语句，那么就意味着这个函数的调用完成 有参数、无返回值 def 函数名(形参列表): 语句 注意： 在调用函数时，如果需要把一些数据一起传递过去，被调用函数就需要用参数来接收 参数列表中变量的个数根据实际传递的数据的多少来确定 有参数、有返回值 def 函数名(形参列表): 语句 return 需要返回的数值 函数名不能重复 如果在同一个程序中出现了多个相同函数名的函数，那么在调用函数时就会出现问题，所以要避免名字相同 还有一点 不仅要避免函数名之间不能相同，还要避免 变量名和函数名相同的，否则都会出现问题 详细的讲解在python就业班中进行学习，此阶段只要注意这些问题即可 1.1.2. 2. 调用函数 调用的方式为： 函数名([实参列表]) 调用时，到底写不写 实参 如果调用的函数 在定义时有形参，那么在调用的时候就应该传递参数 调用时，实参的个数和先后顺序应该和定义函数中要求的一致 如果调用的函数有返回值，那么就可以用一个变量来进行保存这个值 1.1.3. 3. 作用域 在一个函数中定义的变量，只能在本函数中用(局部变量) 在函数外定义的变量，可以在所有的函数中使用(全局变量) Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-25 21:19:29 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics_3/函数应用：学生管理系统.html":{"url":"python_basics_3/函数应用：学生管理系统.html","title":"函数应用：学生管理系统","keywords":"","body":"1.1. 函数应用：学生管理系统1.1. 函数应用：学生管理系统 import time import os # 定一个列表，用来存储所有的学生信息(每个学生是一个字典) info_list = [] def print_menu(): print(\"---------------------------\") print(\" 学生管理系统 V1.0\") print(\" 1:添加学生\") print(\" 2:删除学生\") print(\" 3:修改学生\") print(\" 4:查询学生\") print(\" 5:显示所有学生\") print(\" 6:退出系统\") print(\"---------------------------\") def add_new_info(): \"\"\"添加学生信息\"\"\" global info_list new_name = input(\"请输入姓名:\") new_tel = input(\"请输入手机号:\") new_qq = input(\"请输入QQ:\") for temp_info in info_list: if temp_info['name'] == new_name: print(\"此用户名已经被占用,请重新输入\") return # 如果一个函数只有return就相当于让函数结束，没有返回值 # 定义一个字典，用来存储用户的学生信息(这是一个字典) info = {} # 向字典中添加数据 info[\"name\"] = new_name info[\"tel\"] = new_tel info[\"qq\"] = new_qq # 向列表中添加这个字典 info_list.append(info) def del_info(): \"\"\"删除学生信息\"\"\" global info_list del_num = int(input(\"请输入要删除的序号:\")) if 0 _ Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-26 12:32:51 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics_3/递归函数-了解.html":{"url":"python_basics_3/递归函数-了解.html","title":"递归函数-了解","keywords":"","body":"1.1. 递归函数1.1.1. 什么是递归函数1.1.2. 递归函数的作用1.1. 递归函数 1.1.1. 什么是递归函数 通过前面的学习知道一个函数可以调用其他函数。 如果一个函数在内部不调用其它的函数，而是自己本身的话，这个函数就是递归函数。 1.1.2. 递归函数的作用 举个例子，我们来计算阶乘 n! = 1 * 2 * 3 * ... * n 解决办法1: 看阶乘的规律 1! = 1 2! = 2 × 1 = 2 × 1! 3! = 3 × 2 × 1 = 3 × 2! 4! = 4 × 3 × 2 × 1 = 4 × 3! ... n! = n × (n-1)! 解决办法2: 原理 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-26 12:35:41 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics_3/匿名函数-Lambda.html":{"url":"python_basics_3/匿名函数-Lambda.html","title":"匿名函数-Lambda","keywords":"","body":"1.1. 匿名函数1.2. 应用场合1.2.1. 函数作为参数传递1.1. 匿名函数 用lambda关键词能创建小型匿名函数。这种函数得名于省略了用def声明函数的标准步骤。 lambda函数的语法只包含一个语句，如下： lambda [arg1 [,arg2,.....argn]]:expression 如下实例： sum = lambda arg1, arg2: arg1 + arg2 # 调用sum函数 print(\"Value of total : \" % sum( 10, 20 )) print(\"Value of total : \"% sum( 20, 20 )) 以上实例输出结果： Value of total : 30 Value of total : 40 Lambda函数能接收任何数量的参数但只能返回一个表达式的值 匿名函数不能直接调用print，因为lambda需要一个表达式 1.2. 应用场合 1.2.1. 函数作为参数传递 自己定义函数 >>> def fun(a, b, opt): ... print(\"a = \" % a) ... print(\"b = \" % b) ... print(\"result =\" % opt(a, b)) ... >>> fun(1, 2, lambda x,y:x+y) a = 1 b = 2 result = 3 作为内置函数的参数 想一想，下面的数据如何指定按age或name排序？ stus = [ {\"name\": \"zhangsan\", \"age\": 18}, {\"name\": \"lisi\", \"age\": 19}, {\"name\": \"wangwu\", \"age\": 17} ] 按name排序： >>> stus.sort(key = lambda x: x['name']) >>> stus [{'age': 19, 'name': 'lisi'}, {'age': 17, 'name': 'wangwu'}, {'age': 18, 'name': 'zhangsan'}] 按age排序： >>> stus.sort(key = lambda x: x['age']) >>> stus [{'age': 17, 'name': 'wangwu'}, {'age': 18, 'name': 'zhangsan'}, {'age': 19, 'name': 'lisi'}] Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-26 12:36:39 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics_3/列表推导式.html":{"url":"python_basics_3/列表推导式.html","title":"列表推导式","keywords":"","body":"1.1. 列表推导式1.1.1. 1. 基本的方式1.1.2. 2. 在循环的过程中使用if1.1.3. 3. 2个for循环1.1.4. 4. 3个for循环1.1.5. 练习1.1. 列表推导式 所谓的列表推导式，就是指的轻量级循环创建列表 1.1.1. 1. 基本的方式 1.1.2. 2. 在循环的过程中使用if 1.1.3. 3. 2个for循环 1.1.4. 4. 3个for循环 1.1.5. 练习 请写出一段 Python 代码实现分组一个 list 里面的元素,比如 [1,2,3,...100]变成 [[1,2,3],[4,5,6]....] 参考答案： a = [x for x in range(1,101)] b = [a[x:x+3] for x in range(0,len(a),3)] Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-26 12:37:58 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"python_basics_3/set、list、tuple.html":{"url":"python_basics_3/set、list、tuple.html","title":"set、list、tuple","keywords":"","body":"1.1. set、list、tuple1.1.1. set是集合类型1.1.2. set、list、tuple之间可以相互转换1.1.3. 使用set，可以快速的完成对list中的元素去重复的功能1.1. set、list、tuple 1.1.1. set是集合类型 1.1.2. set、list、tuple之间可以相互转换 1.1.3. 使用set，可以快速的完成对list中的元素去重复的功能 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-26 12:38:50 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"file_operation/文件操作介绍.html":{"url":"file_operation/文件操作介绍.html","title":"文件操作介绍","keywords":"","body":"1.1. 文件操作介绍1.1.1. 什么是文件1.1.2. 文件的作用1.1. 文件操作介绍 1.1.1. 什么是文件 示例如下： 1.1.2. 文件的作用 大家应该听说过一句话：“好记性不如烂笔头”。 不仅人的大脑会遗忘事情，计算机也会如此，比如一个程序在运行过程中用了九牛二虎之力终于计算出了结果，试想一下如果不把这些数据存放起来，相比重启电脑之后，“哭都没地方哭了” 可见，在把数据存储起来有做么大的价值 使用文件的目的： 就是把一些存储存放起来，可以让程序下一次执行的时候直接使用，而不必重新制作一份，省时省力 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-26 14:51:44 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"file_operation/文件的打开与关闭.html":{"url":"file_operation/文件的打开与关闭.html","title":"文件的打开与关闭","keywords":"","body":"1.1. 文件的打开与关闭1.1.1. 打开文件1.1.2. 关闭文件1.1. 文件的打开与关闭 想一想： 如果想用word编写一份简历，应该有哪些流程呢？ 打开word软件，新建一个word文件 写入个人简历信息 保存文件 关闭word软件 同样，在操作文件的整体过程与使用word编写一份简历的过程是很相似的 打开文件，或者新建立一个文件 读/写数据 关闭文件 1.1.1. 打开文件 在python，使用open函数，可以打开一个已经存在的文件，或者创建一个新文件 open(文件名，访问模式) 示例如下： f = open('test.txt', 'w') 说明: 访问模式 说明 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 w 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 w+ 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 1.1.2. 关闭文件 close( ) 示例如下： # 新建一个文件，文件名为:test.txt f = open('test.txt', 'w') # 关闭这个文件 f.close() Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-26 15:28:31 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"file_operation/文件的读写.html":{"url":"file_operation/文件的读写.html","title":"文件的读写","keywords":"","body":"1.1. 文件的读写1.1.1. 写数据(write)1.1.2. 读数据(read)1.1.3. 读数据（readlines）1.1.4. 读数据（readline）1.1.5. 想一想：1.1. 文件的读写 1.1.1. 写数据(write) 使用write()可以完成向文件写入数据 demo: 新建一个文件 file_write_test.py,向其中写入如下代码: f = open('test.txt', 'w') f.write('hello world, i am here!') f.close() 运行之后会在file_write_test.py文件所在的路径中创建一个文件test.txt,其中数据如下: 注意： 如果文件不存在那么创建，如果存在那么就先清空，然后写入数据 1.1.2. 读数据(read) 使用read(num)可以从文件中读取数据，num表示要从文件中读取的数据的长度（单位是字节），如果没有传入num，那么就表示读取文件中所有的数据 demo: 新建一个文件file_read_test.py，向其中写入如下代码: f = open('test.txt', 'r') content = f.read(5) # 最多读取5个数据 print(content) print(\"-\"*30) # 分割线，用来测试 content = f.read() # 从上次读取的位置继续读取剩下的所有的数据 print(content) f.close() # 关闭文件，这个可以是个好习惯哦 运行现象： hello ------------------------------ world, i am here! 注意： 如果用open打开文件时，如果使用的\"r\"，那么可以省略，即只写 open('test.txt') 1.1.3. 读数据（readlines） 就像read没有参数时一样，readlines可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个列表，其中每一行的数据为一个元素 #coding=utf-8 f = open('test.txt', 'r') content = f.readlines() print(type(content)) i=1 for temp in content: print(\"%d:%s\" % (i, temp)) i += 1 f.close() 运行现象： 1.1.4. 读数据（readline） #coding=utf-8 f = open('test.txt', 'r') content = f.readline() print(\"1:%s\" % content) content = f.readline() print(\"2:%s\" % content) f.close() 1.1.5. 想一想： 如果一个文件很大，比如5G，试想应该怎样把文件的数据读取到内存然后进行处理呢？ Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-26 15:29:56 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"file_operation/应用1:制作文件的备份.html":{"url":"file_operation/应用1:制作文件的备份.html","title":"应用1:制作文件的备份","keywords":"","body":"1.1. 应用1:制作文件的备份1.1.1. 任务描述1.1.2. 参考代码1.1. 应用1:制作文件的备份 1.1.1. 任务描述 输入文件的名字，然后程序自动完成对文件进行备份 1.1.2. 参考代码 # 提示输入文件 oldFileName = input(\"请输入要拷贝的文件名字:\") # 以读的方式打开文件 oldFile = open(oldFileName,'rb') # 提取文件的后缀 fileFlagNum = oldFileName.rfind('.') if fileFlagNum > 0: fileFlag = oldFileName[fileFlagNum:] # 组织新的文件名字 newFileName = oldFileName[:fileFlagNum] + '[复件]' + fileFlag # 创建新文件 newFile = open(newFileName, 'wb') # 把旧文件中的数据，一行一行的进行复制到新文件中 for lineContent in oldFile.readlines(): newFile.write(lineContent) # 关闭文件 oldFile.close() newFile.close() Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-26 15:30:53 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"file_operation/文件、文件夹的相关操作.html":{"url":"file_operation/文件、文件夹的相关操作.html","title":"文件-文件夹的相关操作","keywords":"","body":"1. 文件-文件夹的相关操作1. 文件-文件夹的相关操作 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-26 20:48:19 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"file_operation/应用2:批量修改文件名.html":{"url":"file_operation/应用2:批量修改文件名.html","title":"应用2:批量修改文件名","keywords":"","body":"1.1. 应用2:批量修改文件名1.1.1. 运行过程演示1.1.2. 参考代码1.1. 应用2:批量修改文件名 1.1.1. 运行过程演示 运行程序之前 运行程序之后 1.1.2. 参考代码 #coding=utf-8 # 批量在文件名前加前缀 import os funFlag = 1 # 1表示添加标志 2表示删除标志 folderName = './renameDir/' # 获取指定路径的所有文件名字 dirList = os.listdir(folderName) # 遍历输出所有文件名字 for name in dirList: print name if funFlag == 1: newName = '[东哥出品]-' + name elif funFlag == 2: num = len('[东哥出品]-') newName = name[num:] print newName os.rename(folderName+name, folderName+newName) Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-26 15:40:41 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"file_operation/综合应用:学生管理系统-文件版.html":{"url":"file_operation/综合应用:学生管理系统-文件版.html","title":"综合应用:学生管理系统-文件版","keywords":"","body":"1.1. 综合应用:学生管理系统-文件版1.1.1. 注意：1.1. 综合应用:学生管理系统-文件版 import time import os # 定一个列表，用来存储所有的学生信息(每个学生是一个字典) info_list = [] def print_menu(): print(\"---------------------------\") print(\" 学生管理系统 V1.0\") print(\" 1:添加学生\") print(\" 2:删除学生\") print(\" 3:修改学生\") print(\" 4:查询学生\") print(\" 5:显示所有学生\") print(\" 6:保存数据\") print(\" 7:退出系统\") print(\"---------------------------\") def add_new_info(): \"\"\"添加学生信息\"\"\" global info_list new_name = input(\"请输入姓名:\") new_tel = input(\"请输入手机号:\") new_qq = input(\"请输入QQ:\") for temp_info in info_list: if temp_info['name'] == new_name: print(\"此用户名已经被占用,请重新输入\") return # 如果一个函数只有return就相当于让函数结束，没有返回值 # 定义一个字典，用来存储用户的学生信息(这是一个字典) info = {} # 向字典中添加数据 info[\"name\"] = new_name info[\"tel\"] = new_tel info[\"qq\"] = new_qq # 向列表中添加这个字典 info_list.append(info) def del_info(): \"\"\"删除学生信息\"\"\" global info_list del_num = int(input(\"请输入要删除的序号:\")) if 0 _ 1.1.1. 注意： 以上程序，在运行之前请先建立info_data.data文件，并且写入一对中括号[]即可 等到后面讲解完异常之后就解决了这个问题 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-26 15:42:45 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Object_oriented_1/":{"url":"Object_oriented_1/","title":"面向对象基础(一)","keywords":"","body":"1. 面向对象基础(一)1. 面向对象基础(一) Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-27 11:37:25 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Object_oriented_1/面向对象编程介绍.html":{"url":"Object_oriented_1/面向对象编程介绍.html","title":"面向对象编程介绍","keywords":"","body":"1. 面向对象编程介绍1.1. 想一想1. 面向对象编程介绍 1.1. 想一想 请用程序描述如下事情： A同学报道登记信息 B同学报道登记信息 C同学报道登记信息 A同学做自我介绍 B同学做自我介绍 C同学做自我介绍 stu_a = { \"name\":\"A\", \"age\":21, \"gender\":1, \"hometown\":\"河北\" } stu_b = { \"name\":\"B\", \"age\":22, \"gender\":0, \"hometown\":\"山东\" } stu_c = { \"name\":\"C\", \"age\":20, \"gender\":1, \"hometown\":\"安徽\" } def stu_intro(stu): \"\"\"自我介绍\"\"\" for key, value in stu.items(): print(\"key=%s, value=%d\"%(key,value)) stu_intro(stu_a) stu_intro(stu_b) stu_intro(stu_c) 考虑现实生活中，我们的思维方式是放在学生这个个人上，是学生做了自我介绍。而不是像我们刚刚写出的代码，先有了介绍的行为，再去看介绍了谁。 用我们的现实思维方式该怎么用程序表达呢？ stu_a = Student(个人信息) stu_b = Student(个人信息) stu_c = Student(个人信息) stu_a.intro() stu_b.intro() stu_c.intro() 面向过程：根据业务逻辑从上到下写代码 面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程 面向过程编程最易被初学者接受，其往往用一长段代码来实现指定功能，开发过程的思路是将数据与函数按照执行的逻辑顺序组织在一起，数据与函数分开考虑。 今天我们来学习一种新的编程方式：面向对象编程（Object Oriented Programming，OOP，面向对象程序设计） 1）解决菜鸟买电脑的故事 第一种方式: 1)在网上查找资料 2)根据自己预算和需求定电脑的型号 MacBook 15 顶配 1W8 3)去市场找到苹果店各种店无法甄别真假 随便找了一家 4)找到业务员,业务员推荐了另外一款 配置更高价格便宜,也是苹果系统的 1W 5)砍价30分钟 付款9999 6)成交 回去之后发现各种问题 第二种方式 : 1)找一个靠谱的电脑高手 2)给钱交易 面向对象和面向过程都是解决问题的一种思路而已 买电脑的第一种方式: 强调的是步骤、过程、每一步都是自己亲自去实现的 这种解决问题的思路我们就叫做面向过程 买电脑的第二种方式: 强调的是电脑高手, 电脑高手是处理这件事的主角,对我们而言,我们并不必亲自实现整个步骤只需要调用电脑高手就可以解决问题 这种解决问题的思路就 是面向对象 用面向对象的思维解决问题的重点 当遇到一个需求的时候不用自己去实现，如果自己一步步实现那就是面向过程 应该找一个专门做这个事的人来做 面向对象是基于面向过程的 2）解决吃啤酒鸭的问题 第一种方式（面向过程）: 1)养鸭子 2)鸭子长成 3)杀 4)作料 5)烹饪 6)吃 7)卒 第二种方式（面向对象）: 1)找个卖啤酒鸭的人 2)给钱 交易 3)吃 4)胖6斤 需要了解的定义性文字: 面向对象(object-oriented ;简称: OO) 至今还没有统一的概念 我这里把它定义为: 按人们 认识客观世界的系统思维方式,采用基于对象(实体) 的概念建立模型,模拟客观世界分析、设 计、实现软件的办法。 面向对象编程(Object Oriented Programming-OOP) 是一种解决软件复用的设计和编程方法。 这种方法把软件系统中相近相似的操作逻辑和操作 应用数据、状态,以类的型式描述出来,以对象实例的形式在软件系统中复用,以达到提高软件开发效率的作用。 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-26 16:07:04 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Object_oriented_1/类和对象.html":{"url":"Object_oriented_1/类和对象.html","title":"类和对象","keywords":"","body":"1. 类和对象1.1. 1. 类1.2. 2. 对象1.3. 3. 类和对象之间的关系1.4. 4. 练习：区分类和对象1.5. 5. 类的构成1.6. 6. 类的抽象1. 类和对象 面向对象编程的2个非常重要的概念：类和对象 对象是面向对象编程的核心，在使用对象的过程中，为了将具有共同特征和行为的一组对象抽象定义，提出了另外一个新的概念——类 类就相当于制造飞机时的图纸，用它来进行创建的飞机就相当于对象 1.1. 1. 类 人以类聚 物以群分。 具有相似内部状态和运动规律的实体的集合(或统称为抽象)。 具有相同属性和行为事物的统称 类是抽象的,在使用的时候通常会找到这个类的一个具体的存在,使用这个具体的存在。一个类可以找到多个对象 1.2. 2. 对象 某一个具体事物的存在 ,在现实世界中可以是看得见摸得着的。 可以是直接使用的 1.3. 3. 类和对象之间的关系 小总结：类就是创建对象的模板 1.4. 4. 练习：区分类和对象 奔驰汽车 类 奔驰smart 类 张三的那辆奔驰smart 对象 狗 类 大黄狗 类 李四家那只大黄狗 对象 水果 类 苹果 类 红苹果 类 红富士苹果 类 我嘴里吃了一半的苹果 对象 1.5. 5. 类的构成 类(Class) 由3个部分构成 类的名称:类名 类的属性:一组数据 类的方法:允许对进行操作的方法 (行为) 举例： 1）人类设计,只关心3样东西: 事物名称(类名):人(Person) 属性:身高(height)、年龄(age) 方法(行为/功能):跑(run)、打架(fight) 2）狗类的设计 类名:狗(Dog) 属性:品种 、毛色、性别、名字、 腿儿的数量 方法(行为/功能):叫 、跑、咬人、吃、摇尾巴 1.6. 6. 类的抽象 如何把日常生活中的事物抽象成程序中的类? 拥有相同(或者类似)属性和行为的对象都可以抽像出一个类 方法:一般名词都是类(名词提炼法) 坦克发射3颗炮弹轰掉了2架飞机 坦克--》可以抽象成 类 炮弹--》可以抽象成类 飞机-》可以抽象成类 小明在公车上牵着一条叼着热狗的狗 小明--》 人类 公车--》 交通工具类 热狗--》 食物类 狗--》 狗类 【想一想】如下图中，有哪些类呢？ 说明： 人 枪 子弹 手榴弹 刀子 箱子 【想一想】如下图中，有哪些类呢？ 说明: 向日葵 类名: xrk 属性: 行为: 放阳光 豌豆 类名: wd 属性: 颜色 、发型,血量 行为:发炮, 摇头 坚果: 类名:jg 属性:血量 类型 行为:阻挡; 僵尸: 类名:js 属性:颜色、血量、 类型、速度 行为:走 跑跳 吃 死 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-26 16:10:05 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Object_oriented_1/定义类.html":{"url":"Object_oriented_1/定义类.html","title":"定义类","keywords":"","body":"1.1. 定义类1.1. 定义类 定义一个类，格式如下： class 类名: 方法列表 demo：定义一个Hero类 # class Hero: # 经典类（旧式类）定义形式 # class Hero(): class Hero(object): # 新式类定义形式 def info(self): print(\"英雄各有见，何必问出处。\") 说明： 定义类时有2种形式：新式类和经典类，上面代码中的Hero为新式类，前两行注释部分则为经典类； object 是Python 里所有类的最顶级父类； 类名 的命名规则按照\"大驼峰命名法\"； info 是一个实例方法，第一个参数一般是self，表示实例对象本身，当然了可以将self换为其它的名字，其作用是一个变量 这个变量指向了实例对象 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-26 16:10:29 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Object_oriented_1/创建对象.html":{"url":"Object_oriented_1/创建对象.html","title":"创建对象","keywords":"","body":"1.1. 创建对象1.1. 创建对象 python中，可以根据已经定义的类去创建出一个或多个对象。 创建对象的格式为: 对象名1 = 类名() 对象名2 = 类名() 对象名3 = 类名() 创建对象demo: class Hero(object): # 新式类定义形式 \"\"\"info 是一个实例方法，类对象可以调用实例方法，实例方法的第一个参数一定是self\"\"\" def info(self): \"\"\"当对象调用实例方法时，Python会自动将对象本身的引用做为参数， 传递到实例方法的第一个参数self里\"\"\" print(self) print(\"self各不同，对象是出处。\") # Hero这个类 实例化了一个对象 taidamier(泰达米尔) taidamier = Hero() # 对象调用实例方法info()，执行info()里的代码 # . 表示选择属性或者方法 taidamier.info() print(taidamier) # 打印对象，则默认打印对象在内存的地址，结果等同于info里的print(self) print(id(taidamier)) # id(taidamier) 则是内存地址的十进制形式表示 说明： 当创建一个对象时，就是用一个模子，来制造一个实物 问题： 对象既然有实例方法，是否也可以有自己的属性? Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-26 16:11:28 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Object_oriented_1/添加和获取对象的属性.html":{"url":"Object_oriented_1/添加和获取对象的属性.html","title":"添加和获取对象的属性","keywords":"","body":"1. 添加和获取对象的属性1. 添加和获取对象的属性 class Hero(object): \"\"\"定义了一个英雄类，可以移动和攻击\"\"\" def move(self): \"\"\"实例方法\"\"\" print(\"正在前往事发地点...\") def attack(self): \"\"\"实例方法\"\"\" print(\"发出了一招强力的普通攻击...\") # 实例化了一个英雄对象 泰达米尔 taidamier = Hero() # 给对象添加属性，以及对应的属性值 taidamier.name = \"泰达米尔\" # 姓名 taidamier.hp = 2600 # 生命值 taidamier.atk = 450 # 攻击力 taidamier.armor = 200 # 护甲值 # 通过.成员选择运算符，获取对象的属性值 print(\"英雄 %s 的生命值 :%d\" % (taidamier.name, taidamier.hp)) print(\"英雄 %s 的攻击力 :%d\" % (taidamier.name, taidamier.atk)) print(\"英雄 %s 的护甲值 :%d\" % (taidamier.name, taidamier.armor)) # 通过.成员选择运算符，获取对象的实例方法 taidamier.move() taidamier.attack() 问题： 对象创建并添加属性后，能否在类的实例方法里获取这些属性呢？如果可以的话，应该通过什么方式？ Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-26 16:12:32 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Object_oriented_1/实例方法内通过self获取对象属性.html":{"url":"Object_oriented_1/实例方法内通过self获取对象属性.html","title":"实例方法内通过self获取对象属性","keywords":"","body":"1. 在方法内通过self获取对象属性1. 在方法内通过self获取对象属性 class Hero(object): \"\"\"定义了一个英雄类，可以移动和攻击\"\"\" def move(self): \"\"\"实例方法\"\"\" print(\"正在前往事发地点...\") def attack(self): \"\"\"实例方法\"\"\" print(\"发出了一招强力的普通攻击...\") def info(self): \"\"\"在类的实例方法中，通过self获取该对象的属性\"\"\" print(\"英雄 %s 的生命值 :%d\" % (self.name, self.hp)) print(\"英雄 %s 的攻击力 :%d\" % (self.name, self.atk)) print(\"英雄 %s 的护甲值 :%d\" % (self.name, self.armor)) # 实例化了一个英雄对象 泰达米尔 taidamier = Hero() # 给对象添加属性，以及对应的属性值 taidamier.name = \"泰达米尔\" # 姓名 taidamier.hp = 2600 # 生命值 taidamier.atk = 450 # 攻击力 taidamier.armor = 200 # 护甲值 # 通过.成员选择运算符，获取对象的实例方法 taidamier.info() # 只需要调用实例方法info()，即可获取英雄的属性 taidamier.move() taidamier.attack() 问题： 创建对象后再去添加属性有点不合适，有没有简单的办法，可以在创建对象的时候，就已经拥有这些属性？ Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-26 16:13:14 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Object_oriented_1/魔法方法：__init__.html":{"url":"Object_oriented_1/魔法方法：__init__.html","title":"魔法方法：init","keywords":"","body":"1. init()方法1. init()方法 class Hero(object): \"\"\"定义了一个英雄类，可以移动和攻击\"\"\" # Python 的类里提供的，两个下划线开始，两个下划线结束的方法，就是魔法方法，__init__()就是一个魔法方法，通常用来做属性初始化 或 赋值 操作。 # 如果类面没有写__init__方法，Python会自动创建，但是不执行任何操作， # 如果为了能够在完成自己想要的功能，可以自己定义__init__方法， # 所以一个类里无论自己是否编写__init__方法 一定有__init__方法。 def __init__(self): \"\"\" 方法，用来做变量初始化 或 赋值 操作，在类实例化对象的时候，会被自动调用\"\"\" self.name = \"泰达米尔\" # 姓名 self.hp = 2600 # 生命值 self.atk = 450 # 攻击力 self.armor = 200 # 护甲值 def move(self): \"\"\"实例方法\"\"\" print(\"正在前往事发地点...\") def attack(self): \"\"\"实例方法\"\"\" print(\"发出了一招强力的普通攻击...\") # 实例化了一个英雄对象，并自动调用__init__()方法 taidamier = Hero() # 通过.成员选择运算符，获取对象的实例方法 taidamier.info() # 只需要调用实例方法info()，即可获取英雄的属性 taidamier.move() taidamier.attack() 说明： __init__()方法，在创建一个对象时默认被调用，不需要手动调用 __init__(self)中的self参数，不需要开发者传递，python解释器会自动把当前的对象引用传递过去。 问题： 在类的方法里定义属性的固定值，则每个对象实例变量的属性值都是相同的。 一个游戏里往往有很多不同的英雄，能否让实例化的每个对象，都有不同的属性值呢？ Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-26 20:19:59 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Object_oriented_1/有参数的__init__方法.html":{"url":"Object_oriented_1/有参数的__init__方法.html","title":"有参数的init()方法","keywords":"","body":"1. 有参数的init()方法1. 有参数的init()方法 class Hero(object): \"\"\"定义了一个英雄类，可以移动和攻击\"\"\" def __init__(self, name, skill, hp, atk, armor): \"\"\" __init__() 方法，用来做变量初始化 或 赋值 操作\"\"\" # 英雄名 self.name = name # 技能 self.skill = skill # 生命值： self.hp = hp # 攻击力 self.atk = atk # 护甲值 self.armor = armor def move(self): \"\"\"实例方法\"\"\" print(\"%s 正在前往事发地点...\" % self.name) def attack(self): \"\"\"实例方法\"\"\" print(\"发出了一招强力的%s...\" % self.skill) def info(self): print(\"英雄 %s 的生命值 :%d\" % (self.name, self.hp)) print(\"英雄 %s 的攻击力 :%d\" % (self.name, self.atk)) print(\"英雄 %s 的护甲值 :%d\" % (self.name, self.armor)) # 实例化英雄对象时，参数会传递到对象的__init__()方法里 taidamier = Hero(\"泰达米尔\", \"旋风斩\", 2600, 450, 200) gailun = Hero(\"盖伦\", \"大宝剑\", 4200, 260, 400) # print(gailun) # print(taidamier) # 不同对象的属性值的单独保存 print(id(taidamier.name)) print(id(gailun.name)) # 同一个类的不同对象，实例方法共享 print(id(taidamier.move())) print(id(gailun.move())) 说明： 通过一个类，可以创建多个对象，就好比 通过一个模具创建多个实体一样 __init__(self)中，默认有1个参数名字为self，如果在创建对象时传递了2个实参，那么__init__(self)中出了self作为第一个形参外还需要2个形参，例如__init__(self,x,y) 注意： 在类内部获取 属性 和 实例方法，通过self获取； 在类外部获取 属性 和 实例方法，通过对象名获取。 如果一个类有多个对象，每个对象的属性是各自保存的，都有各自独立的地址； 但是实例方法是所有对象共享的，只占用一份内存空间。类会通过self来判断是哪个对象调用了实例方法。 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-26 20:20:37 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Object_oriented_1/魔法方法：__str__.html":{"url":"Object_oriented_1/魔法方法：__str__.html","title":"魔法方法：str","keywords":"","body":"1. str()方法1. str()方法 class Hero(object): \"\"\"定义了一个英雄类，可以移动和攻击\"\"\" def __init__(self, name, skill, hp, atk, armor): \"\"\" __init__() 方法，用来做变量初始化 或 赋值 操作\"\"\" # 英雄名 self.name = name # 实例变量 # 技能 self.skill = skill # 生命值： self.hp = hp # 实例变量 # 攻击力 self.atk = atk # 护甲值 self.armor = armor def move(self): \"\"\"实例方法\"\"\" print(\"%s 正在前往事发地点...\" % self.name) def attack(self): \"\"\"实例方法\"\"\" print(\"发出了一招强力的%s...\" % self.skill) # def info(self): # print(\"英雄 %s 的生命值 :%d\" % (self.name, self.hp)) # print(\"英雄 %s 的攻击力 :%d\" % (self.name, self.atk)) # print(\"英雄 %s 的护甲值 :%d\" % (self.name, self.armor)) def __str__(self): \"\"\" 这个方法是一个魔法方法 (Magic Method) ，用来显示信息 该方法需要 return 一个数据，并且只有self一个参数，当在类的外部 print(对象) 则打印这个数据 \"\"\" return \"英雄 数据： 生命值 %d, 攻击力 %d, 护甲值 %d\" % (self.name, self.hp, self.atk, self.armor) taidamier = Hero(\"泰达米尔\", \"旋风斩\", 2600, 450, 200) gailun = Hero(\"盖伦\", \"大宝剑\", 4200, 260, 400) # 如果没有__str__ 则默认打印 对象在内存的地址。 # 当类的实例化对象 拥有 __str__ 方法后，那么打印对象则打印 __str__ 的返回值。 print(taidamier) print(gailun) # 查看类的文档说明，也就是类的注释 print(Hero.__doc__) 说明： 在python中方法名如果是__xxxx__()的，那么就有特殊的功能，因此叫做“魔法”方法 当使用print输出对象的时候，默认打印对象的内存地址。如果类定义了__str__(self)方法，那么就会打印从在这个方法中 return 的数据 __str__方法通常返回一个字符串，作为这个对象的描述信息 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-26 20:20:52 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Object_oriented_1/魔法方法：__del__.html":{"url":"Object_oriented_1/魔法方法：__del__.html","title":"魔法方法：del","keywords":"","body":"1.1. __del__()方法1.1. __del__()方法 创建对象后，python解释器默认调用__init__()方法； 当删除对象时，python解释器也会默认调用一个方法，这个方法为__del__()方法 class Hero(object): # 初始化方法 # 创建完对象后会自动被调用 def __init__(self, name): print('__init__方法被调用') self.name = name # 当对象被删除时，会自动被调用 def __del__(self): print(\"__del__方法被调用\") print(\"%s 被 GM 干掉了...\" % self.name) # 创建对象 taidamier = Hero(\"泰达米尔\") # 删除对象 print(\"%d 被删除1次\" % id(taidamier)) del(taidamier) print(\"--\" * 10) gailun = Hero(\"盖伦\") gailun1 = gailun gailun2 = gailun print(\"%d 被删除1次\" % id(gailun)) del(gailun) print(\"%d 被删除1次\" % id(gailun1)) del(gailun1) print(\"%d 被删除1次\" % id(gailun2)) del(gailun2) 总结 当有变量保存了一个对象的引用时，此对象的引用计数就会加1； 当使用del() 删除变量指向的对象时，则会减少对象的引用计数。如果对象的引用计数不为1，那么会让这个对象的引用计数减1，当对象的引用计数为0的时候，则对象才会被真正删除（内存被回收）。 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-26 20:21:24 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Object_oriented_1/参考案例：烤地瓜.html":{"url":"Object_oriented_1/参考案例：烤地瓜.html","title":"参考案例：烤地瓜","keywords":"","body":"1. 应用:烤地瓜1.1. 1. 分析“烤地瓜”的属性和方法1.1.1. 示例属性如下:1.1.2. 示例方法如下:1.2. 2. 定义类，并且定义__init__()方法1.3. 3. 添加\"烤地瓜\"方法1.4. 4. 基本的功能已经有了一部分，赶紧测试一下1.5. 5. 测试cook方法是否好用1.6. 6. 定义addCondiments()方法和__str__()方法1.7. 7. 再次测试1. 应用:烤地瓜 为了更好的理解面向对象编程，下面以“烤地瓜”为案例，进行分析 1.1. 1. 分析“烤地瓜”的属性和方法 1.1.1. 示例属性如下: cookedLevel : 这是数字；0~3表示还是生的，超过3表示半生不熟，超过5表示已经烤好了，超过8表示已经烤成木炭了！我们的地瓜开始时时生的 cookedString : 这是字符串；描述地瓜的生熟程度 condiments : 这是地瓜的配料列表，比如番茄酱、芥末酱等 1.1.2. 示例方法如下: cook() : 把地瓜烤一段时间 addCondiments() : 给地瓜添加配料 __init__() : 设置默认的属性 __str__() : 让print的结果看起来更好一些 1.2. 2. 定义类，并且定义__init__()方法 #定义`地瓜`类 class SweetPotato: \"\"\"这是烤地瓜的类\"\"\" #定义初始化方法 def __init__(self): self.cookedLevel = 0 self.cookedString = \"生的\" self.condiments = [] 1.3. 3. 添加\"烤地瓜\"方法 #烤地瓜方法 def cook(self, time): self.cookedLevel += time if self.cookedLevel > 8: self.cookedString = \"烤成灰了\" elif self.cookedLevel > 5: self.cookedString = \"烤好了\" elif self.cookedLevel > 3: self.cookedString = \"半生不熟\" else: self.cookedString = \"生的\" 1.4. 4. 基本的功能已经有了一部分，赶紧测试一下 把上面2块代码合并为一个程序后，在代码的下面添加以下代码进行测试 mySweetPotato = SweetPotato() print(mySweetPotato.cookedLevel) print(mySweetPotato.cookedString) print(mySweetPotato.condiments) 完整的代码为: class SweetPotato: \"\"\"这是烤地瓜的类\"\"\" # 定义初始化方法 def __init__(self): self.cookedLevel = 0 self.cookedString = \"生的\" self.condiments = [] # 烤地瓜方法 def cook(self, time): self.cookedLevel += time if self.cookedLevel > 8: self.cookedString = \"烤成灰了\" elif self.cookedLevel > 5: self.cookedString = \"烤好了\" elif self.cookedLevel > 3: self.cookedString = \"半生不熟\" else: self.cookedString = \"生的\" # 用来进行测试 mySweetPotato = SweetPotato() print(mySweetPotato.cookedLevel) print(mySweetPotato.cookedString) print(mySweetPotato.condiments) 1.5. 5. 测试cook方法是否好用 在上面的代码最后面添加如下代码: print(\"------接下来要进行烤地瓜了-----\") mySweetPotato.cook(4) #烤4分钟 print(mySweetPotato.cookedLevel) print(mySweetPotato.cookedString) 1.6. 6. 定义addCondiments()方法和__str__()方法 def __str__(self): msg = self.cookedString + \" 地瓜\" if len(self.condiments) > 0: msg = msg + \"(\" for temp in self.condiments: msg = msg + temp + \", \" msg = msg.strip(\", \") msg = msg + \")\" return msg def addCondiments(self, condiments): self.condiments.append(condiments) 1.7. 7. 再次测试 完整的代码如下: class SweetPotato: \"\"\"这是烤地瓜的类\"\"\" # 定义初始化方法 def __init__(self): self.cookedLevel = 0 self.cookedString = \"生的\" self.condiments = [] # 定制print时的显示内容 def __str__(self): msg = self.cookedString + \" 地瓜\" if len(self.condiments) > 0: msg = msg + \"(\" for temp in self.condiments: msg = msg + temp + \", \" msg = msg.strip(\", \") msg = msg + \")\" return msg # 烤地瓜方法 def cook(self, time): self.cookedLevel += time if self.cookedLevel > 8: self.cookedString = \"烤成灰了\" elif self.cookedLevel > 5: self.cookedString = \"烤好了\" elif self.cookedLevel > 3: self.cookedString = \"半生不熟\" else: self.cookedString = \"生的\" # 添加配料 def addCondiments(self, condiments): self.condiments.append(condiments) # 用来进行测试 mySweetPotato = SweetPotato() print(\"------有了一个地瓜，还没有烤-----\") print(mySweetPotato.cookedLevel) print(mySweetPotato.cookedString) print(mySweetPotato.condiments) print(\"------接下来要进行烤地瓜了-----\") print(\"------地瓜经烤了4分钟-----\") mySweetPotato.cook(4) #烤4分钟 print(mySweetPotato) print(\"------地瓜又经烤了3分钟-----\") mySweetPotato.cook(3) #又烤了3分钟 print(mySweetPotato) print(\"------接下来要添加配料-番茄酱------\") mySweetPotato.addCondiments(\"番茄酱\") print(mySweetPotato) print(\"------地瓜又经烤了5分钟-----\") mySweetPotato.cook(5) #又烤了5分钟 print(mySweetPotato) print(\"------接下来要添加配料-芥末酱------\") mySweetPotato.addCondiments(\"芥末酱\") print(mySweetPotato) Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-26 20:47:19 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Object_oriented_2/参考案例：存放家具.html":{"url":"Object_oriented_2/参考案例：存放家具.html","title":"参考案例：存放家具","keywords":"","body":"1.1. 应用:存放家具1.1. 应用:存放家具 # 定义一个home类 class Home: def __init__(self, area): self.area = area #房间剩余的可用面积 # self.light = 'on' #灯默认是亮的 self.containsItem = [] def __str__(self): msg = \"当前房间可用面积为:\" + str(self.area) if len(self.containsItem) > 0: msg = msg + \" 容纳的物品有: \" for temp in self.containsItem: msg = msg + temp.getName() + \", \" msg = msg.strip(\", \") return msg # 容纳物品 def accommodateItem(self,item): # 如果可用面积大于物品的占用面积 needArea = item.getUsedArea() if self.area > needArea: self.containsItem.append(item) self.area -= needArea print(\"ok:已经存放到房间中\") else: print(\"err:房间可用面积为:%d,但是当前要存放的物品需要的面积为%d\"%(self.area, needArea)) # 定义bed类 class Bed: def __init__(self,area,name = '床'): self.name = name self.area = area def __str__(self): msg = '床的面积为:' + str(self.area) return msg # 获取床的占用面积 def getUsedArea(self): return self.area def getName(self): return self.name # 创建一个新家对象 newHome = Home(100)#100平米 print(newHome) # 创建一个床对象 newBed = Bed(20) print(newBed) # 把床安放到家里 newHome.accommodateItem(newBed) print(newHome) # 创建一个床对象 newBed2 = Bed(30,'席梦思') print(newBed2) # 把床安放到家里 newHome.accommodateItem(newBed2) print(newHome) 总结： 如果一个对象与另外一个对象有一定的关系，那么一个对象可用是另外一个对象的属性 思维升华： 添加“开、关”灯，让房间、床一起亮、灭 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-27 11:43:39 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Object_oriented_2/继承的概念.html":{"url":"Object_oriented_2/继承的概念.html","title":"继承的概念","keywords":"","body":"1. 继承介绍以及单继承1.1. 1. 现实中的继承1.2. 2. 程序中的继承1. 继承介绍以及单继承 1.1. 1. 现实中的继承 在现实生活中，继承一般指的是子女继承父辈的财产，如下图 搞不好,结果如下.. 1.2. 2. 程序中的继承 在程序中，继承描述的是多个类之间的所属关系。 如果一个类A里面的属性和方法可以复用，则可以通过继承的方式，传递到类B里。 那么类A就是基类，也叫做父类；类B就是派生类，也叫做子类。 # 父类 class A(object): def __init__(self): self.num = 10 def print_num(self): print(self.num + 10) # 子类 class B(A): pass b = B() print(b.num) b.print_num() Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-27 11:45:28 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Object_oriented_2/单继承.html":{"url":"Object_oriented_2/单继承.html","title":"单继承","keywords":"","body":"1.1. 单继承：子类只继承一个父类1.1. 单继承：子类只继承一个父类 故事情节：煎饼果子老师傅在煎饼果子界摸爬滚打几十年，拥有一身精湛的煎饼果子技术，并总结了一套\"古法煎饼果子配方\"。 可是老师傅年迈已久，在嗝屁之前希望把自己的配方传承下去，于是老师傅把配方传给他的徒弟大猫... # 定义一个Master类 class Master(object): def __init__(self): # 属性 self.kongfu = \"古法煎饼果子配方\" # 实例方法 def make_cake(self): print(\"按照 制作了一份煎饼果子...\" % self.kongfu) # 定义Prentice类，继承了 Master，则Prentice是子类，Master是父类。 class Prentice(Master): # 子类可以继承父类所有的属性和方法，哪怕子类没有自己的属性和方法，也可以使用父类的属性和方法。 pass # laoli = Master() # print(laoli.kongfu) # laoli.make_cake() damao = Prentice() # 创建子类实例对象 print(damao.kongfu) # 子类对象可以直接使用父类的属性 damao.make_cake() # 子类对象可以直接使用父类的方法 说明： 虽然子类没有定义__init__方法初始化属性，也没有定义实例方法，但是父类有。所以只要创建子类的对象，就默认执行了那个继承过来的__init__方法 总结： 子类在继承的时候，在定义类时，小括号()中为父类的名字 父类的属性、方法，会被继承给子类 剧情发展： 大猫掌握了师傅的配方，可以制作古法煎饼果子。但是大猫是个爱学习的好孩子，他希望学到更多的煎饼果子的做法，于是通过百度搜索，找到了一家煎饼果子培训学校。（多继承） Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-27 11:45:50 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Object_oriented_2/多继承.html":{"url":"Object_oriented_2/多继承.html","title":"多继承","keywords":"","body":"1. 多继承：子类继承多个父类1. 多继承：子类继承多个父类 class Master(object): def __init__(self): self.kongfu = \"古法煎饼果子配方\" # 实例变量，属性 def make_cake(self): # 实例方法，方法 print(\"[古法] 按照 制作了一份煎饼果子...\" % self.kongfu) def dayandai(self): print(\"师傅的大烟袋..\") class School(object): def __init__(self): self.kongfu = \"现代煎饼果子配方\" def make_cake(self): print(\"[现代] 按照 制作了一份煎饼果子...\" % self.kongfu) def xiaoyandai(self): print(\"学校的小烟袋..\") # class Prentice(School, Master): # 多继承，继承了多个父类（School在前） # pass # damao = Prentice() # print(damao.kongfu) # damao.make_cake() # damao.dayandai() # damao.xiaoyandai() class Prentice(Master, School): # 多继承，继承了多个父类（Master在前） pass damao = Prentice() print(damao.kongfu) # 执行Master的属性 damao.make_cake() # 执行Master的实例方法 # 子类的魔法属性__mro__决定了属性和方法的查找顺序 print(Prentice.__mro__) damao.dayandai() # 不重名不受影响 damao.xiaoyandai() 说明： 多继承可以继承多个父类，也继承了所有父类的属性和方法 注意：如果多个父类中有同名的 属性和方法，则默认使用第一个父类的属性和方法（根据类的魔法属性mro的顺序来查找） 多个父类中，不重名的属性和方法，不会有任何影响。 剧情发展： 大猫掌握了 师傅的配方 和 学校的配方，通过研究，大猫在两个配方的基础上，创建了一种全新的煎饼果子配方，称之为 \"猫氏煎饼果子配方\"。（子类重写父类同名属性和方法） Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-27 11:46:06 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Object_oriented_2/子类重写父类的同名属性和方法.html":{"url":"Object_oriented_2/子类重写父类的同名属性和方法.html","title":"子类重写父类的同名属性和方法","keywords":"","body":"1. 子类重写父类的同名属性和方法1. 子类重写父类的同名属性和方法 class Master(object): def __init__(self): self.kongfu = \"古法煎饼果子配方\" def make_cake(self): print(\"[古法] 按照 制作了一份煎饼果子...\" % self.kongfu) class School(object): def __init__(self): self.kongfu = \"现代煎饼果子配方\" def make_cake(self): print(\"[现代] 按照 制作了一份煎饼果子...\" % self.kongfu) class Prentice(School, Master): # 多继承，继承了多个父类 def __init__(self): self.kongfu = \"猫氏煎饼果子配方\" def make_cake(self): print(\"[猫氏] 按照 制作了一份煎饼果子...\" % self.kongfu) # 如果子类和父类的方法名和属性名相同，则默认使用子类的 # 叫 子类重写父类的同名方法和属性 damao = Prentice() print(damao.kongfu) # 子类和父类有同名属性，则默认使用子类的 damao.make_cake() # 子类和父类有同名方法，则默认使用子类的 # 子类的魔法属性__mro__决定了属性和方法的查找顺序 print(Prentice.__mro__) 剧情发展： 大猫的新配方大受欢迎，但是有些顾客希望也能吃到古法配方和 现代配方 的煎饼果子...（子类调用父类的同名属性和方法） Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-27 11:46:30 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Object_oriented_2/子类调用父类同名属性和方法.html":{"url":"Object_oriented_2/子类调用父类同名属性和方法.html","title":"子类调用父类同名属性和方法","keywords":"","body":"1. 子类调用父类同名属性和方法1. 子类调用父类同名属性和方法 class Master(object): def __init__(self): self.kongfu = \"古法煎饼果子配方\" # 实例变量，属性 def make_cake(self): # 实例方法，方法 print(\"[古法] 按照 制作了一份煎饼果子...\" % self.kongfu) class School(object): def __init__(self): self.kongfu = \"现代煎饼果子配方\" def make_cake(self): print(\"[现代] 按照 制作了一份煎饼果子...\" % self.kongfu) class Prentice(School, Master): # 多继承，继承了多个父类 def __init__(self): self.kongfu = \"猫氏煎饼果子配方\" def make_cake(self): print(\"执行子类的__init__方法前，self.kongfu属性：%s\" % self.kongfu) self.__init__() # 执行本类的__init__方法，做属性初始化 self.kongfu = \"猫氏....\" print(\"执行子类的__init__方法前，self.kongfu属性：%s\" % self.kongfu) print(\"[猫氏] 按照 制作了一份煎饼果子...\" % self.kongfu) # 调用父类方法格式：父类类名.父类方法(self) def make_old_cake(self): # 不推荐这样访问父类的实例属性，相当于创建了一个新的父类对象 # print(\"直接调用Master类的kongfu属性：%s\" % Master().kongfu) # 可以通过执行Master类的__init__方法，来修改self的属性值 print(\"执行Master类的__init__方法前，self.kongfu属性：%s\" % self.kongfu) Master.__init__(self) # 调用了父类Master的__init__方法 self.kongfu = \"古法....\" print(\"执行Master类的__init__方法后，self.kongfu属性：%s\" % self.kongfu) Master.make_cake(self) # 调用父类Master的实例方法 def make_new_cake(self): # 不推荐这样访问类的实例属性，相当于创建了一个新的父类对象 # print(\"直接调用School类的kongfu属性：%s\" % School().kongfu) # 可以通过执行School类的__init__方法，来修改self的属性值 print(\"执行School类的__init__方法前，self.kongfu属性：%s\" % self.kongfu) School.__init__(self) # 调用了父类School的__init__方法 self.kongfu = \"现代....\" print(\"执行School类的__init__方法后，self.kongfu属性：%s\" % self.kongfu) School.make_cake(self) # 调用父类School的实例方法 # 实例化对象，自动执行子类的__init__方法 damao = Prentice() damao.make_cake() # 调用子类的方法（默认重写了父类的同名方法） print(\"--\" * 10) damao.make_old_cake() # 进入实例方法去调用父类Master的方法 print(\"--\" * 10) damao.make_new_cake() # 进入实例方法去调用父类School的方法 print(\"--\" * 10) damao.make_cake() # 调用本类的实例方法 执行结果： 执行子类的__init__方法前，self.kongfu属性：猫氏煎饼果子配方 执行子类的__init__方法前，self.kongfu属性：猫氏煎饼果子配方 [猫氏] 按照 制作了一份煎饼果子... -------------------- 执行Master类的__init__方法前，self.kongfu属性：猫氏煎饼果子配方 执行Master类的__init__方法后，self.kongfu属性：古法煎饼果子配方 [古法] 按照 制作了一份煎饼果子... -------------------- 执行School类的__init__方法前，self.kongfu属性：古法煎饼果子配方 执行School类的__init__方法后，self.kongfu属性：现代煎饼果子配方 [现代] 按照 制作了一份煎饼果子... -------------------- 执行子类的__init__方法前，self.kongfu属性：现代煎饼果子配方 执行子类的__init__方法前，self.kongfu属性：猫氏煎饼果子配方 [猫氏] 按照 制作了一份煎饼果子... 核心点： 无论何时何地，self都表示是子类的对象。在调用父类方法时，通过传递self参数，来控制方法和属性的访问修改。 剧情发展： 大猫的煎饼果子店非常红火，终于有一天，他成了世界首富！！ 但是他也老了，所以他希望把 师傅的配方 和 学校的配方 以及自己的配方 继续传承下去...（多层继承） Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-27 11:46:56 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Object_oriented_2/多层继承.html":{"url":"Object_oriented_2/多层继承.html","title":"多层继承","keywords":"","body":"1. 多层继承1. 多层继承 class Master(object): def __init__(self): self.kongfu = \"古法煎饼果子配方\" def make_cake(self): print(\"[古法] 按照 制作了一份煎饼果子...\" % self.kongfu) class School(object): def __init__(self): self.kongfu = \"现代煎饼果子配方\" def make_cake(self): print(\"[现代] 按照 制作了一份煎饼果子...\" % self.kongfu) class Prentice(School, Master): # 多继承，继承了多个父类 def __init__(self): self.kongfu = \"猫氏煎饼果子配方\" self.money = 10000 # 亿美金 def make_cake(self): self.__init__() # 执行本类的__init__方法，做属性初始化 self.kongfu = \"猫氏....\" print(\"[猫氏] 按照 制作了一份煎饼果子...\" % self.kongfu) # 调用父类方法格式：父类类名.父类方法(self) def make_old_cake(self): Master.__init__(self) # 调用了父类Master的__init__方法 self.kongfu = \"古法....\" Master.make_cake(self) # 调用了父类Master的实例方法 def make_new_cake(self): School.__init__(self) # 调用了父类School的__init__方法 self.kongfu = \"现代....\" School.make_cake(self) # 调用父类School的实例方法， class PrenticePrentice(Prentice): # 多层继承 pass pp = PrenticePrentice() pp.make_cake() # 调用父类的实例方法 pp.make_new_cake() pp.make_old_cake() print(pp.money) 剧情发展： 大猫觉得配方传承下去没问题，但是钱是辛辛苦苦挣得血汗钱，不想传给徒弟。（私有权限） Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-27 11:48:07 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Object_oriented_2/通过super来调用父类方法.html":{"url":"Object_oriented_2/通过super来调用父类方法.html","title":"通过super()来调用父类方法","keywords":"","body":"1.1. super()的使用1.1. super()的使用 问题： class Master(object): def __init__(self): self.kongfu = \"古法煎饼果子配方\" # 实例变量，属性 def make_cake(self): # 实例方法，方法 print(\"[古法] 按照 制作了一份煎饼果子...\" % self.kongfu) # 父类是 Master类 class School(Master): def __init__(self): self.kongfu = \"现代煎饼果子配方\" def make_cake(self): print(\"[现代] 按照 制作了一份煎饼果子...\" % self.kongfu) super().__init__() # 执行父类的构造方法 super().make_cake() # 执行父类的实例方法 # 父类是 School 和 Master class Prentice(School, Master): # 多继承，继承了多个父类 def __init__(self): self.kongfu = \"猫氏煎饼果子配方\" def make_cake(self): self.__init__() # 执行本类的__init__方法，做属性初始化 self.kongfu = \"猫氏....\" print(\"[猫氏] 按照 制作了一份煎饼果子...\" % self.kongfu) def make_all_cake(self): # 方式1. 指定执行父类的方法（代码臃肿） # School.__init__(self) # School.make_cake(self) # # Master.__init__(self) # Master.make_cake(self) # # self.__init__() # self.make_cake() # 方法2. super() 带参数版本，只支持新式类 # super(Prentice, self).__init__() # 执行父类的 __init__方法 # super(Prentice, self).make_cake() # self.make_cake() # 方法3. super()的简化版，只支持新式类 super().__init__() # 执行父类的 __init__方法 super().make_cake() # 执行父类的 实例方法 self.make_cake() # 执行本类的实例方法 damao = Prentice() damao.make_cake() damao.make_all_cake() # print(Prentice.__mro__) 知识点： 子类继承了多个父类，如果父类类名修改了，那么子类也要涉及多次修改。而且需要重复写多次调用，显得代码臃肿。 使用super() 可以逐一调用所有的父类方法，并且只执行一次。调用顺序遵循 mro 类属性的顺序。 注意：如果继承了多个父类，且父类都有同名方法，则默认只执行第一个父类的(同名方法只执行一次，目前super()不支持执行多个父类的同名方法) super() 在Python2.3之后才有的机制，用于通常单继承的多层继承。 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-27 11:54:57 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Object_oriented_3/":{"url":"Object_oriented_3/","title":"面向对象基础(三)","keywords":"","body":"1. 面向对象基础(三)1. 面向对象基础(三) Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-27 15:27:52 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Object_oriented_3/私有属性和私有方法.html":{"url":"Object_oriented_3/私有属性和私有方法.html","title":"私有属性和私有方法","keywords":"","body":"1.1. 私有权限1.1.1. 面向对象三大特性：封装、继承、多态1.1. 私有权限 1.1.1. 面向对象三大特性：封装、继承、多态 封装的意义： 将属性和方法放到一起做为一个整体，然后通过实例化对象来处理； 隐藏内部实现细节，只需要和对象及其属性和方法交互就可以了； 对类的属性和方法增加 访问权限控制。 私有权限：在属性名和方法名 前面 加上两个下划线 __ 类的私有属性 和 私有方法，都不能通过对象直接访问，但是可以在本类内部访问； 类的私有属性 和 私有方法，都不会被子类继承，子类也无法访问； 私有属性 和 私有方法 往往用来处理类的内部事情，不通过对象处理，起到安全作用。 class Master(object): def __init__(self): self.kongfu = \"古法煎饼果子配方\" def make_cake(self): print(\"[古法] 按照 制作了一份煎饼果子...\" % self.kongfu) class School(object): def __init__(self): self.kongfu = \"现代煎饼果子配方\" def make_cake(self): print(\"[现代] 按照 制作了一份煎饼果子...\" % self.kongfu) class Prentice(School, Master): def __init__(self): self.kongfu = \"猫氏煎饼果子配方\" # 私有属性，可以在类内部通过self调用，但不能通过对象访问 self.__money = 10000 # 私有方法，可以在类内部通过self调用，但不能通过对象访问 def __print_info(self): print(self.kongfu) print(self.__money) def make_cake(self): self.__init__() print(\"[猫氏] 按照 制作了一份煎饼果子...\" % self.kongfu) def make_old_cake(self): Master.__init__(self) Master.make_cake(self) def make_new_cake(self): School.__init__(self) School.make_cake(self) class PrenticePrentice(Prentice): pass damao = Prentice() # 对象不能访问私有权限的属性和方法 # print(damao.__money) # damao.__print_info() pp = PrenticePrentice() # 子类不能继承父类私有权限的属性和方法 print(pp.__money) pp.__print_info() 总结 Python中没有像C++中 public 和 private 这些关键字来区别公有属性和私有属性。 Python是以属性命名方式来区分，如果在属性和方法名前面加了2个下划线'__'，则表明该属性和方法是私有权限，否则为公有权限。 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-27 15:13:36 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Object_oriented_3/修改私有属性的值.html":{"url":"Object_oriented_3/修改私有属性的值.html","title":"修改私有属性的值","keywords":"","body":"1.1. 修改私有属性的值1.1. 修改私有属性的值 如果需要修改一个对象的属性值，通常有2种方法 对象名.属性名 = 数据 ----> 直接修改 对象名.方法名() ----> 间接修改 私有属性不能直接访问，所以无法通过第一种方式修改，一般的通过第二种方式修改私有属性的值：定义一个可以调用的公有方法，在这个公有方法内访问修改。 class Master(object): def __init__(self): self.kongfu = \"古法煎饼果子配方\" def make_cake(self): print(\"[古法] 按照 制作了一份煎饼果子...\" % self.kongfu) class School(object): def __init__(self): self.kongfu = \"现代煎饼果子配方\" def make_cake(self): print(\"[现代] 按照 制作了一份煎饼果子...\" % self.kongfu) class Prentice(School, Master): def __init__(self): self.kongfu = \"猫氏煎饼果子配方\" # 私有属性，可以在类内部通过self调用，但不能通过对象访问 self.__money = 10000 # 现代软件开发中，通常会定义get_xxx()方法和set_xxx()方法来获取和修改私有属性值。 # 返回私有属性的值 def get_money(self): return self.__money # 接收参数，修改私有属性的值 def set_money(self, num): self.__money = num def make_cake(self): self.__init__() print(\"[猫氏] 按照 制作了一份煎饼果子...\" % self.kongfu) def make_old_cake(self): Master.__init__(self) Master.make_cake(self) def make_new_cake(self): School.__init__(self) School.make_cake(self) class PrenticePrentice(Prentice): pass damao = Prentice() # 对象不能访问私有权限的属性和方法 # print(damao.__money) # damao.__print_info() # 可以通过访问公有方法set_money()来修改私有属性的值 damao.set_money(100) # 可以通过访问公有方法get_money()来获取私有属性的值 print(damao.get_money()) Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-27 15:20:19 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Object_oriented_3/多态.html":{"url":"Object_oriented_3/多态.html","title":"多态","keywords":"","body":"1. 多态1. 多态 所谓多态：定义时的类型和运行时的类型不一样，此时就成为多态 ，多态的概念是应用于Java和C#这一类强类型语言中，而Python崇尚“鸭子类型”。 鸭子类型：虽然我想要一只\"鸭子\"，但是你给了我一只鸟。 但是只要这只鸟走路像鸭子，叫起来像鸭子，游泳也像鸭子，我就认为这是鸭子。 Python的多态，就是弱化类型，重点在于对象参数是否有指定的属性和方法，如果有就认定合适，而不关心对象的类型是否正确。 Python伪代码实现Java或C#的多态 class F1(object): def show(self): print('F1.show') class S1(F1): def show(self): print('S1.show') class S2(F1): def show(self): print('S2.show') # 由于在Java或C#中定义函数参数时，必须指定参数的类型 # 为了让Func函数既可以执行S1对象的show方法，又可以执行S2对象的show方法， # 所以在def Func的形参中obj的类型是 S1和S2的父类即F1 # # 而实际传入的参数是：S1对象和S2对象 def Func(F1 obj): \"\"\"Func函数需要接收一个F1类型或者F1子类的类型\"\"\" print(obj.show()) s1_obj = S1() Func(s1_obj) # 在Func函数中传入S1类的对象 s1_obj，执行 S1 的show方法，结果：S1.show s2_obj = S2() Func(s2_obj) # 在Func函数中传入Ss类的对象 ss_obj，执行 Ss 的show方法，结果：S2.show 通俗点理解：定义obj这个变量是说的类型是：F1的类型，但是在真正调用Func函数时给其传递的不一定是F1类的实例对象，有可能是其子类的实例对象， 这种情况就是所谓的多态 Python “鸭子类型” class F1(object): def show(self): print('F1.show') class S1(F1): def show(self): print('S1.show') class S2(F1): def show(self): print('S2.show') def Func(obj): # python是弱类型，即无论传递过来的是什么，obj变量都能够指向它，这也就没有所谓的多态了（弱化了这个概念） print(obj.show()) s1_obj = S1() Func(s1_obj) s2_obj = S2() Func(s2_obj) Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-27 15:20:40 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Object_oriented_3/类属性和实例属性.html":{"url":"Object_oriented_3/类属性和实例属性.html","title":"类属性和实例属性","keywords":"","body":"1.1. 类属性和实例属性1.1.1. 类属性1.1.2. 实例属性(对象属性)1.1.3. 通过实例(对象)去修改类属性1.1.4. 总结1.1. 类属性和实例属性 在了解了类基本的东西之后，下面看一下python中这几个概念的区别 先来谈一下类属性和实例属性 在前面的例子中我们接触到的就是实例属性（对象属性），顾名思义，类属性就是类对象所拥有的属性，它被所有类对象的实例对象所共有，在内存中只存在一个副本，这个和C++中类的静态成员变量有点类似。对于公有的类属性，在类外可以通过类对象和实例对象访问 1.1.1. 类属性 class People(object): name = 'Tom' # 公有的类属性 __age = 12 # 私有的类属性 p = People() print(p.name) # 正确 print(People.name) # 正确 print(p.__age) # 错误，不能在类外通过实例对象访问私有的类属性 print(People.__age) # 错误，不能在类外通过类对象访问私有的类属性 1.1.2. 实例属性(对象属性) class People(object): address = '山东' # 类属性 def __init__(self): self.name = 'xiaowang' # 实例属性 self.age = 20 # 实例属性 p = People() p.age = 12 # 实例属性 print(p.address) # 正确 print(p.name) # 正确 print(p.age) # 正确 print(People.address) # 正确 print(People.name) # 错误 print(People.age) # 错误 1.1.3. 通过实例(对象)去修改类属性 class People(object): country = 'china' #类属性 print(People.country) p = People() print(p.country) p.country = 'japan' print(p.country) # 实例属性会屏蔽掉同名的类属性 print(People.country) del p.country # 删除实例属性 print(p.country) 1.1.4. 总结 如果需要在类外修改类属性，必须通过类对象去引用然后进行修改。如果通过实例对象去引用，会产生一个同名的实例属性，这种方式修改的是实例属性，不会影响到类属性，并且之后如果通过实例对象去引用该名称的属性，实例属性会强制屏蔽掉类属性，即引用的是实例属性，除非删除了该实例属性。 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-27 15:20:59 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Object_oriented_3/类方法和静态方法.html":{"url":"Object_oriented_3/类方法和静态方法.html","title":"类方法和静态方法","keywords":"","body":"1. 类方法和静态方法1.1. 1. 类方法1.2. 2. 静态方法1.3. 总结1. 类方法和静态方法 1.1. 1. 类方法 是类对象所拥有的方法，需要用修饰器@classmethod来标识其为类方法，对于类方法，第一个参数必须是类对象，一般以cls作为第一个参数（当然可以用其他名称的变量作为其第一个参数，但是大部分人都习惯以'cls'作为第一个参数的名字，就最好用'cls'了），能够通过实例对象和类对象去访问。 class People(object): # 私有类属性 __country = 'china' #类方法，用classmethod来进行修饰 @classmethod def get_country(cls): return cls.__country p = People() print(p.get_country()) #可以用过实例对象引用 print(People.get_country()) #可以通过类对象引用 类方法还有一个用途就是可以对类属性进行修改： class People(object): # 私有类属性 __country = 'china' #类方法，用classmethod来进行修饰 @classmethod def get_country(cls): return cls.__country @classmethod def set_country(cls,country): cls.__country = country p = People() print(p.get_country()) #可以用过实例对象访问 print(People.get_country()) #可以通过类访问 p.set_country('japan') print(p.get_country()) print(People.get_country()) 结果显示在用类方法对类属性修改之后，通过类对象和实例对象访问都发生了改变 1.2. 2. 静态方法 需要通过修饰器@staticmethod来进行修饰，静态方法不需要多定义参数，可以通过对象和类来访问。 class People(object): country = 'china' @staticmethod #静态方法 def get_country(): return People.country p = People() # 通过对象访问静态方法 p.get_contry() # 通过类访问静态方法 print(People.get_country()) 1.3. 总结 从类方法和实例方法以及静态方法的定义形式就可以看出来，类方法的第一个参数是类对象cls，那么通过cls引用的必定是类对象的属性和方法； 实例方法的第一个参数是实例对象self，那么通过self引用的可能是类属性、也有可能是实例属性（这个需要具体分析），不过在存在相同名称的类属性和实例属性的情况下，实例属性优先级更高。 静态方法中不需要额外定义参数，因此在静态方法中引用类属性的话，必须通过类实例对象来引用 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-27 15:21:41 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Object_oriented_3/__new__方法.html":{"url":"Object_oriented_3/__new__方法.html","title":"new()方法","keywords":"","body":"1.1. __new__方法1.1.1. __new__和__init__的作用1.1.2. 注意点1.1. __new__方法 1.1.1. __new__和__init__的作用 class A(object): def __init__(self): print(\"这是 init 方法\") def __new__(cls): print(\"这是 new 方法\") return object.__new__(cls) A() 总结 __new__至少要有一个参数cls，代表要实例化的类，此参数在实例化时由Python解释器自动提供 __new__必须要有返回值，返回实例化出来的实例，这点在自己实现__new__时要特别注意，可以return父类__new__出来的实例，或者直接是object的__new__出来的实例 __init__有一个参数self，就是这个__new__返回的实例，__init__在__new__的基础上可以完成一些其它初始化的动作，__init__不需要返回值 我们可以将类比作制造商，__new__方法就是前期的原材料购买环节，__init__方法就是在有原材料的基础上，加工，初始化商品环节 1.1.2. 注意点 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-27 15:22:44 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Object_oriented_3/设计模式：单例模式.html":{"url":"Object_oriented_3/设计模式：单例模式.html","title":"设计模式：单例模式","keywords":"","body":"1.1. 单例模式1.1.1. 1. 单例是什么1.1.2. 2. 创建单例-保证只有1个对象1.1.3. 3. 创建单例时，只执行1次init方法1.1. 单例模式 1.1.1. 1. 单例是什么 举个常见的单例模式例子，我们日常使用的电脑上都有一个回收站，在整个操作系统中，回收站只能有一个实例，整个系统都使用这个唯一的实例，而且回收站自行提供自己的实例。因此回收站是单例模式的应用。 确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，单例模式是一种对象创建型模式。 1.1.2. 2. 创建单例-保证只有1个对象 # 实例化一个单例 class Singleton(object): __instance = None def __new__(cls, age, name): #如果类属性__instance的值为None， #那么就创建一个对象，并且赋值为这个对象的引用，保证下次调用这个方法时 #能够知道之前已经创建过对象了，这样就保证了只有1个对象 if not cls.__instance: cls.__instance = object.__new__(cls) return cls.__instance a = Singleton(18, \"dongGe\") b = Singleton(8, \"dongGe\") print(id(a)) print(id(b)) a.age = 19 #给a指向的对象添加一个属性 print(b.age)#获取b指向的对象的age属性 运行结果： In [12]: class Singleton(object): ...: __instance = None ...: ...: def __new__(cls, age, name): ...: if not cls.__instance: ...: cls.__instance = object.__new__(cls) ...: return cls.__instance ...: ...: a = Singleton(18, \"dongGe\") ...: b = Singleton(8, \"dongGe\") ...: ...: print(id(a)) ...: print(id(b)) ...: ...: a.age = 19 ...: print(b.age) ...: 4391023224 4391023224 19 1.1.3. 3. 创建单例时，只执行1次init方法 # 实例化一个单例 class Singleton(object): __instance = None __is_first = True def __new__(cls, age, name): if not cls.__instance: cls.__instance = object.__new__(cls) return cls.__instance def __init__(self, age, name): if self. __is_first: self.age = age self.name = name Singleton. __is_first = False a = Singleton(18, \"习大大\") b = Singleton(28, \"习大大\") print(id(a)) print(id(b)) print(a.age) print(b.age) a.age = 19 print(b.age) 运行结果: Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-27 15:24:32 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"unusual/":{"url":"unusual/","title":"异常、模块","keywords":"","body":"1. 异常、模块1. 异常、模块 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-27 16:12:42 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"unusual/异常介绍.html":{"url":"unusual/异常介绍.html","title":"异常介绍","keywords":"","body":"1. 异常1.1. 异常简介1. 异常 1.1. 异常简介 看如下示例: print '-----test--1---' open('123.txt','r') print '-----test--2---' 运行结果: 说明: 打开一个不存在的文件123.txt，当找不到123.txt 文件时，就会抛出给我们一个IOError类型的错误，No such file or directory：123.txt （没有123.txt这样的文件或目录） 异常: 当Python检测到一个错误时，解释器就无法继续执行了，反而出现了一些错误的提示，这就是所谓的\"异常\" Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-27 15:54:20 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"unusual/捕获异常.html":{"url":"unusual/捕获异常.html","title":"捕获异常","keywords":"","body":"1. 案例剖析1.1. 捕获异常 try...except...1.2. except捕获多个异常1.2.1. 注意：1.3. 获取异常的信息描述1.4. 捕获所有异常1.5. else1.6. try...finally...1. 案例剖析 1.1. 捕获异常 try...except... 看如下示例: try: print('-----test--1---') open('123.txt','r') print('-----test--2---') except IOError: pass 运行结果: -----test--1--- 说明: 此程序看不到任何错误，因为用except 捕获到了IOError异常，并添加了处理的方法 pass 表示实现了相应的实现，但什么也不做；如果把pass改为print语句，那么就会输出其他信息 小总结: 把可能出现问题的代码，放在try中 把处理异常的代码，放在except中 1.2. except捕获多个异常 看如下示例: try: print num except IOError: print('产生错误了') 运行结果如下: File \"/Users/jiazhixiang/doc/spider/wechat/2.py\", line 2 print num ^ SyntaxError: Missing parentheses in call to 'print'. Did you mean print(num)? 想一想: 上例程序，已经使用except来捕获异常了，为什么还会看到错误的信息提示？ 答: except捕获的错误类型是IOError，而此时程序产生的异常为 NameError ，所以except没有生效 修改后的代码为: try: print num except NameError: print('产生错误了;') 运行结果如下: 产生错误了; 实际开发中，捕获多个异常的方式，如下： #coding=utf-8 try: print('-----test--1---') open('123.txt','r') # 如果123.txt文件不存在，那么会产生 IOError 异常 print('-----test--2---') print(num)# 如果num变量没有定义，那么会产生 NameError 异常 except (IOError,NameError): #如果想通过一次except捕获到多个异常可以用一个元组的方式 1.2.1. 注意： 当捕获多个异常时，可以把要捕获的异常的名字，放到except 后，并使用元组的方式仅进行存储 1.3. 获取异常的信息描述 1.4. 捕获所有异常 1.5. else 咱们应该对else并不陌生，在if中，它的作用是当条件不满足时执行的实行；同样在try...except...中也是如此，即如果没有捕获到异常，那么就执行else中的事情 try: num = 100 print num except NameError as errorMsg: print('产生错误了:%s'%errorMsg) else: print('没有捕获到异常，真高兴') 运行结果如下: 1.6. try...finally... try...finally...语句用来表达这样的情况： 在程序中，如果一个段代码必须要执行，即无论异常是否产生都要执行，那么此时就需要使用finally。 比如文件关闭，释放锁，把数据库连接返还给连接池等 demo: import time try: f = open('test.txt') try: while True: content = f.readline() if len(content) == 0: break time.sleep(2) print(content) except: #如果在读取文件的过程中，产生了异常，那么就会捕获到 #比如 按下了 ctrl+c pass finally: f.close() print('关闭文件') except: print(\"没有这个文件\") 说明: test.txt文件中每一行数据打印，但是我有意在每打印一行之前用time.sleep方法暂停2秒钟。这样做的原因是让程序运行得慢一些。在程序运行的时候，按Ctrl+c中断（取消）程序。 我们可以观察到KeyboardInterrupt异常被触发，程序退出。但是在程序退出之前，finally从句仍然被执行，把文件关闭。 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-27 16:00:29 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"unusual/异常的传递.html":{"url":"unusual/异常的传递.html","title":"异常的传递","keywords":"","body":"1. 异常的传递1.1. 1. try嵌套中1.2. 2. 函数嵌套调用中1. 异常的传递 1.1. 1. try嵌套中 import time try: f = open('test.txt') try: while True: content = f.readline() if len(content) == 0: break time.sleep(2) print(content) finally: f.close() print('关闭文件') except: print(\"没有这个文件\") 运行结果: In [26]: import time ...: try: ...: f = open('test.txt') ...: try: ...: while True: ...: content = f.readline() ...: if len(content) == 0: ...: break ...: time.sleep(2) ...: print(content) ...: finally: ...: f.close() ...: print('关闭文件') ...: except: ...: print(\"没有这个文件\") ...: finally: ...: print(\"最后的finally\") ...: xxxxxxx--->这是test.txt文件中读取到信息 ^C关闭文件 没有这个文件 最后的finally 1.2. 2. 函数嵌套调用中 def test1(): print(\"----test1-1----\") print(num) print(\"----test1-2----\") def test2(): print(\"----test2-1----\") test1() print(\"----test2-2----\") def test3(): try: print(\"----test3-1----\") test1() print(\"----test3-2----\") except Exception as result: print(\"捕获到了异常，信息是:%s\"%result) print(\"----test3-2----\") test3() print(\"------华丽的分割线-----\") test2() 运行结果: 总结： 如果try嵌套，那么如果里面的try没有捕获到这个异常，那么外面的try会接收到这个异常，然后进行处理，如果外边的try依然没有捕获到，那么再进行传递。。。 如果一个异常是在一个函数中产生的，例如函数A---->函数B---->函数C,而异常是在函数C中产生的，那么如果函数C中没有对这个异常进行处理，那么这个异常会传递到函数B中，如果函数B有异常处理那么就会按照函数B的处理方式进行执行；如果函数B也没有异常处理，那么这个异常会继续传递，以此类推。。。如果所有的函数都没有处理，那么此时就会进行异常的默认处理，即通常见到的那样 注意观察上图中，当调用test3函数时，在test1函数内部产生了异常，此异常被传递到test3函数中完成了异常处理，而当异常处理完后，并没有返回到函数test1中进行执行，而是在函数test3中继续执行 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-27 16:01:12 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"unusual/抛出自定义的异常.html":{"url":"unusual/抛出自定义的异常.html","title":"抛出自定义的异常","keywords":"","body":"1. 抛出自定义的异常1.1.1. 注意1. 抛出自定义的异常 你可以用raise语句来引发一个异常。异常/错误对象必须有一个名字，且它们应是Error或Exception类的子类 下面是一个引发异常的例子: class ShortInputException(Exception): '''自定义的异常类''' def __init__(self, length, atleast): #super().__init__() self.length = length self.atleast = atleast def main(): try: s = input('请输入 --> ') if len(s) 运行结果如下: 1.1.1. 注意 以上程序中，关于代码 #super().__init__() 的说明 这一行代码，可以调用也可以不调用，建议调用，因为__init__方法往往是用来对创建完的对象进行初始化工作，如果在子类中重写了父类的__init__方法，即意味着父类中的很多初始化工作没有做，这样就不保证程序的稳定了，所以在以后的开发中，如果重写了父类的__init__方法，最好是先调用父类的这个方法，然后再添加自己的功能 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-27 16:01:51 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"unusual/异常处理中抛出异常.html":{"url":"unusual/异常处理中抛出异常.html","title":"异常处理中抛出异常","keywords":"","body":"1. 异常处理中抛出异常1. 异常处理中抛出异常 class Test(object): def __init__(self, switch): self.switch = switch #开关 def calc(self, a, b): try: return a/b except Exception as result: if self.switch: print(\"捕获开启，已经捕获到了异常，信息如下:\") print(result) else: #重新抛出这个异常，此时就不会被这个异常处理给捕获到，从而触发默认的异常处理 raise a = Test(True) a.calc(11,0) print(\"----------------------华丽的分割线----------------\") a.switch = False a.calc(11,0) 运行结果: Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-27 16:02:31 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"unusual/模块介绍.html":{"url":"unusual/模块介绍.html","title":"模块介绍","keywords":"","body":"1. 模块1.1. Python中的模块1.2. import1.3. from…import1.3.1. 注意1.4. from … import *1.4.1. 注意1.5. as1.6. 定位模块1. 模块 1.1. Python中的模块 有过C语言编程经验的朋友都知道在C语言中如果要引用sqrt函数，必须用语句#include引入math.h这个头文件，否则是无法正常进行调用的。 那么在Python中，如果要引用一些其他的函数，该怎么处理呢？ 在Python中有一个概念叫做模块（module），这个和C语言中的头文件以及Java中的包很类似，比如在Python中要调用sqrt函数，必须用import关键字引入math这个模块，下面就来了解一下Python中的模块。 说的通俗点：模块就好比是工具包，要想使用这个工具包中的工具(就好比函数)，就需要导入这个模块 1.2. import 在Python中用关键字import来引入某个模块，比如要引用模块math，就可以在文件最开始的地方用import math来引入。 形如: import module1,mudule2... 当解释器遇到import语句，如果模块在当前的搜索路径就会被导入。 在调用math模块中的函数时，必须这样引用： 　　模块名.函数名 想一想: 为什么必须加上模块名调用呢？ 答: 因为可能存在这样一种情况：在多个模块中含有相同名称的函数，此时如果只是通过函数名来调用，解释器无法知道到底要调用哪个函数。所以如果像上述这样引入模块的时候，调用函数必须加上模块名 import math #这样会报错 print sqrt(2) #这样才能正确输出结果 print math.sqrt(2) 有时候我们只需要用到模块中的某个函数，只需要引入该函数即可，此时可以用下面方法实现： from 模块名 import 函数名1,函数名2.... 不仅可以引入函数，还可以引入一些全局变量、类等 注意: 通过这种方式引入的时候，调用函数时只能给出函数名，不能给出模块名，但是当两个模块中含有相同名称函数的时候，后面一次引入会覆盖前一次引入。也就是说假如模块A中有函数function( )，在模块B中也有函数function( )，如果引入A中的function在先、B中的function在后，那么当调用function函数的时候，是去执行模块B中的function函数。 如果想一次性引入math中所有的东西，还可以通过from math import *来实现 1.3. from…import Python的from语句让你从模块中导入一个指定的部分到当前命名空间中 语法如下： from modname import name1[, name2[, ... nameN]] 例如，要导入模块fib的fibonacci函数，使用如下语句： from fib import fibonacci 1.3.1. 注意 不会把整个fib模块导入到当前的命名空间中，它只会将fib里的fibonacci单个引入 1.4. from … import * 把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明： from modname import * 1.4.1. 注意 这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。 1.5. as In [1]: import time as tt In [2]: time.sleep(1) --------------------------------------------------------------------------- NameError Traceback (most recent call last) in () ----> 1 time.sleep(1) NameError: name 'time' is not defined In [3]: In [3]: In [3]: tt.sleep(1) In [4]: In [4]: In [4]: from time import sleep as sp In [5]: sleep(1) --------------------------------------------------------------------------- NameError Traceback (most recent call last) in () ----> 1 sleep(1) NameError: name 'sleep' is not defined In [6]: In [6]: In [6]: sp(1) In [7]: 1.6. 定位模块 当你导入一个模块，Python解析器对模块位置的搜索顺序是： 当前目录 如果不在当前目录，Python则搜索在shell变量PYTHONPATH下的每个目录。 如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/ 模块搜索路径存储在system模块的sys.path变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-27 16:02:53 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"unusual/模块制作.html":{"url":"unusual/模块制作.html","title":"模块制作","keywords":"","body":"1. 模块制作1.1. 定义自己的模块1.2. 调用自己定义的模块1.3. 测试模块1.3.1. 直接运行此文件1.3.2. 在其他文件中import此文件1. 模块制作 1.1. 定义自己的模块 在Python中，每个Python文件都可以作为一个模块，模块的名字就是文件的名字。 比如有这样一个文件test.py，在test.py中定义了函数add test.py def add(a,b): return a+b 1.2. 调用自己定义的模块 那么在其他文件中就可以先import test，然后通过test.add(a,b)来调用了，当然也可以通过from test import add来引入 main.py import test result = test.add(11,22) print(result) 1.3. 测试模块 在实际开中，当一个开发人员编写完一个模块后，为了让模块能够在项目中达到想要的效果，这个开发人员会自行在py文件中添加一些测试信息，例如： test.py def add(a,b): return a+b # 用来进行测试 ret = add(12,22) print('int test.py file,,,,12+22=%d'%ret) 如果此时，在其他py文件中引入了此文件的话，想想看，测试的那段代码是否也会执行呢！ main.py import test result = test.add(11,22) print(result) 运行现象： 至此，可发现test.py中的测试代码，应该是单独执行test.py文件时才应该执行的，不应该是其他的文件中引用而执行 为了解决这个问题，python在执行一个文件时有个变量__name__ 1.3.1. 直接运行此文件 1.3.2. 在其他文件中import此文件 总结： 可以根据name变量的结果能够判断出，是直接执行的python脚本还是被引入执行的，从而能够有选择性的执行测试代码 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-27 16:04:04 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"unusual/模块中的__all__.html":{"url":"unusual/模块中的__all__.html","title":"模块中的all","keywords":"","body":"1. 模块中的__all__1.1. 1. 没有__all__1.2. 2. 模块中有__all__1.2.1. 总结1. 模块中的__all__ 1.1. 1. 没有__all__ 1.2. 2. 模块中有__all__ 1.2.1. 总结 如果一个文件中有all变量，那么也就意味着这个变量中的元素，不会被from xxx import *时导入 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-27 16:05:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"unusual/python中的包.html":{"url":"unusual/python中的包.html","title":"python中的包","keywords":"","body":"1. python中的包1.1. 1. 引入包1.1.1. 1.1 有2个模块功能有些联系1.1.2. 1.2 所以将其放到同一个文件夹下1.1.3. 1.3 使用import 文件.模块 的方式导入1.1.4. 1.4 使用from 文件夹 import 模块 的方式导入1.1.5. 1.5 在msg文件夹下创建__init__.py文件1.1.6. 1.6 在__init__.py文件中写入1.1.7. 1.7 重新使用from 文件夹 import 模块 的方式导入1.2. 总结：1.3. 2. __init__.py文件有什么用1.3.1. 2.1 __init__.py为空1.3.2. 2.2 __all__1.3.3. 2.3 可以在__init__.py文件中编写内容1.3.4. 2.4 可以控制导入其他模块1. python中的包 1.1. 1. 引入包 1.1.1. 1.1 有2个模块功能有些联系 1.1.2. 1.2 所以将其放到同一个文件夹下 1.1.3. 1.3 使用import 文件.模块 的方式导入 1.1.4. 1.4 使用from 文件夹 import 模块 的方式导入 1.1.5. 1.5 在msg文件夹下创建__init__.py文件 1.1.6. 1.6 在__init__.py文件中写入 1.1.7. 1.7 重新使用from 文件夹 import 模块 的方式导入 1.2. 总结： 包将有联系的模块组织在一起，即放到同一个文件夹下，并且在这个文件夹创建一个名字为__init__.py 文件，那么这个文件夹就称之为包 有效避免模块名称冲突问题，让应用组织结构更加清晰 1.3. 2. __init__.py文件有什么用 __init__.py 控制着包的导入行为 1.3.1. 2.1 __init__.py为空 仅仅是把这个包导入，不会导入包中的模块 1.3.2. 2.2 __all__ 在__init__.py文件中，定义一个__all__变量，它控制着 from 包名 import *时导入的模块 1.3.3. 2.3 可以在__init__.py文件中编写内容 可以在这个文件中编写语句，当导入时，这些语句就会被执行 __init__.py文件 1.3.4. 2.4 可以控制导入其他模块 目录结构 sendmsg.py 和 recvmsg.py文件中的内容 python2导入失败 python3导入成功，但是不能使用模块 在文件夹下创建一个文件 python2导入成功，但不能使用 python3导入成功，但不能使用 解决python2不能使用的方式 python2的解放方式对python3不生效 解决python3不能使用的方式 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-27 16:10:21 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"第1课/python-数据分析第一课.html":{"url":"第1课/python-数据分析第一课.html","title":"Pandas数据结构和数据的创建","keywords":"","body":"1.1. 第1章 运筹帷幄，决胜千里1.1.1. 课程介绍1.1.2. 新时代的石油1.1.3. 关羽的青龙偃月刀1.1.4. Pandas简介1.1.5. Pandas的数据结构1.1.6. Series的创建1.1.7. DataFrame的创建1.1.8. 本节总结1.1.9. 下节预告1.1.10. 练习1.1.11. 练习21.1. 第1章 运筹帷幄，决胜千里 1.1.1. 课程介绍 Hi！初次见面，我是你在开课吧的课程导师，大家可以叫我小K，从现在开始我们将一起学习Python数据分析之路，在这条路上你会有导师小K的一路陪伴！请敲回车键继续学习٩(๑❛ᴗ❛๑)۶ 为了让你能不受干扰的在学习数据分析路上饱览胜景，请将屏幕调整成全屏，Windows系统：请按F11（或Fn+F11)；苹果系统：请同时按control+command+F。 操作好了吗？现在一切就绪，我们可以准备启程！ 1.1.2. 新时代的石油 随着全球经济数字化转型的发展，各行各业都积累了大量的数据。具有从大数据分析及数据科学中获取独特见解的公司，可以拥有关键信息优势，从而在第四次工业革命（也称为数字时代）中蓬勃发展。 数据分析最重要的作用就像是古代军师，掌握敌我双方的粮草、兵马、路程、天气等等因素的数据，再进行统计分析，从而得出什么时间什么地点用什么策略，这样就可以运筹帷幄之中，决胜千里之外。 第一次听见数据分析这个词时，感觉它就像我们心中的女神，只可远观不可亵玩。此言差矣，其实数据分析早已存在于我们的工作和生活中了。 公司中的HR，通过分析员工的打卡数据，可以重新制定考核制度。 每个月还信用卡的时候，我们是不是要看一下，那么多的血都流到哪里，心里暗暗发誓，以后一些没必要的血就不要流了。 你喜欢上一个姑娘，你会搜集她的兴趣、爱好、星座、闺蜜、乃至三围等等各种信息吧，然后想自己怎么能搭讪上、约出来，碰壁了会继续找原因、想办法，这里面你都有在做数据分析呢。 总之，从数据里面寻求真正有价值的信息，并对实际的工作或者生活有一定的指导作用，这个过程就叫数据分析。 1.1.3. 关羽的青龙偃月刀 可以做数据分析的语言有很多，我们为什么要学习Python数据分析？ 掌握一门编程语言有时候可以让你更加高效的处理几十万甚至上亿条数据。 Python目前已经成为数据科学领域最为重要的编程语言，几乎所有的公司在进行数据分析师招聘的时候都对Python有明确的要求。 Python的应用领域非常广，例如爬虫、自动化报表、网页制作以及分析以后进一步进行数据挖掘等。 社区则提供了丰富的第三方数据分析工具包，Pandas、Numpy、Matplotlib、Seaborn等，可以让我们的数据分析更加轻松。 Python提供了非常丰富的数据分析的工具，我们可以利用这些工具完成数据分析流程的前五步： Pandas 是Python最重要的数据分析工具包，是Panel Data Analysis 的缩写，也是目前最为流行的Python数据分析工具。最初被作为金融数据分析工具由全球资产管理公司AQR于2008年4月开发，并于2009年底开源出来。 Matplotlib和Seaborn是最为常用的数据可视化的工具包，解决如何通过数据来绘制图表，来更好的展示数据。 NumPy 是一个用于数值运算的Python库，专门对数值运算进行优化，最大的优势是快。Pandas底层数据结构采用NumPy来实现，我们也可以把Pandas理解成是对NumPy的封装，让数据分析的一些功能的实现变得更容易。 在接下来的课程中我将着重讲解这几个工具包在数据分析的使用。 章节 章节名 知识点 第一章 运筹帷幄，决胜千里 Pandas数据结构和数据的创建 第二章 太乙真人的奇珍异宝 Series和DataFrame的属性和方法 第三章 再见Excel，你好Pandas！ 数据的写入和数据的读取 工欲善其事必先利其器，各位武林豪杰是否已经了解了武林规则，在线编辑器的使用？ A：还没有了解 B：已经了解了 选A 的回答 认识一下在线编辑器，这是一个由开课吧编程创建，能够“边学边武”的独门武器。 此在线编辑器分为左右两部分。左边的框叫做代码框（后面课程中用此名字），我们往里面输入对计算机的指令：也就是代码，其实它就是程序员的工作台；右边的框我们叫它终端（后面课程中用此名字），它是显示您代码运行结果的地方，也就是用户看到的屏幕。 在后续的教学中，我们会把他们称为【代码框】和【终端】，记得千万不要弄混哦~ 小K会一直陪伴您，为您答疑解惑，另外我们学习群里的众多谋士也会相互扶持。 选B的回答 好，那我们正式开始学习。 人生没有如果，任尔东西南北风，认识数据是运筹帷幄的第一步。 1.1.4. Pandas简介 Pandas 是基于NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。Pandas 纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的工具。Pandas提供了大量能使我们快速便捷地处理数据的函数和方法。 了解了Pandas的基本概念，再看一下Pandas在数据分析方面有哪些作用呢？ Pandas提供的数据结构和函数的设计，将使表格化数据的工作快速、简单、有表现力。所以利用Pandas进行数据操作、预处理、清洗是Python数据分析中的重要技能。 1.1.5. Pandas的数据结构 常见的数据存储形式有Excel和数据库这两种，他们的存储有什么共同点呢？ 不管是Excel还是数据库他们存储数据的方式都是以表格样式进行存储，有行、有列，并且每一行和每一列都有自己的索引，例如：name，age等这些就是列索引，可以方便我们获取数据。 不难看出每一行的数据其实就是我们存储的一条数据信息。 巧了，Pandas的DataFrame的结构就和他们相同，Series的结构和表中的行的结构相同。 在下面的代码框中，我们使用代码创建出一套英雄团队。点击运行按钮，检查你的成果。 # 导入pandas模块 import pandas as pd #通过Series存储每个英雄的基本信息 #创建Series s1 = pd.Series([1001,'鲁班','18','150.00','男']) s2 = pd.Series([1002,'小乔','19','167.00','女']) s3 = pd.Series([1003,'关羽','30','180.00','男']) s4 = pd.Series([1004,'蔡文姬','20','160.00','女']) s5 = pd.Series([1005,'兰陵王','22','165.00','男']) series_list=[s1,s2,s3,s4,s5] #创建一个DataFrame对象存储通讯录 df=pd.DataFrame(series_list) # 打印刚刚构造的DataFrame print(df) 我们根据df的打印结果进一步解析DataFrame的结构。 整个数据被分为三部分：行索引（index），列索引（columns）及数据内容（data）。 行、列索引的值在没有自定义的时候，会被默认设置上0-N的值，索引的作用就是为了更好的认知和查询数据。 通过上面的数据，可以看出每一列数据都是同种类型的数据，如果每一列设定一个有意义的名字，操作的时候就会更加方便。 1.1.6. Series的创建 Series是Pandas中最基本的对象，Series类似一种一维数组。事实上，Series 基本上就是基于 NumPy 的数组对象来的。和 NumPy 的数组不同，Series 能为数据自定义标签，也就是索引（index），然后通过索引来访问数组中的数据。 接下来我们开始创建Series，看看一看它的结构有什么不同。 此处是代码 ————————————— ——————————— 终端 # 导入Series from pandas import Series,DataFrame # 创建Series，使用默认索引 sel = Series(data=[1,'TheShy',20,'天不生theshy，LPL上单万古如长夜']) print(sel) 一个Series其实就是一条数据，Series方法的第一个参数是data，第二个参数是index(索引)，如果没有传值会使用默认值（0-N）。 接下来我们来自定义一下我们的索引。 此处是代码 ————————————— ——————————— 终端 # 导入Series from pandas import Series,DataFrame # 创建Series，使用默认索引 sel = Series(data=[1,'TheShy',20,'天不生theshy，Lpl上单万古如长夜'], index = ['排名','ID号','年龄','评语']) print(sel) index参数是我们自定义的索引值，注意：参数值的个数一定要相同。 在创建Series时数据并不一定要是列表，也可以将一个字典传进去。 此处是代码 ————————————— ——————————— 终端 from pandas import Series,DataFrame # 将字典转换为Series dic={\"red\":100,\"black\":400,\"green\":300,\"pink\":900} se2=Series(data=dic) print(se2) 当数据是字典的时候，会将字典的键作为索引，字典的值作为索引对应的数据值。 综上可以看出，Series是一组带索引数组，与list相似，一般我们用其承装一条数据或者一行数据。多个Series可组成一个DataFrame。 1.1.7. DataFrame的创建 DataFrame（数据表）是一种 2 维数据结构，数据以表格的形式存储，分成若干行和列。通过 DataFrame，你能很方便地处理数据。 调用DataFrame()可以将多种格式的数据转换为DataFrame对象，它的的三个参数data、index和columns分别为数据、行索引和列索引。 DataFrame的数据结构类似Excel或者SQL中表，现在请Pandas帮忙创建出一套英雄联盟王者之师。 此处是代码 ————————————— ——————————— 终端 from pandas import Series,DataFrame # 创建二维列表存储选手信息 lol_list = [['上单','TheShy',20], ['打野','小天',19], ['中单','Faker',23], ['ADC','Uzi',22], ['辅助','Ming',21]] # 创建dataframe df = DataFrame(data=lol_list) print(df) 好了，您已经成功的创建出一个英雄联盟王者之师，我们再来一起阅读下这段代码。 lol_list是使用一个二维列表，将每一个队员的信息存储到一个列表中。 调用DataFrame()将二维列表转换为DataFrame对象，行列索引使用的是默认0-N数字代表。 有没有办法在创建DataFrame对象的时候为每一列设定一个有意义的名字呢？ 我们可以通过给DataFrame构造函数中的参数index,columns传值，来设定DataFrame的中的行列索引的值。 此处是代码 ————————————— ——————————— 终端 from pandas import Series,DataFrame # 创建二维列表存储选手信息 lol_list = [['上单','TheShy',20], ['打野','小天',19], ['中单','Faker',23], ['ADC','Uzi',22], ['辅助','Ming',21]] # 创建dataframe df = DataFrame(data=lol_list, index=['a','b','c','d','e'], columns=['位置','ID号','年龄']) print(df) 从这段程序的运行结果中，我们可以看到每一列或者每一行都有了一个名字。 当然我们也可以使用字典来创建一个DataFrame数据。 此处是代码 ————————————— ——————————— 终端 from pandas import Series,DataFrame import pandas as pd # 使用字典创建 dic={ '位置': ['上单', '打野', '中单', 'ADC','辅助'], 'ID号': ['TheShy', '小天', 'Faker', 'Uzi', 'Ming'], 'year': [20, 19, 23, 22,21]} df=pd.DataFrame(dic) print(df) 通过结果可以看出当字典格式的数据被dataframe整理后，字典的键将作为数据的列索引值。 通过 DataFrame，你能很方便地处理数据。常见的操作比如选取、替换行或列的数据，还能重组数据表、修改索引、多重筛选等。我们基本上可以把 DataFrame 理解成一组采用同样索引的 Series 的集合 1.1.8. 本节总结 数据分析第一节的课程到这里就结束了，相信你对数据分析有了一定的了解了。下面我们对第一节的内容进行以下总结。 九层之台，起于垒土，不要小看今天所学的知识，它将是我们后期大项目中的基石。 1.1.9. 下节预告 下一关我们要探究太乙真人的奇珍异宝。揭秘Series和DataFrame中的属性和方法。 现在我正式通知您：恭喜您通过第一节! 第二节即将解锁，别忘了今天的课后冲浪，我们下一课再见。 1.1.10. 练习 题目：宇宙第一天团 题目要求： 下面表格存储了天团中一部分人员信息，包括演员姓名、饰演、技能、语录，现在需要创建一个DataFrame将这些信息保存起来。 姓名 饰演 武器 语录 1 小罗伯特·唐尼 钢铁侠 钢铁战衣 和平,我热爱和平 2 克里斯·埃文斯 美国队长 盾牌 最好的选择就是重新开始 3 斯嘉丽·约翰逊 黑寡妇 寡妇蜇 嘿，大兄弟，太阳下山了 4 克里斯·海姆斯沃斯 雷神 雷神之锤 要用知识来打败无知 题目讲解： 创造DataFrame的流程如下： 将表格中每一列数据作为字典中的一个值。 将列名作为字典中的键。 调用DataFrame的构造方法来创建DataFrame。 在屏幕打印DataFrame的数据 书写代码： from pandas import Series,DataFrame import pandas as pd # 使用字典创建 dic={ '姓名': ['小罗伯特·唐尼', '克里斯·埃文斯', '斯嘉丽·约翰逊', '克里斯·海姆斯沃斯'], '饰演': ['钢铁侠', '美国队长', '黑寡妇', '雷神'], '武器': ['钢铁战衣', '盾牌', '寡妇蜇', '雷神之锤'], '语录': ['和平,我热爱和平','最好的选择就是重新开始 ','嘿，大兄弟，太阳下山了','要用知识来打败无知']} df=pd.DataFrame(dic,index=range(1,len(dic)+1)) print(df) 1.1.11. 练习2 题目：渣男备忘录 题目要求：渣男不可怕就怕渣男有“文化”，下面是一个渣男的标准备忘录，现在需要创建一个DataFrame来保存这些信息（你认为渣男还需要记录哪些信息，可以自行添加&#x1F642;）。 姓名 类型 爱好 时间 娜娜 可爱单纯 逛街、电影、爱吃甜 2019-2-14去看电影 淼淼 风骚火辣 喝酒、蹦迪、爱吃辣 2019-2-16去蹦迪 依依 性感高冷 看书、烘焙、爱吃酸 2019-2-18去烘焙 题目讲解： 创造DataFrame的流程如下： 将表格中的每一列创建成Series，作为字典的值。 将列名作为字典中的键。 调用DataFrame的构造方法来创建DataFrame。 在屏幕打印DataFrame的数据 书写代码： from pandas import Series,DataFrame import pandas as pd # 使用字典创建 index_list = ['No1','No2','No3'] dic={ '姓名': Series(['娜娜','淼淼','依依'],index=index_list), '类型': Series(['可爱单纯','风骚火辣','性感高冷'],index=index_list), '爱好': Series(['逛街、电影、爱吃甜','喝酒、蹦迪、爱吃辣','看书、烘焙、爱吃酸'],index=index_list), '时间': Series(['2019-2-14去看电影','2019-2-16去蹦迪','2019-2-18去烘焙'],index=index_list) } df=pd.DataFrame(dic) print(df) Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-23 12:29:34 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"第2课/python数据分析第二课.html":{"url":"第2课/python数据分析第二课.html","title":"Series、Pandas的常用属性&操作方法","keywords":"","body":"1.1. 太乙真人的奇珍异宝1.1.1. 课程介绍1.1.2. Series1.1.3. DataFrame1.1.4. 本节总结1.1.5. 下节预告1.1.6. 练习11.1.7. 练习21.1. 太乙真人的奇珍异宝 1.1.1. 课程介绍 Hello, 我是小K，很高兴又和大家见面了，我们一起继续学习Python数据分析。 为了让你能不受干扰的在学习数据分析路上饱览胜景，请将屏幕调整成全屏，Windows系统：请按F11（或Fn+F11)；苹果系统：请同时按control+command+F。 在上一节我们认识了什么是数据，什么是数据分析以及Pandas数据结构和数据的创建。 本节我们将开始探宝之旅，学习Series和DataFrame的属性和方法，看一下太乙真人有哪些奇珍异宝？ 1.1.2. Series 表格数据中的每一列或者每一行的数据结构都是Series，它可以看成是一维的表格数据。 它可以属于DataFrame的一部分也可以作为一个独立的数据结构存在。 Series的常用属性 下面，我们创建了一个Series，索引是员工号，数据是员工的姓名。我们可以通过values、index、items等Series的属性来获取各部分的全部数据。 此处是代码 ————————————— ——————————— 终端 from pandas import Series emp=['001','002','003','004','005','006'] name=['亚瑟', '后裔','小乔','哪吒' ,'虞姬','王昭君'] series = Series(data=name,index=emp) # 获取数据的值 print(series.values) # 获取索引的值 print(series.index.tolist()) # 获取每对索引和值 print(list(series.items())) values、index、items返回的对象分别是List、Index、Zip类型的数据，为了方便我们使用和观察数据，可以使用series.index.tolist()和list(series.items())方法转化成List类型。 Series就像将索引值暴露在外面的List，其实它们除了外表相似以外，在获取数据方面也非常的相似。我们可以通过索引值来进行单个数据的访问，同样也支持切片选择多个数据。 此处是代码 ————————————— ——————————— 终端 from pandas import Series emp=['001','002','003','004','005','006'] name=['亚瑟', '后裔','小乔','哪吒' ,'虞姬','王昭君'] series = Series(data=name,index=emp) # 使用索引值获取单个数据 print(series['001']) # 使用索引值获取多个不连续的数据 print('索引下标',series[['002','004']]) # 使用切片获取连续的数据 print('索引切片',series['001':'004']) 【神仙的自我修养：获取数据格式—对象名[]；获取多个不连续数据时是双层括号— 对象名[[]]；使用切片时使用的是:】 忽然想到我们的索引值是自定义的，那原来的自带的0、1、2……的索引值去哪里了？ 第一想法肯定是被自定义的index覆盖了呀，错！！！它不仅存在我们还可以使用。 我们自定的index值被叫做索引下标，没有设置index值时会有一个默认的值叫做位置下标。 位置下标就像电影院中的座位号，索引下标就是座位上人的名字。 此处是代码 ————————————— ——————————— 终端 from pandas import Series emp=['001','002','003','004','005','006'] name=['亚瑟', '后裔','小乔','哪吒' ,'虞姬','王昭君'] series = Series(data=name,index=emp) # 获取单个数据 print(series[0]) # 获取多个不连续的数据 print('位置下标',series[[1,3]]) # 使用切片获取连续的数据 print('位置切片',series[0:3]) 趁热打铁，sel = Series(data = ['1','2','3','4'], index = list('abcd')),下面哪个获取操作是错的？ A ：sel[1] B：sel[['a':'c']] C ：sel['a':'c'] D ：sel[[0,3]] A、C、D 恭喜您，基本已经掌握了Series的数据获取。 B 不好意思，你答错了，选B。使用切片的时候是单括号例如C选项，或者双括号内的值应该用，分割例如D选项。 Series的遍历 和Python其它数据结构类似，我们可以很方便的利用循环来遍历Series。我们可以直接遍历Series的值： # 遍历并拿到data数据 for value in series: print(value) 或者通过keys()，遍历Series的索引： # 遍历并拿到index数据 for value in series.keys(): print(value) 也可以通过items()，遍历Series的每对索引和数据 # 遍历并拿到每对索引和数据 for value in series.items(): print(value) 复制上面的代码，你自己来尝试下： 此处是代码 ————————————— ——————————— 终端 1.1.3. DataFrame DataFrame里的数据是按照行和列来进行排列，现在我们一起来看下如何对DataFrame的数据按照行或者列进行选择、遍历以及修改。 数据的选择 每当学校需要打扫卫生的时候，灭绝师太或者老狼都会跑到教室微笑的说：\"后两排拿着工具去打扫操场！\"。 如果所有学生信息都保存在一个DataFrame中，我们有没有方法可以选择某一行或者多行数据呢？ 当然可以，但是在获取之前我们要清楚DataFrame中的数据情况，不然岂不是要闹大笑话—报错。 首先数据的维度是一维还是二维的我们可以使用ndim查看，数据的行数和列数shape，以及行列的索引值index、columns。 此处是代码 ————————————— ——————————— 终端 import pandas as pd df_dict = { 'name':['ZhangSan','LiSi','WangWu','ZhaoLiu'], 'age':['18','20','19','22'], 'weight':['50','55','60','80'] } df = pd.DataFrame(data=df_dict,index=['001','002','003','004']) print(df) # 获取行数和列数 print(df.shape) # 获取行索引 print(df.index.tolist()) # 获取列索引 print(df.columns.tolist()) # 获取数据的维度 print(df.ndim) 需要注意的是，如果我们数据量是10G，像这种数据量比较大并且我们想看数据的具体情况的时候，这些属性就不够用了，如果直接打印df有比较耗时，所以我们可以只获取前几行或者后几行，了解数据的构成即可。 这时候有两个法宝head()、tail()正好能帮我们解决这个问题。 # 获取前两条 df.head(2) # 获取后两条 df.tail(2) 【神仙的自我修养：两个方法都有默认值，默认值是5，当然也可以自己设置，如果数据不够5个会将全部数据拿出来。】 了解数据了，我们就可以修炼下一个招式--获取行数据了。 # 通过位置索引切片获取一行 print(df[0:1]) # 通过位置索引切片获取多行 print(df[1:3]) # 获取多行里面的某几列 print(df[1:3][['name','age']]) # 获取DataFrame的列 print(df['name']) # 如果获取多个列 print(df[['name','age']]) 将上面的代码复制到下面，运行查看结果： 此处是代码 ————————————— ——————————— 终端 import pandas as pd df_dict = { 'name':['ZhangSan','LiSi','WangWu','ZhaoLiu'], 'age':['18','20','19','22'], 'weight':['50','55','60','80'] } df = pd.DataFrame(data=df_dict,index=['001','002','003','004']) 【神仙的自我修养：df[]不支持直接输入标签索引获取行数据，例如：df['001']；这种方式可以获取一列数据，列如：df['name']；如果想获取多行里面的某几列可写成：df[行][列]，例如：df[1:3][['name','age']],将列索引值放到同一个列表中，再将列表放到第二个方括号中。】 当然我们也可以使用另外两个比较好用的法宝进行获取数据：通过行标签索引筛选loc[]，通过行位置索引筛选iloc[]： 此处是代码 ————————————— ——————————— 终端 import pandas as pd df_dict = { 'name':['ZhangSan','LiSi','WangWu','ZhaoLiu'], 'age':['18','20','19','22'], 'weight':['50','55','60','80'] } df = pd.DataFrame(data=df_dict,index=['001','002','003','004']) print(df) # 获取某一行某一列的数据 print(df.loc['001','name']) # 某一行多列的数据 print(df.loc['001',['name','weight']]) # 一行所有列 print(df.loc['001',:]) # 选择间隔的多行多列 print(df.loc[['001','003'],['name','weight']]) # 选择连续的多行和间隔的多列 print(df.loc['001':'003','name':'weight']) 【神仙的自我修养：df.loc[] 通过标签索引获取行数据；它的语法结构是这样的：df.loc[[行],[列]]，方括号中用逗号分隔，左侧是行、右侧是列，千万注意：如果行或者列的使用切片的时候，要把方括号去掉，列df.loc['001':'003','name':'weight']】。 df.iloc[] 通过位置索引获取行数据，他的操作和loc[]操作是一样的，只要将标签索引改成位置索引就好了。 # 取一行 print(df.iloc[1]) # 取连续多行 print(df.iloc[0:2]) # 取间断的多行 print(df.iloc[[0,2],:]) # 取某一列 print(df.iloc[:,1]) # 某一个值 print(df.iloc[1,0]) 上面是iloc的常见的写法，复制运行感受一下： 此处是代码 ————————————— ——————————— 终端 import pandas as pd df_dict = { 'name':['ZhangSan','LiSi','WangWu','ZhaoLiu'], 'age':['18','20','19','22'], 'weight':['50','55','60','80'] } df = pd.DataFrame(data=df_dict,index=['001','002','003','004']) print(df) 怎么样？是不是已经掌握了这两个法宝的使用秘诀了。 需要注意的是，loc和iloc的切片操作在是否包含切片终点的数据有差异。loc['001':'003']的结果中包含行索引003对应的行。iloc[0:2] 结果中不包含序号为2的数据，切片终点对应的数据不在筛选结果中。 DataFrame的遍历 现在有个需求，我们需要将班级中所有人的数据都依次打印出来。那我们就需要对数据进行遍历。 iterrows(): 按行遍历，将DataFrame的每一行转化为(index, Series)对。index为行索引值，Series为该行对应的数据。 for index,row_data in df.iterrows(): print(index,row_data) iteritems():按列遍历，将DataFrame的每一列转化为(column, Series)对。column为列索引的值，Series为该列对应的数据。 for col,col_data in df.iteritems(): print(col) 复制上面的代码，自己来尝试下： 此处是代码 ————————————— ——————————— 终端 1.1.4. 本节总结 对Series或Dataframe行列数据的获取就像军人必修课站军姿一样是必备技能，我们一定要掌握。 数据分析第二节的课程到这里就结束了，相信你对数据分析有了一定的了解了。下面我们对第二节的内容进行以下总结。 现在我正式通知您：恭喜您通过Python第2课! 第3课即将解锁，别忘了今天的课后冲浪，我们下一课再见。 1.1.5. 下节预告 下一节我们要探究如何使用Pandas读取和写入Excel。 1.1.6. 练习1 题目：众里寻她千百度 题目要求： index_list = ['001','002','003','004','005','006','007','008','009','010'] name_list = ['李白','王昭君','诸葛亮','狄仁杰','孙尚香','妲己','周瑜','张飞','王昭君','大乔'] age_list = [25,28,27,25,30,29,25,32,28,26] salary_list = ['10k','12.5','20k','14k','12k','17k','18k','21k','22k','21.5k'] marital_list = ['NO','NO','YES','YES','NO','NO','NO','YES','NO','YES'] dic={ '姓名': Series(data=name_list,index=index_list), '年龄': Series(data=age_list,index=index_list), '薪资': Series(data=salary_list,index=index_list), '婚姻状况': Series(data=marital_list,index=index_list) } df=DataFrame(dic) 根据上面公司的员工信息登记表数据，最后获取下面相关信息： 获取工号为003~007的所有员工信息； 获取所有员工的年龄和工资信息； 查看一个你感兴趣员工的婚姻状况。 参考答案： 此处是代码 ————————————— ——————————— 终端 from pandas import Series,DataFrame # 使用字典创建 index_list = ['001','002','003','004','005','006','007','008','009','010'] name_list = ['李白','王昭君','诸葛亮','狄仁杰','孙尚香','妲己','周瑜','张飞','王昭君','大乔'] age_list = [25,28,27,25,30,29,25,32,28,26] salary_list = ['10k','12.5','20k','14k','12k','17k','18k','21k','22k','21.5k'] marital_list = ['NO','NO','YES','YES','NO','NO','NO','YES','NO','YES'] dic={ '姓名': Series(data=name_list,index=index_list), '年龄': Series(data=age_list,index=index_list), '薪资': Series(data=salary_list,index=index_list), '婚姻状况': Series(data=marital_list,index=index_list) } df=DataFrame(dic) # 1. 获取工号为003~007的所有员工信息 result1 = df['003':'007'] print(result1) # 2. 获取所有员工的年龄和工资信息 result2 = df.loc[:,['年龄','薪资']] print(result2) # 3. 查看一个你感兴趣员工的婚姻状况 result3 = df.loc['009',['姓名','年龄','婚姻状况']] print(result3) 1.1.7. 练习2 题目：如何查看别人的薪水？ 题目要求： 根据练习1的信息，完成下面要求： 用三种方法获取遍历所有员工的薪水信息； 获取最高薪水值。 参考答案： # 如何查看别人的薪水？ from pandas import Series,DataFrame # 使用字典创建 index_list = ['001','002','003','004','005','006','007','008','009','010'] name_list = ['李白','王昭君','诸葛亮','狄仁杰','孙尚香','妲己','周瑜','张飞','王昭君','大乔'] age_list = [25,28,27,25,30,29,25,32,28,26] salary_list = ['10k','12.5k','20k','14k','12k','17k','18k','21k','22k','21.5k'] marital_list = ['NO','NO','YES','YES','NO','NO','NO','YES','NO','YES'] dic={ '姓名': Series(data=name_list,index=index_list), '年龄': Series(data=age_list,index=index_list), '薪资': Series(data=salary_list,index=index_list), '婚姻状况': Series(data=marital_list,index=index_list) } df=DataFrame(dic) # 方法一：遍历薪水列 for value in df['薪资']: print(value) # 方法二：遍历薪水列 for index,row_data in df.iterrows(): print(row_data['薪资']) # 方法三：遍历薪水列 for col,col_data in df.iteritems(): if col == '薪资': print(col_data) # 获取最大薪资 for col,col_data in df.iteritems(): if col == '薪资': # 将薪资中的k去掉并转化成float类型 list1 = [float(value[:len(value)-1]) for value in col_data] # 排序 max_salary = sorted(list1,reverse=True)[0] print(max_salary) Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-23 12:30:40 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"第3课/python数据分析第三课.html":{"url":"第3课/python数据分析第三课.html","title":"数据的写入和读取","keywords":"","body":"1.1. 再见Excel，你好Pandas！1.1.1. 课程介绍1.1.2. 数据的写入1.1.3. 数据的读取1.1.4. 本节总结1.1.5. 下节预告1.1.6. 练习11.1.7. 练习21.1. 再见Excel，你好Pandas！ 1.1.1. 课程介绍 Hello, 我是小K，很高兴又和大家见面了，我们一起继续学习Python数据分析。 为了让你能不受干扰的在学习数据分析路上饱览胜景，请将屏幕调整成全屏，Windows系统：请按F11（或Fn+F11)；苹果系统：请同时按control+command+F。 在上一节我们了解了Series的常用属性和方法以及DataFrame的数据获取和遍历。 在做数据分析的时候，Excel是我们最常用的工具，但是当数据量比较大的时，Excel光把数据文件打开就要很久很久，那么利用Pandas就会非常高效。 本节我们将开始新的征程，学习如何利用Pandas读取和写入Excel？ 1.1.2. 数据的写入 我们可以将数据写入到文件中进行永久性的保存，支持的文件根式有HTML、CSV、JSON、Excel。 csv是最为常见的以纯文本文件存储数据文件的格式，它的优点是通用性很强，不受操作系统以及具体的软件的限制。我们以写入csv为例，看一下pandas是如何是将数据写入csv文件中。 此处是代码 ————————————— ——————————— 终端 from pandas import Series,DataFrame # 使用字典创建 index_list = ['001','002','003','004','005','006','007','008','009','010'] name_list = ['李白','王昭君','诸葛亮','狄仁杰','孙尚香','妲己','周瑜','张飞','王昭君','大乔'] age_list = [25,28,27,25,30,29,25,32,28,26] salary_list = ['10k','12.5k','20k','14k','12k','17k','18k','21k','22k','21.5k'] marital_list = ['NO','NO','YES','YES','NO','NO','NO','YES','NO','YES'] dic={ '姓名': Series(data=name_list,index=index_list), '年龄': Series(data=age_list,index=index_list), '薪资': Series(data=salary_list,index=index_list), '婚姻状况': Series(data=marital_list,index=index_list) } df=DataFrame(dic) # 写入csv，path_or_buf为写入文本文件 df.to_csv(path_or_buf='./People_Information.csv', encoding='utf_8_sig') print('end') 在上面的代码里，我们创建了一个DataFrame，接着通过to_csv()方法将DataFrame保存为csv文件。 从结果中可以发现，to_csv()保存数据时，df的行索引作为一列被输出到csv文件中。 如何在保存csv文件的时候，不存储DataFrame的行索引信息呢，我们看下面的解决方法。 df.to_csv(path_or_buf='./People_Information.csv',index=False,encoding='utf_8_sig') 在to_csv方法中将参数index设置为False就可以不存储DataFrame的行索引信息。 在to_csv方法参数中设置encoding='utf_8_sig'，此举为何呢？ 因为to_csv()方法生成csv文件时，打开文件时都是乱码，encoding参数设置“utf_8_sig”后乱码就会消失。 1.1.3. 数据的读取 数据的存储我们发现很简单，调用to_csv()后设置文件存储路径后就可以了。 人生就是要反复的折腾，现在我们看看是如何从csv文件将数据读取出来的。 运行下面的代码，看一下与上面保存的数据是否一致。 此处是代码 ————————————— ——————————— 终端 import pandas as pd df = pd.read_csv('./People_Information.csv') print(df) print(df.shape) 根据结果我们可以看出，调用read_csv()方法并传入文件的路径，就可以将数据读取出来并且是DataFrame类型。 数据的列索引 还可以看出，read_csv()默认会将文件中的第一行作为数据的列索引。 如果csv文件的第一行或者其他行不满足我们的需求时，我们就不能再屈服在它的淫威下了，我们要自己修改。 当csv数据的第一行是一条脏数据，不符合我们要求，如上图。 可以利用read_excel()中的header参数进行选择哪一行作为我们的列索引。 import pandas as pd people = pd.read_csv('./data/People1.csv',header = 0) print(people.columns) import pandas as pd people = pd.read_csv('./data/People1.csv',header = 1) print(people.head()) 将上面的两个代码块分别放到运行框中运行，对比结果。 此处是代码 ————————————— ——————————— 终端 read_excel()的header参数默认是0，取第一行的值，可以根据具体的要求设置header的值来确定列索引。 如果都不满足的你的要求，可以将header设置为None，列索引值会使用默认的1、2、3、4，之后在自行设置。 江湖秘籍：当指定了header的值，读出来的数据就是从该行开始向下切片，该行以上的数据会被忽略。 指定表格读取 一个Excel文件可以创建多个表，然后在不同的表中存储不同数据，这种形式的文件很常见。但是要注意csv文件不存在多个sheet的问题。 所以，如果是Excel文件就需要考虑，如何从Excel中读取出其中的一个表。 Excel文件的读取和csv的读取方式相似，to_csv()读取csv文件，to_excel()读取Excel文件。 import pandas as pd sheet = pd.read_excel('./data/sheet.xlsx') print(sheet.head()) 将上面的代码，复制到下面运行，对比一下Excel和csv的文件读取。 此处是代码 ————————————— ——————————— 终端 to_csv()会比to_excel()少一个sheet_name的参数，这个参数就是可以指定表的名字。 此处是代码 ————————————— ——————————— 终端 import pandas as pd sheet1 = pd.read_excel('./data/sheet.xlsx',sheet_name='sheet1') print(sheet1.head()) sheet2 = pd.read_excel('./data/sheet.xlsx',sheet_name='sheet2') print(sheet2.head()) 在上面的代码里，我们引入了带有两个表的sheet.xlsx的Excel文件，两个表名分别为'sheet1'，'sheet2'，然后我们通过指定sheet_name的值，获取不同表中的数据。 1.1.4. 本节总结 1.1.5. 下节预告 下一节我们要开始学习Pandas是如何让数据增加、删除和合并的。 图 1.1.6. 练习1 题目：组建自己的球队 题目要求： 从数据集中选取5个球员，组成自己的球队。 球员信息存储在csv中，路径为./players.csv 打印前5条了解数据的基本信息 随机获取5条数据 参考代码： import pandas as pd import random # 1. 读取数据 players = pd.read_csv('./players.csv') # 2. 打印前5条了解数据的基本信息 print(players.head()) # 3. 随机获取5条信息 index_list = players.index.to_list() for i in range(0,5): value = index_list[random.randint(0,len(index_list))] msg = players.iloc[value] print(msg) 1.1.7. 练习2 题目：进军好莱坞 题目要求： 在这个练习中，我们会读取好莱坞电影信息的csv文件，并统计出数据集中共有多少个导演。 球员信息存储在csv中，路径为./movie_data.csv 获取导演名字信息并算出一共多少个导演。 参考代码： import pandas as pd import random # 1. 读取数据 movie = pd.read_csv('./movie_data.csv') # 2. 了解数据的基本信息 print(movie.head()) # 3. 获取导演列信息,并转成list directors = movie['director_name'].to_list() # 4. 去重后获取个数 num = set(directors) print(len(num)) Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-23 12:30:55 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"第4课/python数据分析第四节.html":{"url":"第4课/python数据分析第四节.html","title":"删除行、列、重复数据处理、空值处理","keywords":"","body":"1.1. 数据七十二变1.1.1. 课程介绍1.1.2. 删除数据1.1.3. 空值的处理1.1.4. 重复数据的处理1.1.5. 本节总结1.1.6. 下节预告1.1.7. 练习11.1.8. 练习21.1. 数据七十二变 1.1.1. 课程介绍 Hello, 我是小K，很高兴又和大家见面了，我们一起继续学习Python数据分析。 为了让你能不受干扰的在学习数据分析路上饱览胜景，请将屏幕调整成全屏，Windows系统：请按F11（或Fn+F11)；苹果系统：请同时按control+command+F。 在上一节我们解锁了Pandas对数据的永久性保存以及对本地数据的读取。 我们分析的数据来源有很多种，例如：爬取、公司数据库、数据公司等。但是这些数据中有些数据项是我们不需要的，甚至可能会存在重复数据和空值的情况。 所以，本节我们将继续解锁数据七十二变，看一下数据是如何删除多余的数据和重复数据以及空值的处理。 本节知识点图 本节课我们将以（1990年到2015年多个国家的年龄抚养比率）数据为课程实验数据。为了满足你们的好奇心，先跟大家科普一下何为年龄抚养比率？ 年龄抚养比是非劳动年龄人口（18岁以下至65岁及以上）与劳动年龄人口（18至64岁之间）的“比率”（百分比）。 1.1.2. 删除数据 数据的路径为./data/rate.xlsx，现在我们读取文件，了解一下数据的基本情况，运行下方代码查看结果： 此处是代码 ————————————— ——————————— 终端 import pandas as pd df = pd.read_excel('./data/rate.xlsx') print(df.shape) print(df.head()) 在结果中我们发现有多个NaN，那NaN表示的是什么数据呢？ 如果文件的单元格中没有值时，在使用pandas读取后就会用NaN表示，也就是我们常说的空值。 在NumPy模块中提供了nan的值，如果你想要创建一个空值，可以使用下方代码： from numpy import nan as NaN 而且需要注意的是，NaN比较特殊点就是其本身是一种float类型数据。 print(type(NaN)) 但是，当NaN可以参与到数据计算中，最终的结果却永远都是NaN。 print(NaN+1) 所以，当我们不知道的情况下会影响我们的计算结果。 请抄写代码到下面的代码框运行： 此处是代码 ————————————— ——————————— 终端 对于大批量的Series数据，使用肉眼很难判断空值的存在，这时我们可以先对空值进行过滤。 请运行下方代码，查看过滤的方法： from numpy import nan as NaN se=pd.Series([4,NaN,8,NaN,5]) print(se.notnull()) print(se[se.notnull()]) 从结果中可以看出，我们成功的去除了数据中的空值，并且保留了非空的数据。 se.notnull()方法可以对每一个数据进行空值判断，最后返回一个bool类型数据，空值用False替代，同理非空用True值替代。 然后使用se[se.notnull()]取值方式，就会过滤掉空值，保留非空值。 但是在DataFrame类型数据中，我们只能notnull()方法判断是否有空值存在，确不能使用se[se.notnull()]取值方式过滤空值。 运行下方代码，查看空值数据是否被过滤： import pandas as pd df = pd.read_excel('./rate.xlsx') print(df.notnull()) print(df[df.notnull()]) 通过结果我们发现，结果中依然存在空值，并没有过滤掉空值。 所以在DataFrame类型数据中，一般我们会将存在NaN的数据使用dropna()方法全部删掉： df1 = df.dropna() dropna()是删除空值数据的方法，默认将只要含有NaN的整行数据删掉，如果想要删除整行都是空值的数据需要添加how='all'参数。 如果想要对列做删除操作，需要添加axis参数，axis=1表示列，axis=0表示行。 我们也可以是用thresh参数筛选想要删除的数据，thresh=n保留至少有n个非NaN数据的行。 接下来抄写代码到下面的代码框运行，测试两个参数： 此处是代码 ————————————— ——————————— 终端 到这里有同学会问，如果我只是单纯的想删除两行数据该怎么做呢？ 如果只是单纯的想删除数据，我们可以使用df.drop()方法，一起来了解一下该函数。 DataFrame.drop(labels=None,axis=0, index=None, columns=None, inplace=False) labels ：就是要删除的行列的名字，用列表给定； axis：默认为0，指删除行，因此删除columns时要指定axis=1； index： 直接指定要删除的行； columns： 直接指定要删除的列； inplace=False：默认该删除操作不改变原数据，而是返回一个执行删除操作后的新dataframe； inplace=True：则会直接在原数据上进行删除操作，删除后无法返回； 所以，根据参数我们可以总结出，删除行列有两种方式： labels=None,axis=0 的组合 index或columns直接指定要删除的行或列 请在下面代码框中，尝试删除一行数据和一列数据： 看一下，小K的代码： import pandas as pd df = pd.read_excel('./rate.xlsx') # 删除第0行和第1行 # df.drop(labels=[0,1],axis=0) # 删除列名为1990的列 df.drop(axis=1,columns=1990) 1.1.3. 空值的处理 对于空值我们可以将整条数据删除，也可以使用fillna()方法对空值进行填充。 df.fillna(value=None, method=None, axis=None, inplace=False, limit=None, downcast=None, **kwargs) value：需要用什么值去填充缺失值 axis：确定填充维度，从行开始或是从列开始 method： ​ ffill：用缺失值前面的一个值代替缺失值，如果axis =1，那么就是横向的前面的值替换后面的缺失值，如 果axis=0，那么则是上面的值替换下面的缺失值。 ​ bfill：缺失值后面的一个值代替前面的缺失值。 limit：确定填充的个数，如果limit=2，则只填充两个缺失值。 注意：method参数不能与value参数同时出现。 下面,请分别打开左边代码框中的代码注释, 然后运行观察结果： 此处是代码 ————————————— ——————————— 终端 import pandas as pd df = pd.read_excel('./data/rate.xlsx') # 用常数填充fillna # print(df.fillna(0)) # 用一列的平均值填充 # print(df.fillna(df.mean()) # 用前面的值来填充ffill # print(df.fillna(method='ffill',axis=0)) 1.1.4. 重复数据的处理 重复数据的存在有时不仅会降低分析的准确度，也会降低分析的效率。所以我们在整理数据的时候应该将重复的数据删除掉。 利用duplicated()函数可以返回每一行判断是否重复的结果（重复则为True)。 运行下面的代码，观察结果是否有重复数据： 此处是代码 ————————————— ——————————— 终端 import pandas as pd df = pd.read_excel('./data/rate.xlsx') # 返回重复的结果 print(df.duplicated()) 通过结果我们发现，返回的是一个值为Bool类型的Series，如果当前行所有列的数据与前面的数据是重复的就返回True；反之，则返回False。 可以使用drop_duplicates()将重复的数据行进行删除。 df.drop_duplicates() 我们也可以只可以通过判断某一列的重复数据，然后进行删除 df.drop_duplicates(['CountryName'],inplace=False) 其中['CountryName']表示对比CountryName例数据是否有重复，inplace用来控制是否直接对原始数据进行修改。 现在是否已经理解如何处理重复值了呢？可以将上面的代码复制过来，验证你的想法： 此处是代码 ————————————— ——————————— 终端 1.1.5. 本节总结 到此，我们就将年龄抚养比率数据的空值、重复数据已经处理完毕。遇到不同的数据时，我们应该灵活应对，万变不离其宗，本质都是一样的，所以大家要勤加练习。 1.1.6. 下节预告 1.1.7. 练习1 题目：如果你不需要，就让它消失！ 题目要求： 从自2009-2010赛季以来的英格兰当地足球比赛结果数据中，删除2009/2010赛季的所有数据以及county列。 文件路径为：./data/sccore_game.xlsx game_date-比赛时间 country-国家 tournament-锦标赛 season-赛季 home_field-主场场地 home_team-主场球队 away_team-客场球队 home_team_score-主场球队得分 away_team_score-客场球队得分 home_team_score_extra_time-主持球队加时赛 away_team_score_extra_time-客场球队加时赛 参考答案： import pandas as pd df = pd.read_excel('./data/sccore_game.xlsx') print(df.shape) # 通过遍历获取2009/2010赛季的数据索引（下节课我们将学习其他获取方式） index_list = [] for index,row_data in df.iterrows(): if row_data['season']=='2009/2010': index_list.append(index) # 删除2009/2010赛季的数据 df1 = df.drop(index_list,axis=0) # print(df1) # 删除country列 df2 = df1.drop('country',axis=1) print(df2) 1.1.8. 练习2 题目：算你狠 题目要求： 根据文件（./data/04Books.xlsx.）中的商品的单价（OnePrice）和购买数量（Count）计算出对应的总价（Price）。 参考答案： import pandas as pd books = pd.read_excel('./data/04Books.xlsx',index_col = 'ID') print(books) # 计算Price的值(这种方法是列与列之间对齐后进行计算) # books[\"Price\"] = books['OnePrice'] * books['Count'] # print(books) # 如果只想算某一段就可以，使用循环迭代（是单元格与单元格之间的操作） # for i in range(5,16): # books[\"Price\"].iloc[i] = books[\"OnePrice\"].iloc[i] * books[\"Count\"].iloc[i] # print(books) Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-23 12:30:58 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"第5课/python数据分析第五节.html":{"url":"第5课/python数据分析第五节.html","title":"数据的合并、筛选、排序","keywords":"","body":"1. 数联璧合1.1.1. 课程介绍1.1.2. 数据的合并1.1.3. 数据的筛选1.1.4. 数据的排序1.1.5. 本节总结1.1.6. 下节预告1.1.7. 练习1：最长的时间是多久?1.1.8. 练习2：全国人口最多的城市1. 数联璧合 1.1.1. 课程介绍 Hello, 我是小K，很高兴又和大家见面了，我们一起继续学习Python数据分析。 为了让你能不受干扰的在学习数据分析路上饱览胜景，请将屏幕调整成全屏，Windows系统：请按F11（或Fn+F11)；苹果系统：请同时按control+command+F。 我们经常需要将多个Excel文件，或者从多个渠道获得来的数据综合起来一起分析。本节课，我们将学习如何利用Pandas合并多个DataFrame数据，以及筛选我们心仪的数据。 1.1.2. 数据的合并 数据合并主要包括下面两种操作： 轴向连接（concatenation），pd.concat()可以沿一个轴将多个DataFrame对象连接在一起，形成一个新的DataFrame对象 融合（merging），pd.merge()方法可以根据一个或多个键将不同DataFrame中的行连接起来 concat concat()函数可以将数据根据不同的轴作进行合并。我们先看一下concat()的常用参数： pd.concat(objs, axis=0, join='outer') objs: series，dataframe或者是panel构成的序列lsit axis： 需要合并链接的轴，0是行，1是列，默认是0 join：连接的方式 inner，或者outer，默认是outer 方便同学们更好的理解，我们自己构建一些简单的数据，进行图文演示。 运行下面代码，了解数据的基本情况。 此处是代码 ————————————— —————————— 终端 import pandas as pd dict1={ 'A': ['A0', 'A1', 'A2', 'A3'], 'B': ['B0', 'B1', 'B2', 'B3'], 'C': ['C0', 'C1', 'C2', 'C3']} df1=pd.DataFrame(dict1) print(df1) dict2={ 'B': ['B0', 'B1', 'B2', 'B3'], 'C': ['C0', 'C1', 'C2', 'C3'], 'D': ['D0', 'D1', 'D2', 'D3']} df2=pd.DataFrame(dict2) print(df2) 当concat()使用默认参数合并df1和df2时,pd.concat([df1,df2],axis=0,join='outer')。 通过上面的结果可以发现，当join='outer'，axis参数为0时，列进行并集处理，纵向表拼接，缺失值由NaN填充，并且会保留原有数据的行索引。 如果两个表的index都没有实际含义，使用ignore_index参数，置true，重新整理一个新的index。 pd.concat([df1,df2],axis=0,join='outer',ignore_index=True) 当concat()的axis参数为1合并df1和df2时,pd.concat([df1,df2],axis=1,join='outer')。 当join='outer'，axis参数为1时，行进行并集处理，横向表拼接，缺失值由NaN填充。 当concat()的join参数为inner时合并df1和df2时,pd.concat([df1,df2],axis=0,join='inner')。 通过上面的结果可以看出，如果为inner得到的是两表的交集，如果是outer，得到的是两表的并集。 下面大家复制上面的代码到下面的代码框运行，验证的一下自己的理解： 此处是代码 ————————————— ——————————— 终端 merge merge()函数通过指定连接键拼接列数据，我们先看一下merge的常用参数： merge(left, right, how='inner', on=None) 参数介绍： left和right：两个要合并的DataFrame how：连接方式，有inner、left、right、outer，默认为inner on：指的是用于连接的列索引名称，必须存在于左右两个DataFrame中，如果没有指定且其他参数也没有指定，则以两个DataFrame列名交集作为连接键 运行下面代码，了解数据的基本情况。 此处是代码 ————————————— ——————————— 终端 import pandas as pd left = pd.DataFrame({'key':['a','b','b','d'],'data1':range(4)}) print(left) right = pd.DataFrame({'key':['a','b','c'],'data2':range(3)}) print(right) 当merge()使用默认参数连接两个DataFrame时，pd.merge(left, right): merge()默认做inner连接，并且使用两个DataFrame的列名交集（key）作为连接键，同样，最终连接的数据也是两个DataFramekey列数据的交集。 当两个DataFram使用做outer连接时，pd.merge(left,right,on=['key'],how='outer'): 当merge()做outer连接时最终连接的数据是两个DataFramekey列数据的并集，缺失的内容由NaN填充。 当两个DataFram使用left做连接时，pd.merge(left,right,on=['key'],how='left'): 当merge()做left连接时，最终连接的数据将以left数据的链接建为准合并两个数据的列数据，缺失的内容由NaN填充。 那么，当merge()做right连接时，最终的链接数据是什么样呢？运行下面的代码，验证你的想法： 此处是代码 ————————————— ——————————— 终端 import pandas as pd left = pd.DataFrame({'key':['a','b','b','d'],'data1':range(4)}) right = pd.DataFrame({'key':['a','b','c'],'data2':range(3)}) result = pd.merge(left,right,on=['key'],how='right') print(result) 上面我们了解两种合并数据的方式，接下来我们看一下他们的应用场景： 例如： 现在有两张表格分别存储了9月和10月份的成交信息，那么这个时候我们就可以使用concat( )将两个表沿着0轴合并。 例如： 现在有两张表格，一个是成交信息，包含订单号、金额、客户ID等信息；第二个是客户信息，包含客户ID、姓名、电话号等信息，那么这个时候我们就可以使用merge()根据客户ID将两个表合并成一个完整的表。 1.1.3. 数据的筛选 前面的课程中，我们学习了如何获取一条数据或者连续的多条数据，但是实际工作中我们经常需要处理上万条数据，特别是合并后的数据甚至上亿条，那么我们如何能快速筛选出符合条件的数据呢？ 接下来，我们用某网站2017年用户数据为实验数据，来筛选我们想要的数据，路径为./data/mouhu_users_2017.csv。 数据详情: _id 关注的收藏夹数量 关注数量 关注者数量（粉丝数） 关注的问题数量 关注的话题数量 关注的专栏数量 运行下面代码，了解数据的基本情况。 此处是代码 ————————————— ——————————— 终端 import pandas as pd df = pd.read_csv('./data/mouhu_users_2017.csv') df.head() 了解了数据的基本情况之后，第一个需求是将关注者超过100的用户数据获取出来。 我们先来看看小K的筛选逻辑，然后运行代码，验证筛选结果： 此处是代码 ————————————— ——————————— 终端 import pandas as pd df = pd.read_csv('./data/mouhu_users_2017.csv') bools= df['关注者']>100 df1 = df[bools] print(df1.shape) print(df1) 我们已经准确获取到所有关注者超过100的用户数据，下面我们看一下代码的逻辑。 bools= df['关注者']>100 首先判断每个用户的关注者数量是否大于100，大于则会返回True，表示该行被标记为True，否则被标记为False。bools记录了每一行是否符合筛选条件，是一个Series对象，其中的值是bool类型。 df1 = df[bools] 然后，根据bools每行的值来对df进行筛选，值为True，表示对应的行会留下，否则，则去除。 最后打印的df1数据就是关注者超过100的用户数据。这是pandas根据某列的值进行筛选的基本逻辑。 根据某列的值进行筛选的逻辑我们已经掌握了，如何进行多条件的联合筛选呢？ 第二个需求是：获取关注者超过300并且关注的超过100的用户数据。 现在需要你抄写代码到下方的代码框，然后运行。 import pandas as pd df = pd.read_csv('./data/mouhu_users_2017.csv') bool1= df['关注者']>300 bool2= df['关注']>100 df2 = df[bool1 & bool2] df2.head() 此处是代码 ————————————— ——————————— 终端 上面的这段代码里，我们通过了2个限制条件df['关注者']>300和 df['关注']>100 分别得到 bool1和bool2这2个Series。 在我们的需求中，需要的数据是同时满足两个条件，所以我们使用逻辑与运算连接两个值，最后获取同时满足两个条件的值。 1.1.4. 数据的排序 在数据获取过程中，数据的排序也是我们经常需要处理的问题。例如：我们需要找出关注者数量前十的用户信息。 可以使用sort_index()、sort_values()两个方法对数据进行排序，并且这两个方法Series和DataFrame都支持。 DataFrame的sort_index( )方法是按照行索引进行排序，sort_values()可以指定具体列进行排序。 sort_index 接下来，我们使用的世界年龄抚养比率数据为行索引排序实验数据，是否还记得这个数据呢？运行下面的代码，我们一起回顾一下这个数据： 此处是代码 ————————————— ——————————— 终端 import pandas as pd df = pd.read_excel('./data/rate.xlsx') print(df.shape) print(df.head()) 我们先来看一下，如何根据国家名称来进行排序，并且Country Code这一列被设置成了行索引。 此处是代码 ————————————— ——————————— 终端 import pandas as pd df = pd.read_excel('./data/rate.xlsx',index_col='Country Code') df.sort_index(inplace=True,ascending=True) df.head() 通过结果发现，原来排序这么简单！接下来我们一起分析一下代码。 read_excel()中的参数index_col='Country Code'作用是在读取文件的时候指定Country Code这一列数据为行索引。 inplace=True参数和我们之前见过的作用一样，用来控制是否直接对原始数据进行修改。 ascending可以控制排序的顺序，默认值为True从小到大排列，当它被设置为False的时候就可以实现倒序排列。 现在就需要你马上动手更改上面的代码，实现数据根据索引进行倒序排列。 sort_values 现在我们来完成第一个问题，获取某乎关注者数据前十的用户数据。那么，我们就需要根据关注者这一列数据进行排序。 import pandas as pd df = pd.read_csv('./data/mouhu_users_2017.csv') df.sort_values(by='关注者',ascending=False,inplace=True) print(df.head(10)) 我们成功的获取了关注者数据前十的用户数据，按照惯例我们一起分析一下代码。 by:决定了是按数据中的哪一列进行排序，将需要按照某列排序的列名赋值给by即可 ascending=False:将数据按照从大到小的顺序排列 inplace=True:用来控制是否直接对原始数据进行修改 根据排序后的结果，我们发现最高的关注者数量已经达到了585787，并远远的看着第二名的356246，确有大V的潜质啊。 1.1.5. 本节总结 数据的合并、筛选和排序，是数据整理中比较重要的技能，就像将自行车变跑车，会大大提高你的工作效率，成功没有捷径，必须反复练习，勤于总结。下面我们对这节的知识点进行以下总结。 现在我正式通知您：恭喜您通过Python数据分析第5课! 第6课即将解锁，别忘了今天的课后冲浪，我们下一课再见。 1.1.6. 下节预告 1.1.7. 练习1：最长的时间是多久? 题目：最长的时间是多久? 题目要求： 现在我们有2017年度1月份和2月份的共享单车历史骑行数据，路径为./data/2017_1_data.csv和./data/2017_2_data.csv。 数据描述： Duration (ms)：骑行时间， 以毫秒为单位。 Start date：开始骑行时间 End date：结束骑行时间 Start station：开始地点 End station：结束地点 Bike number：共享单车车号 Member type：用户类别： 会员（Member/casual非会员） 将两个csv数据合并成一个数据，并按骑行时间进行倒序排列，获取最长的骑行时间。 参考答案： import pandas as pd df1 = pd.read_csv('./data/2017_1_data.csv') print(df1.shape) df2 = pd.read_csv('./data/2017_2_data.csv') print(df2.shape) # 合并数据 df3 = pd.concat([df1,df2]) print(df3.shape) print(df3.head()) # 倒序排列时间 df3.sort_values(by='Duration (ms)',ascending=False,inplace=True) print(df3.head()) # 获取最长时间 long_time = df3.iloc[0]['Duration (ms)'] print(df3.head()) print(long_time) 1.1.8. 练习2：全国人口最多的城市 题目：全国人口最多的城市 题目要求： 根据第六次全国人口普查中的常住人口数据，获取全国人口最多的10个城市。 数据信息：共包含省、地区、结尾、常住人口4个字段 难点：根据结尾字段的数据，过滤掉省，保留市 参考答案： import pandas as pd df = pd.read_csv('./data/liupu.csv') # 查看数据 print(df.head()) # series.str会将每一个数据转换成字符串 # contains()判断字符串是否含有指定子串，返回的是bool类型 bools = df['结尾'].str.contains(\"市\") # 根据人口数倒序排列 df = df[bools].sort_values('常住人口',ascending=False) # 获取前十个数据 print(df.head(10)) Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-23 12:31:23 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"第6课/python数据分析第六课.html":{"url":"第6课/python数据分析第六课.html","title":"数据的分组、分组遍历、统计","keywords":"","body":"1. 给数据分个班1.1.1. 课程介绍1.1.2. 数据的分组1.1.3. 对分组进行遍历1.1.4. 按多列进行分组1.1.5. 对分组后数据进行统计1.1.6. 本节总结1.1.7. 下节预告1.1.8. 练习1：好色的不止是女人1.1.9. 练习2: 那些年错过的电影1. 给数据分个班 备用标题：人以群分，数以组聚 1.1.1. 课程介绍 Hello, 我是小K，很高兴又和大家见面了，我们一起继续学习Python数据分析。 为了让你能不受干扰的在学习数据分析路上饱览胜景，请将屏幕调整成全屏，Windows系统：请按F11（或Fn+F11)；苹果系统：请同时按control+command+F。 上一节我们解锁了如何对数据的合并、筛选和数据的排序的技能，大家要记得经常的复习和练习呦！ 俗话说：“人与类聚，物以群分”，这一节我们将解锁数据的分组以及分组后统计。Pandas的分组相对于Excel会更加简单和灵活。 1.1.2. 数据的分组 本节我们将以福布斯2018年度亿万富翁数据为实验数据，探索数据分组的奥秘，运行下面的代码，来了解一下数据的基本情况： 此处是代码 ————————————— ——————————— 终端 import pandas as pd df = pd.read_excel('./data/forbes_2018.xlsx') print(df.head()) print(df.shape) 数据详情 name-名字 lastName-姓 age-年龄 country-国家 gender-性别 wealthSource-财富来源 根据结果我们了解到，共有2031条数据，那么在这些富翁中男女比例是多少呢？ 要解决这个问题，我们最好的办法就是根据性别分成男女两组，然后分别计算他们的人数，从而计算他们的占比。 Pandas提供了一个灵活高效的groupby功能，它使你能以一种自然的方式对数据集进行切片、切块、摘要等操作。 我们一起看下如何使用groupby()方法根据性别将富翁们进行分组，运行下方代码，查看结果。 此处是代码 ————————————— ——————————— 终端 import pandas as pd df = pd.read_excel('./data/forbes_2018.xlsx') # 根据gender列进行分组 groups = df.groupby('gender') print(groups) 根据结果可以发现，分组后的结果为DataFrameGroupBy object，是一个分组后的对象。 用groupby的size方法可以查看分组后每组的数量，并返回一个含有分组大小的Series： print(groups.size()) 根据上面的方法，你是否已经有了如何获取男女的占比是多少的思路呢？别犹豫，在下面的代码框中一试便知： 此处是代码 ————————————— ——————————— 终端 import pandas as pd df = pd.read_excel('./data/forbes_2018.xlsx') # 请根据的你的思路用代码在下面实现 怎么样？不管对错有想法就要试一试，现在请看小K的答案： import pandas as pd df = pd.read_excel('./data/forbes_2018.xlsx') group = df.groupby('gender') for gender,value in group.size().items(): # 计算每组的占比 accounted = value/df.shape[0] # 将小数转化成百分数 bb = \"%.2f%%\" % (accounted * 100) print('福布斯2018年度亿万富翁中{}共{}位，占比是{}'.format(gender,value, bb)) df.groupby('gender')是根据gender列对整个数据进行分组，同样我们也可以只对一列数据进行分组，只保留我们需要的列数据。 例如：我们通过性别gender，只对age列数据进行分组。 group = df['age'].groupby(df['gender']) # 查看分组 print(group.groups) # 根据分组后的名字选择分组 print(group.get_group('F')) 将上面代码复制到代码框，运行产看结果： 此处是代码 ————————————— ——————————— 终端 import pandas as pd df = pd.read_excel('./data/forbes_2018.xlsx') 代码df['age'].groupby(df['gender'])的逻辑是：取出df中age列数据，并且对该列数据根据df['gender']列数据进行分组操作。 上面的带也可改写成df.groupby(df['gender'])['age']，它的逻辑是：将df数据通过df['gender']进行分组，然后再取出分组后的age列数据。两种写法达到的效果是一样的。 group.groups的结果是一个字典，字典的key是分组后每个组的名字，对应的值是分组后的数据，此方法方便我们产看分组的情况。 group.get_group('F')这个方法可以根据具体分组的名字获取，每个组的数据。 1.1.3. 对分组进行遍历 上面我们通过groupby()和size()两个方法以及以前所学的一些技能计算出了富豪的男女占比。 如果我们还想要分别查看富豪中男、女的最大年纪，最小年纪以及平均年龄，看看我们是不是还有机会成为他们中的一员&#x1F60A;。 groups.get_group('F')可以获取分组后某一个组的数据，'F'为组的名字，这样我们就可以对某一个组进行处理。 下面的代码实现了获取'F'组的最大年纪，最小年纪以及平均年龄，运行代码并观察结果。 此处是代码 ————————————— ——————————— 终端 import pandas as pd df = pd.read_excel('./data/forbes_2018.xlsx') groups = df.groupby('gender') # 获取F组的数据 f_group = groups.get_group('F') # 获取平均值 f_mean = f_group['age'].mean() # 获取最大值 f_max = f_group['age'].max() # 获取最小值 f_min = f_group['age'].min() print(f_mean,f_max,f_min) 代码中我们使用get_group()获取了F组的数据，并使用mean()、max()、min()等统计函数快速获取我们的指标值。 pandas里常用的统计函数包括： count( )：统计列表中非空数据的个数 nunique( )：统计非重复的数据的个数 sum( )：统计列表中所有数值的和 mean( )：计算列表中数据的平均值 median( )：统计列表中数据的中位数 max( )：求列表中数据的最大值 min( )：求找列表中数据的最小值 上面的代码成功的计算出了我们想要的数据，我们也可以遍历分组后的数据，并获取他们的最大年纪，最小年纪以及平均年龄。 运行下面的代码，看一下如何遍历分组后的数据。 此处是代码 ————————————— ——————————— 终端 import pandas as pd df = pd.read_excel('./data/forbes_2018.xlsx') groups = df.groupby('gender') for group_name,group_df in groups: print(group_name,group_df.shape) 上面代码中的将分组后的对象groups进行遍历，可以获取到group_name每个组的名字，group_df每个组的数据。 接下来我们自己在下面代码框中练习使用遍历的方法，计算出每一组中的最大年纪，最小年纪以及平均年龄。 此处是代码 ————————————— ——————————— 终端 现在一起来看一下小K的答案： import pandas as pd df = pd.read_excel('./data/forbes_2018.xlsx') groups = df.groupby('gender') for group_name,group_df in groups: f_mean = group_df['age'].mean() f_max = group_df['age'].max() f_min = group_df['age'].min() print('{}组的最大年龄是{}，最小年龄是{}，平均年龄是{}'.format(group_name,f_max,f_min,f_mean)) 1.1.4. 按多列进行分组 刚刚我们完成了将富豪以性别进行分组，并拿到了年龄的最大值和最小值以及平均值等信息。 现在我们完成一个相对复杂的需求，需要产看每个国家男女的富豪的数量。那就需要我们将富豪们先按国家分组，然后在按性别分组。 按照上面的分析，难道我们要写两次groupby的分组操作？NO，我们强大的groupby()方法是支持按照多列进行分组。 运行下面的代码，看下groupby()是如何进行多列分组的： 此处是代码 ————————————— ——————————— 终端 import pandas as pd df = pd.read_excel('./data/forbes_2018.xlsx') group=df.groupby(['country','gender']) df1 = group.size() print(df1) 当需要按多列进行分组的时候，groupby方法里面我们传入的一个列表，列表中分别存储分组依据的列名。 注意：列表中列名的顺序，确定了先按country列进行分组，然后再按gender列分组。不同的顺序，产生的分组名字是不同的。 group.size()返回的结果中发现索引值是多层的，那么对于多层索引的值我们如何去获取呢？ 此处是代码 ————————————— ——————————— 终端 import pandas as pd df = pd.read_excel('./data/forbes_2018.xlsx') group=df.groupby(['country','gender']) df1 = group.size() size = df1['Austria']['F'] print(size) 通过代码，我们发现对于多层索引值的获取，只需要从外往里一层一层的取就可以了，就像我们睡觉之前，需要先脱外衣再脱掉内衣是一样的&#x1F60A;。 1.1.5. 对分组后数据进行统计 数据统计（也称为数据聚合）是数据处理的最后一步，通常是要使每一个数组生成一个单一的数值。 上面我们已经了解了一些Pandas提供好的统计函数，例如:mean()、max()等函数。 为大家使用更为灵活，pandas提供了一个 agg( )方法用来对分组后的数据进行统计。 接下来我们来体验一下，agg()方法的使用： 此处是代码 ————————————— ——————————— 终端 import pandas as pd df = pd.read_excel('./data/forbes_2018.xlsx') groups = df.groupby('gender') for group_name,group_df in groups: f_se = group_df['age'].agg(['max','min','mean']) print('{}组的最大年龄是{}，最小年龄是{}，平均年龄是{}'.format(group_name,f_se[0],f_se[1],f_se[2])) 观察上面的代码，可以发现在使用agg()函数时，我们可以将多个统计函数一起放到一个agg()函数中。 并且需要注意的是，如果是统计函数是pandas提供的，我们只需将函数的名字以字符串的形势存储到列表中即可，例如：将max()改成'max'。 这样不仅简化了我们的代码，在添加和删减统计函数的时候我们只需更改agg()函数中list就可以了。是不是很方便。 它的好处还不止这些，比如现在又有新的需求，要计算年龄的最大值和最小值的差值。但是，pandas并没有提供这样统计函数，所以就需要我们进行自己定义一个统计函数： def peak_range(df): \"\"\" 返回数值范围 \"\"\" return df.max() - df.min() 现在我们看一下自己定义的统计函数，如何使用： 此处是代码 ————————————— ——————————— 终端 import pandas as pd df = pd.read_excel('./data/forbes_2018.xlsx') groups = df.groupby('gender') def peak_range(df): \"\"\" 返回数值范围 \"\"\" return df.max() - df.min() for group_name,group_df in groups: f_se = group_df['age'].agg(['max','min','mean',peak_range]) print(f_se[0],f_se[1],f_se[3]) peak_range(df)函数是我们自定的函数，并设置了一个df参数,为了接收group_df['age']的值。 注意：自定义的函数名字在传入agg()函数中时不需要转换成字符串。 1.1.6. 本节总结 本节我们通过groupby方法对数据进行分组以及根据多列进行分组，并且对分组后的数据进行统计。 1.1.7. 下节预告 1.1.8. 练习1：好色的不止是女人 题目：好色的不止是女人 题目要求： 本次练习采用的是网易考拉海淘网口红一天的销售数据。每条数据都包含了品牌、折扣价、原价、是否自营、评论数、国家共6列信息。 统计每种口红的平均折扣价。 分别统计每种口红自营评论数总和和非自营的评论数总和。 参考答案： import pandas as pd df = pd.read_excel('./data/lipsticks.xlsx') print(df.head()) # 1. 统计每种口红的平均折扣价。 # 根据品牌进行分类 groups = df.groupby('品牌') for group_name,group_df in groups: mean = group_df['折扣价'].mean() str_mean = '{}的平均折扣价为{}'.format(group_name,mean) print(str_mean) # 2. 分别统计每种口红自营评论数总和和非自营的评论数总和 # 根据品牌列和是否自营列进行分组 groups = df.groupby(['品牌','是否自营']) for group_name,group_df in groups: group_sum = group_df['评论数'].sum() str_sum = '{}{}的评论数为{}'.format(group_name[0],group_name[1],group_sum) print(str_sum) 1.1.9. 练习2: 那些年错过的电影 题目：那些年错过的电影 题目要求： 本次练习采用的是爱奇艺视频数据。共有6万多条电影数据，每条数据包含12列信息，文件的路径为./data/aiqiyi.xlsx，以下获取的前五条数据： 取出每年电影评分前两名电影的名字 哪一年的电影总评分最高 参考答案： import pandas as pd df = pd.read_excel('./data/aiqiyi.xlsx') groups = df.groupby('上映时间') for group_name,group_df in groups: result = group_df.sort_values(by='评分',ascending=False)[0:2] print(group_name,result['整理后剧名']) 第二个问题参考答案： import pandas as pd df = pd.read_excel('./data/aiqiyi.xlsx') groups = df.groupby('上映时间') year=groups.sum().sort_values(by='评分',ascending=False).index.to_list()[0] print(year) Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-25 15:57:05 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"第7课/python数据分析之多层索引.html":{"url":"第7课/python数据分析之多层索引.html","title":"多层索引","keywords":"","body":"1.1.1. 课程介绍1.1.2. 多层索引的创建1.1.3. 多层索引的取值1.1.4. 多层索引的排序1.1.5. 本节总结1.1.6. 下节预告1.1.7. 练习11.1.8. 练习21.1.1. 课程介绍 Hello, 我是小K，很高兴又和大家见面了，我们一起继续学习Python数据分析。 为了让你能不受干扰的在学习数据分析路上饱览胜景，请将屏幕调整成全屏，Windows系统：请按F11（或Fn+F11)；苹果系统：请同时按control+command+F。 多层索引是Pandas中一个比较核心的概念，允许你在一个轴向上拥有多个索引层级，许多同学不能处理复杂的数据，最大的问题在于没法灵活的处理多层索引。 看到这两个图的时候，我们不由自主的发出一声感叹：“这不就是对数据进行多列分组的结果吗？”。没错，groupby方法就可以生成带有多层级索引的结果。 本节我们将一起学习多层索引的相关内容。 1.1.2. 多层索引的创建 Series多层索引 我们根据下图学生期中和期末的成绩，演示Series多层索引的创建方法。 运行下方代码，创建上方数据，并观察index的内容： 此处是代码 ————————————— —————————— 终端 import pandas as pd s = pd.Series([1,2,3,4,5,6],index=[['张三','张三','李四','李四','王五','王五'], ['期中','期末','期中','期末','期中','期末']]) s 从图中数据可以看出，张三那一列是数据的第一层索引，期中那一列是数据的第二层索引，而第二层索引值是和数据一一对应的。 但是，我们在创建的时候发现，也需要将名字和考试阶段一一对应，才可以。 DataFrame多层索引 现在，我们将数据增加几个科目的成绩，演示DataFrame多层索引的创建方法。 由于成绩的数据比较多，我们将使用numpy的随机数方法构建成绩数据。 numpy会在后续的课程中讲解，现在大家先体验一下，如何使用numpy构建实验数据： import numpy as np data = np.random.randint(0,100,size=(6,3)) data import numpy as np是导入numpy并改名为np。 np.random.randint(0,100,size=(6,3))是使用numpy中的随机模块random中，生成随机整数方法randint，里面的参数size是指定生成6行3列的数据，并且每个数字的范围在0到100之间。 现在，我们知道了实验数据如何创建，下面我们根据Series的创建方法创建多层索引的DataFrame。 此处是代码 ————————————— —————————— 终端 import pandas as pd data = np.random.randint(0,100,size=(6,3)) df = pd.DataFrame(data,index=[['张三','张三','李四','李四','王五','王五'], ['期中','期末','期中','期末','期中','期末']], columns=['Java','Web','Python']) df 我们虽然成功的创建了DataFrame的多层索引，但是有一个问题，在设置索引的时候会有很多重复的索引值，如何才能简化索引的写法呢？ Pandas为了解决这个问题，提供了一个创建多层索引的构造方法。 pd.MultiIndex.from_product()构建索引的方式，对我们这些平凡的人来说会好理解一些。 首先，确定每一层索引的值什么，然后以列表的形势传给from_product()方法即可。 此处是代码 ————————————— —————————— 终端 import pandas as pd data = np.random.randint(0,100,size=(6,3)) names = ['张三','李四','王五'] exam = ['期中','期末'] index = pd.MultiIndex.from_product([names,exam]) df = pd.DataFrame(data,index=index,columns=['Java','Web','Python']) df 我们成功创建了DataFrame的多层索引，而且你会发现，我们只需要关注每层索引的值都有哪些就可以了。 混世宝典：[names,exam]列表中的位置不同，产生的索引也会不同。 运行下方代码，观察结果中索引变化： 此处是代码 ————————————— —————————— 终端 import pandas as pd data = np.random.randint(0,100,size=(6,3)) names = ['张三','李四','王五'] exam = ['期中','期末'] index = pd.MultiIndex.from_product([exam,names]) df = pd.DataFrame(data,index=index,columns=['Java','Web','Python']) df 经过上面的两段代码，你是否已经找到了规律，下面我们一起总结一下： 第一：from_product([exam,names])会将列表中第一个元素作为最外层索引，依次类推； 第二：列表中元素值的对应关系，如下图： 1.1.3. 多层索引的取值 创建不是我们的目的，我们的目的是如何从多层索引中获取到我们想要的数据。 多层级Series的取值 我们以下面代码为例： import pandas as pd s = pd.Series([1,2,3,4,5,6],index=[['张三','张三','李四','李四','王五','王五'], ['期中','期末','期中','期末','期中','期末']]) s 可以直接使用[]的方式取最外面的一个层级: s['张三'] 注意：[]取值方式，不可直接使用最外层以外的其他层级，例如：s['期末'] 使用[]的方式,获取某个数据: s['张三','期末'] 注意：['张三','期末']他们的顺序不能变。剥洋葱原则，从外到内一层一层的剥。 使用[]的切片，获取数据 s[:,'期中'] 分别复制上面的代码到代码框内运行，观察结果： 此处是代码 ————————————— —————————— 终端 大家是否还记得loc和iloc的使用呢？ loc使用的是标签索引，iloc使用的是位置索引。 loc的使用方式和[]的方式基本一样： s.loc['张三'] s.loc['张三','期中'] s.loc[:,'期中'] 但是，iloc的取值并不会受多层索引印象，只会根据数据的位置索引进行取值。 如上图所示，0~5分别为数据的位置索引 s.iloc[0] 分别复制上面的代码到代码框内运行，观察结果： 此处是代码 ————————————— —————————— 终端 DataFrame的取值 我们下方代码为例: import pandas as pd data = np.random.randint(0,100,size=(6,3)) names = ['张三','李四','王五'] exam = ['期中','期末'] index = pd.MultiIndex.from_product([names,exam]) df = pd.DataFrame(data,index=index,columns=['Java','Web','Python']) df 在对多层索引DataFrame的取值是，我们推荐使用loc()函数。 同时对一二级索引进行检索: df.loc['张三','期中'] df.loc['张三'].loc['期中'] df.loc[('张三','期中'),:] 上面的三种方式都可以获取张三期中各科成绩。 注意：DataFrame中对行索引的时候和Series有一个同样的注意点，就是无法直接对二级索引直接进行索引，必须让二级索引变成一级索引后才能对其进行索引！ 复制上面的代码到代码框内运行，观察结果： 此处是代码 ————————————— —————————— 终端 1.1.4. 多层索引的排序 有时候，我们需要将分组或创建出来的多层索引数据，根据索引值进行排序。 现在我们就需要明确默认是如何排序的？还有就是如何指定某一个索引列进行排序？ 为方便大家理解，我们先创建一个简单的多层索引数据： import pandas as pd data = np.random.randint(0,100,size=(9,3)) key1 = ['b','c','a'] key2 = [2,1,3] index = pd.MultiIndex.from_product([key1,key2]) df = pd.DataFrame(data,index=index,columns=['Java','Web','Python']) 创建的数据效果如下图： DataFrame按行索引排序的方法是sort_index()，接下来我们看一下sort_index()是如何对多层索引进行排序。 默认状态下的排序： df.sort_index() 为了方便大家理解，默认状态下的排序结果图如下： 通过结果可以看出每一层都会根据索引值进行相应的升序排列。 df.sort_index()中的level参数可以指定是否按照指定的层级进行排列，第一层级索引值为0，第二层级索引值为1。 当level=0时，会根据第一层索引值进行降序排序： df.sort_index(level=0,ascending=False) 通过结果可以看出每一层都会根据第一层索引值进行相应的降序排列。 当level=1时，会根据第二层索引值进行降序排序： df.sort_index(level=1,ascending=False) 通过结果可以看出数据会根据第二层索引值进行相应的降序排列，如果索引值相同时会根据其他层索引值排列。 通过上面的几个排序发现，可以通过level设置排序的索引层级，其他层索引也会根据其排序规则进行排序。 1.1.5. 本节总结 今天的内容就告一段落了，本节课我们学习了多层索引的创建、多层索引的取值（重点）以及多层索引的排序。 最后，我们来总结一下绘制这些图像的知识点： 1.1.6. 下节预告 1.1.7. 练习1 题目：留一线，为相见 题目要求： 本次练习我们使用2017中国城市分级名单数据，共有300多条电影数据，每条数据包含7列信息，文件的路径为./data/china_city_list.xlsx，以下是数据的基本详情： City: 城市中文名称缩写 City_FullName: 城市中文全称 City_EN: 城市英文名称 Province: 省中文名 Province_EN：省英文名 Region：区域划分（西、南、东、北） Tier：城市等级（一线、二线、三线、四线、五线） 根据上面的数据，计算出我国南部所有城市中一线城市的占比是多少？ 参考答案： import pandas as pd data = pd.read_excel('./data/china_city_list.xlsx') # 根据区域和等级分组 groups = data.groupby(by=['Region','Tier']) # 计算出所有区域内各个等级城市的数量 groups_count = groups.count() # 计算出南部所有等级城市的总数量 south_all_count = groups_count.loc['South']['City'].sum() # 南部所有城市中一线城市的数量 south_t1_count = groups_count.loc['South','Tier 1']['City'] # 计算一线城市的占比 accounted = south_t1_count/south_all_count print('南部所有城市中一线城市的占比是{}'.format(\"%.2f%%\" % (accounted * 100))) 1.1.8. 练习2 题目：带你浪漫中国行 题目要求： 本次练习我们继续使用2017中国城市分级名单数据，计算出我国各个区域内不同等级城市的占比是多少？ 参考答案： groups = data.groupby(by=['Region','Tier']) # 计算出所有区域内各个等级城市的数量 groups_count = groups.count() # 获取分组后的索引 index_list = groups_count.index.tolist() for value_tuple in index_list: # 区域内所有等级城市的总数量 all_count = groups_count.loc[value_tuple[0]]['City'].sum() # 区域内各个城市等级的数量 t_count = groups_count.loc[value_tuple[0],value_tuple[1]]['City'] accounted = \"%.2f%%\" % (t_count/all_count * 100) print('{}所有城市中{}城市的占比是{}'.format(value_tuple[0],value_tuple[1],accounted)) Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-23 12:31:42 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"第8课/时间序列.html":{"url":"第8课/时间序列.html","title":"时间序列","keywords":"","body":"1. 搭上时间分析的飞剑1.1.1. 课程介绍1.1.2. 日期和时间数据类型1.1.3. Pandas时间序列基础1.1.4. 本节总结1.1.5. 下节预告1.1.6. 练习11.1.7. 练习21. 搭上时间分析的飞剑 1.1.1. 课程介绍 Hello, 我是小K，很高兴又和大家见面了，我们一起继续学习Python数据分析。 为了让你能不受干扰的在学习数据分析路上饱览胜景，请将屏幕调整成全屏，Windows系统：请按F11（或Fn+F11)；苹果系统：请同时按control+command+F。 在金融、经济、物理学等领域，都需要在多个时间点观测或者测量数据，这样就产生了关于时间序列的数据。 时间序列数据（Time Series Data）是在不同时间上收集到的数据，这类数据是按时间顺序收集到的，用于描述现象随时间变化的情况。 学会如何对时间序列数据进行巧妙的处理非常重要，Pandas为我们提供了强大的时间序列数据处理的方法，本节小K将带你入门时间序列。 1.1.2. 日期和时间数据类型 Python标准库包含了日期和时间数据的数据类型，datetime模块是开始处理时间数据最广泛的。 datetime的日期和时间数据类型 下面我们先简单的了解下python日期和时间数据类型。 datetime是一个关于时间的库，常用的类有： 类型 说明 date 以公历形式存储日历日期（年、月、日） time 将时间存储为时、分、秒 datetime 存储日期和时间 下面我们一起看一下，datetime各个类型的创建和获取 日期(date)类型的使用： # 导入datetime模块 import datetime # 创建日期 date = datetime.date(2019, 9, 9) print(date) # 获取年 print(date.year) # 获取月 print(date.month) # 获取日 print(date.day) 时间(time)类型的使用: # 创建时间 import datetime time = datetime.time(13, 14, 20) print(time) # 获取小时 print(time.hour) # 获取分钟 print(time.minute) # 获取秒 print(time.second) 日期和时间的结合体--日期时间(datetime)： import datetime # 创建日期时间 datetime = datetime.datetime(2019, 9, 9, 13, 14, 20) print(datetime) # 获取年 print(datetime.year) # 获取月 print(datetime.month) # 获取日 print(datetime.day) # 获取小时 print(datetime.hour) # 获取分钟 print(datetime.minute) # 获取秒 print(datetime.second) datetime的time方法可以创建时间，date方法可以创建日期，datetime方法则是日期和时间的结合体。 同过year、month、day、hour、minute、second属性，可以获取到相应的日期或者时间的值。 同样，使用datetime.datetime.now()方法可以获取到当前时间： datetime.datetime.now() 请分别复制上面的代码到代码框中，体验datetime的神奇： 此处是代码 ————————————— —————————— 终端 现在我们知道如何使用datetime模块创建时间，但是有些时候我们可能需要将datetime类型转成字符串样式， 例如：将datetime.datetime(2019, 9, 9, 13, 14, 20)转换成2019-9-9 13:14:20样式的字符串。 datetime与字符串转换 有的同学会问道：“datetime.datetime(2019, 9, 9, 13, 14, 20)输出的的结果不就是2019-9-9 13:14:20吗？为什么还需要变？”。 没错，它的结果就是我们想要的样式，但是，需要注意的是它的类型是datetime，并不是str。 如果我们只是单一的想改变类型，就可以使用强制类型转换： 此处是代码 ————————————— —————————— 终端 import datetime date_time = datetime.datetime(2019, 9, 9, 13, 14, 20) print(type(date_time)) str_date_time = str(date_time) print(str_date_time) print(type(str_date_time)) 但是，小K想提一个需求：将datetime.datetime(2019, 9, 9, 13, 14, 20)转换成9/9/2019 13:14样式的字符串。 莫慌，使用strftime()方法便可破解此需求。 此处是代码 ————————————— —————————— 终端 import datetime date_time = datetime.datetime(2019, 9, 9, 13, 14, 20) str_time = date_time.strftime('%m/%d/%Y %H:%M') str_time strftime()方法的作用是将时间格式转化为自定义字符串格式，格式可以完全自定义。 %m/%d/%Y %H:%M就是格式化以后的样式，%m、%d等是时间格式化占位符。 关于时间格式的汇总： 利用这些格式符，我们就可以随意的破解将datetime转化成str这类的要求。 磨人的小K的第二个需求来了，请将str类型转化成datetime类型。 例如：将字符串类型的Aug-23-19 20:13转化成2019-08-23 20:13:00样式的datetime类型。 同理，使用strptime()方法便可破解此需求。 此处是代码 ————————————— —————————— 终端 import datetime strp = datetime.datetime.strptime('Aug-23-19 20:13', '%b-%d-%y %H:%M') print(strp) strptime()方法的作用是字符串时间转化为datetime格式，需要注意的是按一定的格式输出时间。 例如：第二个参数不可写成%B-%d-%Y %H:%M ，或者%b / %d / %Y %H:%M 1.1.3. Pandas时间序列基础 前面我们了解了Python内置的datetime模块对时间和日期的处理方法，接下来我们看一下Pandas处理时间上有哪些方法。 创建一个时间范围 使用Pandas的date_range()方法可以快速创建出一个日期范围。 pd.date_range(start=None,end=None,periods=None,freq=\"D\") start:日期范围的开始 end:日期范围的结束 periods:固定日期的个数 freq:日期偏移量，取值为string, 默认为'D'，即：一天为日期偏移量 接下来，我们看一下date_range()的几种使用方式。 使用start和end以及默认的freq参数创建： date= pd.date_range(start='20190505',end='20190606') 使用start和end以及频率参数freq为10天创建： date= pd.date_range(start='20190505',end='20190606',freq=\"10D\") 使用start和periods以及默认的频率参数创建： date= pd.date_range(start='20190505',periods=10,freq=\"D\") 分别复制上面的带码到代码框运行，观察结果： 此处是代码 ————————————— —————————— 终端 import pandas as pd 根据上面的运行结果可以得出以下结论： start和end以及freq配合能够生成start和end范围内以频率freq的一组时间索引。 start和periods以及freq配合能够生成从start开始的频率为freq的periods个时间索引。 上面我们提到时间索引，是因为date_range()方法生成的对象类型是DatetimeIndex，这个类型就是pandas中的时间索引类型。 关于频率的更多缩写： 别名 说明 D 日历日的每天 B 工作日的每天 H 每小时 T或min 每分钟 S 每秒 L或ms 每毫秒 U 每微秒 M 日历日的月底日期 BM 工作日的月底日期 MS 日历日的月初日期 BMS 工作日的月初日期 在数据中索引和切片时间序列数据 有时候我们会对一天或者一个月的数据进行分析，这就需要我们将时间设置成数据的索引，然后通过时间索引获取到一定时间范围内的数据进行分析。 现在我们创建一个以时间序列为索引的Series数据。 首先，使用pd.date_range()来创建从2019-01-01开始的时间索引： import pandas as pd time_index = pd.date_range('2019-01-01', periods=365) 然后，使用numpy的随机数创建365个随机整数： import numpy as np time_data = np.random.randint(100,size=365) 最后，创建出以时间序列为索引的Series数据，运行下方代码，产看数据： 此处是代码 ————————————— —————————— 终端 import pandas as pd import numpy as np time_index = pd.date_range('2019-01-01', periods=400) time_data = np.random.randint(100,size=400) date_time = pd.Series(data=time_data,index=time_index) date_time 现在已经成功创建出数据，并将时间索引值设置成数据的索引项，接下来的重点是如何根据时间序列索引获取数据呢？ 可以依据年份进行索引： date_time['2020'] 可以依据年和月进行索引： date_time['2019-10'] 可以使用时间戳进行切片获取数据 date_time['2019-10-05':'2019-10-10'] 分别复制上面的代码，查看运行结果： 此处是代码 ————————————— —————————— 终端 通过上面的三行代码，大家会发现我们在获取数据的时候可以直接使用字符串的形势获取以及切片操作。 to_datetime改变时间格式 有的时候用csv导入到时间数据时，默认的是字符串的数据类型 ，当可视化的时候，会出现没有按时间先后顺序的方式绘图 ，所以需要将字符串解析为时间类型的数据类型。 使用Pandas的to_datetime()方法可以将字符串形式的日期转换成时间格式。 pd.to_datetime(arg,format=None) arg：需要修改的数据 format：数据的格式 to_datetime()方法会将字符串类型的是时间转换成Timestamp('2019-10-05 00:00:00')时间戳类型。 pd.to_datetime('2019-10-05') 如果想对时间格式修改，还可以使用to_pydatetime()方法将Timestamp类型转换成datetime类型。 pd.to_datetime('2019-10-05').to_pydatetime() 需要注意的是字符串日期中包含中文，我们可以这样处理： pd.to_datetime('2019年10月10日',format='%Y年%m月%d日') 请抄写上面代码到代码框，并运行。 此处是代码 ————————————— —————————— 终端 1.1.4. 本节总结 本节我们一起学习了日期和时间数据类型的创建以及Pandas对时间序列的处理。 最后，我们来总结一下本节课的知识点： 1.1.5. 下节预告 1.1.6. 练习1 题目：销售额的华山论剑 题目要求： 现在我们有一份某电商超市从2016年到2019年的部分销售数据，路径为：./data/Commerce.xls 我们的字段有订单 ID，客户对象，订单日期，邮寄方式，地区，地区经理，销售额，数量，退回，折扣等，在这些字段下面，一共有近一万条数据。 请根据数据完成下面的需求： 分别算出2016年到2019年，每年5月份的总销售额。 2018年各地区的5月份的总销售额对比。 参考答案： import pandas as pd data = pd.read_excel('./data/Commerce.xls') # 了解数据基本情况 # data.head() # 将订单日期设置为数据的索引 data.index = data['订单日期'] # 分别计算每年5月份的销售额 sales16 = data['2016-05']['销售额'].sum() sales17 = data['2017-05']['销售额'].sum() sales18 = data['2018-05']['销售额'].sum() sales19 = data['2019-05']['销售额'].sum() # 获取2018年五月份数据 sales18 = data['2018-05'] # 根据地区分组 groups = sales18.groupby('地区') # 分别计算各地区销售总额 for group_name,group_df in groups: sales_all = group_df['销售额'].sum() print('{}地区5月份总销售额是{}'.format(group_name,sales_all)) 1.1.7. 练习2 题目：天外飞仙，各显神通 题目要求： 本练习继续使用某电商超市从2016年到2019年的部分销售数据，路径为：./data/Commerce.xls。 计算出2018年各个季度的总销售额（1-3月为第一季度，4-6为第二季度，7-9为第三季度，10-12为第四季度）。 计算出2018年各季度各地区的总销售额。 参考答案： import pandas as pd data = pd.read_excel('./data/Commerce.xls') # 将订单日期设置为数据的索引 data.index = data['订单日期'] # 根据本节课知识点，分别获取每个季度销售总额 Q1 = data['2018-01':'2018-03']['销售额'].sum() Q2 = data['2018-04':'2018-06']['销售额'].sum() Q3 = data['2018-07':'2018-09']['销售额'].sum() Q4 = data['2018-10':'2018-12']['销售额'].sum() print('2018年Q1总销售额{},Q2总销售额{},Q3总销售额{},Q4总销售额{}'.format(Q1,Q2,Q3,Q4)) # 2018年各季度各地区的总销售额 # 获取每个季度的数据 Q1_area = data['2018-01':'2018-03'].groupby('地区')['销售额'].sum() Q2_area = data['2018-04':'2018-06'].groupby('地区')['销售额'].sum() Q3_area = data['2018-07':'2018-09'].groupby('地区')['销售额'].sum() Q4_area = data['2018-10':'2018-12'].groupby('地区')['销售额'].sum() print(\"\"\" 2018年各季度各地区的总销售额: Q1:{} Q2:{} Q3:{} Q4:{} \"\"\".format(Q1_area,Q2_area,Q3_area,Q4_area)) Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-25 15:57:22 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"第9课/":{"url":"第9课/","title":"Matplotlib","keywords":"","body":"1. Matplotlib1. Matplotlib Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-23 12:26:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"第9课/python数据分析第九课.html":{"url":"第9课/python数据分析第九课.html","title":"Matplotlib常见图形种类及意义","keywords":"","body":"1.1. 用Matplotlib让数据复活1.1.1. 课程介绍1.1.2. Matplotlib是什么1.1.3. 常见图形种类及意义1.1.4. 认识Matplotlib图像结构1.1.5. 折线图初体验1.1.6. 本节总结1.1.7. 下节预告1.1.8. 练习1:一起来画龙1.1.9. 练习2：下一个股神可能就是你1.1. 用Matplotlib让数据复活 1.1.1. 课程介绍 Hello, 我是小K，很高兴又和大家见面了，我们一起继续学习Python数据分析。 为了让你能不受干扰的在学习数据分析路上饱览胜景，请将屏幕调整成全屏，Windows系统：请按F11（或Fn+F11)；苹果系统：请同时按control+command+F。 前面我们已经学习了如何使用Python对数据做简单的处理，例如，删除空值以及数据的合并等技能。让之前的脏数据变得相对干净了，从而准确的挖掘出数据中隐藏的信息，使公司或者企业做出进一步的战略部署。 俗话说：“文不如表，表不如图”，如果我们将海量的数据绘制成图，就可以让我们的数据更加直观的呈现，更具说服力。 在“互联网+时代”，90%的信息传到大脑，其实都是通过视觉形式来传过来的，而且可视化信息被人脑接受的速度比文字信息要快6万倍，所以，将海量的数据转换成可视化的图形是我们数据分析师必备技能。 这节课我们就来一起学习Python展示数据信息的方法。 1.1.2. Matplotlib是什么 Matplotlib是一个Python 2D绘图库，它可以在各种平台上以各种硬拷贝格式和交互式环境生成出具有出版品质的图形。 Matplotlib试图让简单的事情变得更简单，让无法实现的事情变得可能实现。也是Python中最常用的可视化工具之一，它的功能非常强大，可以通过调用函数轻松方便地绘制数据分析中常见的各种图像，比如折线图、条形图、柱状图、散点图、饼图等。 1.1.3. 常见图形种类及意义 选择最重要，一个选择和另一个选择结果可能会有天壤之别。在我们将数据的可视化之前，同样也需要根据图形的特点来选择绘制数据的图形，从而让我们快速发现数据的特点。 接下来，我们一起了解一下Matplotlib常见图形种类及意义。 折线图：以折线的上升或下降来表示统计数量的增减变化的统计图 ​ 特点：能够显示数据的变化趋势，反映事物的变化情况。(变化) 散点图：用两组数据构成多个坐标点，考察坐标点的分布,判断两变量之间是否存在某种关联或总结坐标点的分布模式。 特点：判断变量之间是否存在数量关联趋势,展示离群点(分布规律) 柱状图：排列在工作表的列或行中的数据可以绘制到柱状图中。 特点：绘制离散的数据,能够一眼看出各个数据的大小,比较数据之间的差别。(统计/对比) 直方图：由一系列高度不等的纵向条纹或线段表示数据分布的情况。 一般用横轴表示数据范围，纵轴表示分布情况。 特点：绘制连续性的数据展示一组或者多组数据的分布状况(统计) 饼图：用于表示不同分类的占比情况，通过弧度大小来对比各种分类。 特点：分类数据的占比情况(占比) 当然，除了这些常用图之外，matplotlib还可以绘制一些其它的图像，那么，这些图究竟是如何绘制的呢？ 1.1.4. 认识Matplotlib图像结构 其实想要学好用好Matplotlib是特别简单的，前提就是要必须清楚的了解Matplotlib图像组成。 先来看一下Matplotlib的图像的结构图： 通常情况下，我们可以将一张Matplotlib图像分成三层结构： 第一层是底层的容器层，主要包括Canvas、Figure、Axes； 第二层是辅助显示层，主要包括axis、spines、grid、legend、title等； 第三层为图像层，即通过plot、scatter等方法绘制的图像。 容器层 容器层主要由Canvas、Figure、Axes组成。 Canvas是位于最底层的系统层，在绘图的过程中充当画板的角色，即放置画布(Figure)的工具，用户一般接触不到。 Figure是Canvas上方的第一层，也是需要用户来操作的应用层的第一层，在绘图的过程中充当画布的角色，我们可以设置画布的大小和分辨率等。 Axes是应用层的第二层，在绘图的过程中相当于画布上的绘图区的角色。一个Figure对象可以包含多个Axes对象，每个Axes都是一个独立的坐标系，绘图过程中的所有图像都是基于坐标系绘制的。 辅助显示层 辅助显示层为Axes(绘图区)内的除了根据数据绘制出的图像以外的内容，主要包括Axes外观(facecolor)、边框线(spines)、坐标轴(axis)、坐标轴名称(axis label)、坐标轴刻度(tick)、坐标轴刻度标签(tick label)、网格线(grid)、图例(legend)、标题(title)等内容。 该层的设置可使图像显示更加直观更加容易被用户理解，但又不会对图像产生实质的影响。 图像层 图像层指Axes内通过plot、scatter、bar、histogram、pie等函数根据数据绘制出的图像。 根据上面对Matplotlib的结构的拆分了解后，我们可以做出以下总结： Canvas（画板）位于最底层，用户一般接触不到 Figure（画布）建立在Canvas之上 Axes（绘图区）建立在Figure之上 坐标轴（axis）、图例（legend）等辅助显示层以及图像层都是建立在Axes之上 1.1.5. 折线图初体验 上面我们已经了解了Matplotlib的结构，下面我们就来一起体验一下绘制折线图的过程。 跟Pandas的使用一样，使用matplotlib之前，我们需要将它的模块，因为我们是使用Matplotlib的pyplot模块进行图形绘制，所以我们要导入pyplot模块。 from matplotlib import pyplot as plt 我们从matplotlib包中导入了pyplot模块并将其改名为plt，编写代码时，直接使用plt调用方法即可。 绘制折线图 下面我们绘制一个简单的折线图，运行下面的代码，观察图形的生成： 此处是代码 ————————————— —————————— 终端 from matplotlib import pyplot as plt x = range(1,8) y = [17, 17, 18, 15, 11, 11, 13] plt.plot(x,y) plt.show() 恭喜你，成功的画出第一张简单的折线图，我们一起来看一看代码的含义： 绘制二维图形需要确定x、y值：图形中点的值（x， y值的个数要相同）。 plt.plot(x,y)：根据传过来的x，y值进行绘制折线图。 plt.show()：显示绘制的图形。 折线的常用属性 从图片上可以看出，X轴和Y轴的刻度都是默认生成的，这个是可以自己定义的，后面的课程我们会具体讲解。还有一个问题就是折线的颜色、折点以及宽度该怎么设置呢？ 请点击运行，观察图形的变化： 此处是代码 ————————————— —————————— 终端 from matplotlib import pyplot as plt x = range(1,8) y = [17, 17, 18, 15, 11, 11, 13] plt.plot(x, y, color='green',alpha=0.5,linestyle='-',linewidth=3,marker='o') plt.show() 完美运行后，请仔细阅读该代码的解释： color='green'：设置线的颜色； alpha=0.5：设置线的透明度，让其拥有似漏非漏的感觉； linestyle='—'：设置线的样式，- 实线(solid)、-- 短线(dashed)、-. 短点相间线(dashdot)、：虚点线(dotted) linewidth=3：设置线的宽度。 marker='o'：设置折点的样式，默认是什么都没有，折点有没有其他的样式呢？当然，向下看。 设置标题 对一个图形最重要的是内容的绘制，其次就是标题，我们需要让其他人清楚这张图的含义是什么，图中x轴表示什么，y轴表示什么，这个时候我们就需要为图像添加一些标题。 这些标题信息就需要我们在绘制的时候，将标题信息绘制在图片上，运行下面的代码，我们一起看一下如何添加标题： 此处是代码 ————————————— —————————— 终端 from matplotlib import pyplot as plt x = range(1,8) y = [17, 17, 18, 15, 11, 11, 13] plt.plot(x, y, color='green',alpha=0.5,linestyle='-',linewidth=3,marker='o') plt.xlabel('Time') plt.ylabel(\"Temp\") plt.title('Title') plt.show() 结果我们发现，通过plt.xlabel('Time')、plt.ylabel(\"Temp\")、plt.title('Title')三个方法，将x轴标题，y轴标题以及图片标题成功添加上了，这样就可以清晰明了地看出图片及每个轴的含义。 1.1.6. 本节总结 今天的内容就告一段落了，在今天的课程中，我们学习了Matplotlib是什么、常见图形种类和意义以及Matplotlib图像结构等。最后，我们把本关的知识点总结一下： 1.1.7. 下节预告 1.1.8. 练习1:一起来画龙 题目：一起来画龙 题目要求： 本次练习我们使用上节课的爱奇艺视频数据，共有6万多条电影数据，每条数据包含12列信息，文件的路径为./data/aiqiyi.xlsx，以下获取的前五条数据： 现在我们需要画出电影产量与年份的趋势图。 思路： 根据年份将电影数据分组； 分别计算每年的电影数量； 根据电影年份和数量画出折线图。 参考答案： import pandas as pd from matplotlib import pyplot as plt df = pd.read_excel('./data/aiqiyi.xlsx') # 根据上映时间分组 groups = df.groupby('上映时间') # 根据评分获取出年份和数量的Series num_series = groups['评分'].count() # 获取出年份列表 year_list= num_series.index.tolist() # 获取出数量列表 num_list= num_series.values.tolist() # 绘制折线 plt.plot(year_list,num_list) plt.xlabel('year') plt.ylabel(\"Number\") plt.title('Number/year') plt.show() 1.1.9. 练习2：下一个股神可能就是你 题目：下一个股神可能就是你 题目要求： 本次练习我们使用的是上海证券交易所A股股票日线数据，我们从中选取了某公司2016全年股票信息。共有106条数据，每条数据包含13列信息，文件的路径为./data/600001SH.xlsx，以下获取的前五条数据： 根据数据绘制出2015全年的开盘价折线图。 需要思考的问题： 标题设置中文 X轴数据重合 在一个坐标系中画多个折线 这个些问题我们将在下节课中解决！大家提前思考一下。 参考答案： import pandas as pd from matplotlib import pyplot as plt df = pd.read_excel('./data/600001SH.xlsx') x = df['日期'].values.tolist() y = df['开盘价(元)'].values.tolist() plt.plot(x,y) plt.xlabel('Time') plt.ylabel(\"¥\") plt.title('open/Time') plt.show() Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-25 15:57:43 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"第10课/python数据分析第十课.html":{"url":"第10课/python数据分析第十课.html","title":"中文显示、自定义x轴刻度、一图多线、创建子图","keywords":"","body":"1. 给图像加点料1.1.1. 课程介绍1.1.2. 中文显示1.1.3. 自定义X轴刻度1.1.4. 一图多线1.1.5. 一图多个坐标系子图1.1.6. 本节总结1.1.7. 下节预告1.1.8. 练习1：1.1.9. 练习2：1. 给图像加点料 1.1.1. 课程介绍 Hello, 我是小K，很高兴又和大家见面了，我们一起继续学习Python数据分析。 为了让你能不受干扰的在学习数据分析路上饱览胜景，请将屏幕调整成全屏，Windows系统：请按F11（或Fn+F11)；苹果系统：请同时按control+command+F。 上一节我们学习了Matplotlib的图形结构、常见图形种类和特点以及折线图的绘制流程，同时，在我们做课后练习的时候也发现了问题，例如：X轴、Y轴的刻度自定义，还有一个坐标系中绘制多个折线等问题。 这节课就让我们一起来解决这些问题。 1.1.2. 中文显示 相信大家在练习的时候也遇到过这样的问题，使用Matplotlib画的图居然不显示中文，作为中华儿女，真是气死我也。 实际上，matplotlib是支持unicode编码的，中文乱码的主要问题是没有找到合适的中文字体。 如果想要Matplotlib显示中文我们可以使用三种方法： 第一种：直接修改Matplotlib配置文件matplotlibrc 第二种：动态修改配置 第三种：设置自定义字体 本节课我们将讲解第三种方法，因为自定义的字体自由度比较高，同时也方便我们在一个图中使用不同风格的字体。 首先，我们下载了一个字体文件，文件的存储路径为./data/STSONG.TTF。 在给图片设置中文显示之前我们应该先添加下面的代码： from matplotlib import font_manager my_font = font_manager.FontProperties(fname='./data/STSONG.TTF') from matplotlib import font_manager导入字体管理模块，font_manager.FontProperties()使用这个方法根据我提供的字体文件创建字体对象。 当需要有中文显示的地方，添加字体属性就可以了。 接下来我们通过一个代码来看一下，如何添加中文字体，运行下方代码： 此处是代码 ————————————— —————————— 终端 from matplotlib import pyplot as plt from matplotlib import font_manager import random # 创建字体对象 my_font = font_manager.FontProperties(fname='./data/STSONG.TTF',size=18) x = range(0,120) y = [random.randint(10,30) for i in range(120)] # 添加字体属性 plt.ylabel(\"次数\",fontproperties=my_font) plt.xlabel(\"时间\",fontproperties=my_font) # 设置标题 plt.title('每分钟跳动次数',fontproperties=my_font) plt.plot(x,y) plt.show() 从展示的图片发现我们已经成功的将中文添加上了，首先我们创建了一个字体对象，然后在需要添加中文的地方添加了fontproperties属性，只需两步就成功的将中文字体添加上了 。 当然，我们在所有需要中文的地方添加的都是同一种字体，我们可以根据需求创建更多的字体对象，还可以通过size属性设置字体的大小，这样就可以让我们的图像中文显示的更加多样化。 1.1.3. 自定义X轴刻度 在上一节的第二个练习中，我们发现一个问题，x轴的刻度值全都重叠在一起了。 造成这个问题的原因是： 刻度的文字过长，但是图片的宽度不够。 x轴和y轴刻度会默认根据x值和y值生成，并且Matplotlib默认会生成它认为合适的刻度间距。 现在，我们先看看通过改变图片的大小能否解决重叠的问题。 要想改变图像的大小，我们需要更改画布的大小来实现，matplotlib 中设置图形大小的语句如下： plt.figure(figsize=(a, b), dpi=dpi) 其中： figsize 设置图形的大小，a 为图形的宽， b 为图形的高，单位为英寸 dpi 为设置图形每英寸的点数，即每英寸多少个像素 下来我们试着改变图形的宽和高，看看效果： 此处是代码 ————————————— —————————— 终端 import pandas as pd from matplotlib import pyplot as plt df = pd.read_excel('./data/600001SH.xlsx') df.head() x = df['日期'].values.tolist() y = df['开盘价(元)'].values.tolist() plt.figure(figsize=(20, 10),dpi=80) plt.plot(x,y) plt.xlabel('Time') plt.ylabel(\"¥\") plt.title('open/Time') plt.show() 我们将图形的宽和高分别设置为20，10英寸，分辨率设置为80后发现，x轴的重叠的效果减轻一些，但还是会有严重的重叠。 那我们是不是还要继续修改宽和高呢，答案肯定是No，如果继续放大，图形会变的很大，不是我们想要的效果，所以，并不是所有的刻度问题我们都可以使用改变图片的大小来解决。 如果x轴的刻度我们能自己设置，岂不是完美了，我们可以根据自己的想法，对x轴刻度的疏密程度和刻度值进行设置。 前面我们学习x轴的标题是使用plt.xlabel()这个方法，接下来我要使用plt.xticks()这个方法自定义x轴的刻度，赶快拿出小本本记上笔记，千万不要把两个方法记混哦。 xticks(locs, [labels], **kwargs) locs参数为数组参数，表示x-axis的刻度线显示标注的地方，即ticks放置的地方，第二个参数也为数组参数，表示在locs数组表示的位置添加的标签。 运行下面的代码，看看如何自定义x轴的刻度和刻度值： 此处是代码 ————————————— —————————— 终端 import pandas as pd from matplotlib import pyplot as plt df = pd.read_excel('./data/600001SH.xlsx') df.head() x = df['日期'].values.tolist() y = df['开盘价(元)'].values.tolist() plt.figure(figsize=(20, 10),dpi=80) plt.plot(x,y) plt.xlabel('Time') plt.ylabel(\"¥\") plt.title('open/Time') # 自定义x轴刻度显示 plt.xticks(range(0,len(x),3),x[::3],rotation=45) plt.show() 我们把结果拿过来，对照图片一起分析代码的逻辑。 range(0,len(x),3)为xticks()的第一个参数，根据x值的个数调整x轴的刻度疏密程度。 x[::3]为xticks()的第二个参数，还是使用x的值作为刻度的标签值，但是这里获取了其中的一部分，确保第一个参数和第二个参数的个数相同。 rotation=45默认刻度的值是横向书写的，这样会有一定的重叠，所以我们将文字进行旋转操作，45位旋转的度数。 通过上面的设置我们就可以轻松的对x轴刻度进行疏密调整，以及对应的刻度标签的设置。 1.1.4. 一图多线 通过以上学习，我们知道了如何自定义坐标轴的刻度。现在又提出一个需求，就是在上图中同时绘制出开盘价和收盘价。 我们知道绘制一个折线的方法是plt.plot()方法，所以，我们可以猜想一个画布上绘制两条折线，是不是使用两次plt.plot()方法就可以了呢？运行下方代码，验证我们的猜想： 此处是代码 ————————————— —————————— 终端 import pandas as pd from matplotlib import pyplot as plt df = pd.read_excel('./data/600001SH.xlsx') df.head() x = df['日期'].values.tolist() y = df['开盘价(元)'].values.tolist() z = df['收盘价(元)'].values.tolist() plt.figure(figsize=(20, 10),dpi=80) # 绘制开盘价折线 plt.plot(x,y) # 绘制收盘价折线 plt.plot(x,z) plt.xlabel('Time') plt.ylabel(\"¥\") plt.title('open/Time') plt.xticks(range(0,len(x),3),x[::3],rotation=45) plt.show() 哇塞，居然真的是这样的，一个坐标系中绘制两条折线，只需要使用两次plt.plot()方法就可以了。 但是，通过图形大家有没有发现，我们并不知道哪条线是开盘价哪条线是收盘价，所以，我们应该在图像中添加对应的图例，从而标明每条线的作用是什么。 plt.legend()方法就是图形添加图例的方法，但是这个方法比较特殊，一共需要两步才能成功的添加上图例，我们先运行下放代码，看一下图例的效果： 此处是代码 ————————————— —————————— 终端 import pandas as pd from matplotlib import pyplot as plt from matplotlib import font_manager my_font = font_manager.FontProperties(fname='./data/STSONG.TTF') df = pd.read_excel('./data/600001SH.xlsx') x = df['日期'].values.tolist() y = df['开盘价(元)'].values.tolist() z = df['收盘价(元)'].values.tolist() plt.figure(figsize=(20, 10),dpi=80) plt.plot(x,y,label='开盘价') plt.plot(x,z,label='收盘价') plt.xlabel('Time') plt.ylabel(\"¥\") plt.title('open/Time') # 添加图例 plt.legend(prop=my_font) plt.xticks(range(0,len(x),3),x[::3],rotation=45) #alpha=0.4 设置透明度 plt.grid(alpha=0.4) plt.show() 通过结果发现，在图形的右上角我们成功的添加上了图例。接下来，我们一起分析一下家图例的流程。 plt.legend(prop=my_font)是添加图例的方法，prop=my_font参数是设置图例上中文显示的属性，另外一个比较重要的是，图例上显示的文字我们需要添加在plt.plot(x,y,label='开盘价')方法的label属性中。 细心的同学会发现，结果中我们不仅添加上了图例，在图形中我们发现了很多网格。 没错，代码中小k添加这这样一行代码plt.grid(alpha=0.4)，这行代码就是添加网格的效果，这里面的alpha=0.4是设置网格线的透明度，范围是（0~1）。 绘制网格的作用就是为了辅助我们更好的观察数据的x值和y值。 1.1.5. 一图多个坐标系子图 我们上面的学习都是在一个画布上创建一个坐标系，在上节课中我们介绍到一个画布上是可以分成多个区域，每个区域都可以绘制一个图像，这里的每个图像称为一个子图。 调用plt.subplot()函数就可以在画布上创建一个子图，plt.subplot()的使用方法如下： plt.subplot(nrows, ncols, index) 函数的 nrows 参数指定将数据图区域分成多少行；ncols 参数指定将数据图区域分成多少列；index 参数指定获取第几个区域。 Axes1、Axes2、Axes3、Axes4分别代表四个区域。 运行下方代码，根据代码加深对子图的理解和绘图的方式： 此处是代码 ————————————— —————————— 终端 from matplotlib import pyplot as plt import numpy as np x = [1,10,14,15,16,17] y = np.array([3,4,6,2,1,5]) plt.figure(figsize = (10,8)) # 第一个子图 # 折线图 plt.subplot(2, 2, 1) plt.plot(y) plt.title('Axes1') #第二个子图 # 折线图，y轴每个数据的立方 plt.subplot(2, 2, 2) plt.plot(y**3) plt.title('Axes2') #第三个子图 # 折线图，x轴和y轴均指定数据 plt.subplot(2, 2, 3) plt.plot(x,y) plt.title('Axes3') plt.show() 上面我们创建一个包含2行2列，共4个子图。第一个子图的创建方法是plt.subplot(2, 2, 1)，第二个子图就使用：plt.subplot(2, 2, 2)，以此类推。 1.1.6. 本节总结 今天的内容就告一段落了，在今天的课程中，我们学习了图形的中文显示、坐标轴刻度的自定义、一图多线以及一图多个坐标系等。最后，我们把本关的知识点总结一下： 1.1.7. 下节预告 1.1.8. 练习1： 题目：人生苦短，你还在浪吗？ 题目要求： 假设大家在30岁的时候，根据自己的实际情况，统计出来你和你同事各自从11岁到30岁每年交的男/女朋友的数量如列表y1和y2，请在一个图中绘制出该数据的折线图，从而分析每年交朋友的数量走势。 y1 = [1,0,1,1,2,4,3,4,4,5,6,5,4,3,3,1,1,1,1,1] y2 = [1,0,3,1,2,2,3,4,3,2,1,2,1,1,1,1,1,1,1,1] 参考答案： import pandas as pd from matplotlib import pyplot as plt my_font = font_manager.FontProperties(fname='./data/STSONG.TTF') y1 = [1,0,1,1,2,4,3,4,4,5,6,5,4,3,3,1,1,1,1,1] y2 = [1,0,3,1,2,2,3,4,3,2,1,2,1,1,1,1,1,1,1,1] x = range(11,31) # 设置图形 plt.figure(figsize=(20,8),dpi=80) plt.plot(x,y1,color='red',label='自己') plt.plot(x,y2,color='blue',label='同事') # 设置x轴刻度 xtick_labels = ['{}岁'.format(i) for i in x] plt.xticks(x,xtick_labels,fontproperties=my_font,rotation=45) plt.grid(alpha=0.4) plt.legend(prop=my_font) plt.show() 1.1.9. 练习2： 题目：你还记得哪些数学公式？ 题目要求： 数据可视化的时候，常常需要将多个子图放在同一个画板上进行比较，那我们就来练习一下，在同一个画板上画出你还记得的数学函数图形。例如：x的平方、x的立方、以及平方根等。 参考答案： import pandas as pd from matplotlib import pyplot as plt import math x = range(0,10) y1 = [i**2 for i in range(0,10)] y2 = [i**3 for i in range(0,10)] y3 = [i**0.5 for i in range(0,10)] plt.figure(figsize = (10,8)) # 第一个子图 # 平方图 plt.subplot(2, 2, 1) plt.plot(x,y1) #第二个子图 # 立方图 plt.subplot(2, 2, 2) plt.plot(x,y2) #第三个子图 # 平方根图 plt.subplot(2, 2, 3) plt.plot(x,y3) plt.show() Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-25 15:57:12 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"第11课/python数据分析第十一节.html":{"url":"第11课/python数据分析第十一节.html","title":"常见图形的绘制","keywords":"","body":"1.1.1. 课程介绍1.1.2. 柱状图1.1.3. 直方图1.1.4. 散点图1.1.5. 饼图1.1.6. 本节总结1.1.7. 练习11.1.8. 练习2题目：常见图像的绘制（乱花渐欲迷人眼） 1.1.1. 课程介绍 Hello, 我是小K，很高兴又和大家见面了，我们一起继续学习Python数据分析。 为了让你能不受干扰的在学习数据分析路上饱览胜景，请将屏幕调整成全屏，Windows系统：请按F11（或Fn+F11)；苹果系统：请同时按control+command+F。 上一节我们在折线图的基础上实现了给图像设置中文显示，自定义X轴刻度以及子图的创建等知识点。 在今天的课程中我将一起学习其他常见图像的绘制。 1.1.2. 柱状图 柱状图适用场合是二维数据集（每个数据点包括两个值x和y），但只有一个维度需要比较。例如：年销售额就是二维数据，”年份”和”销售额”就是它的两个维度，但只需要比较”销售额”这一个维度。 柱状图利用柱子的高度，反映数据的差异。肉眼对高度差异很敏感，辨识效果非常好。 我们使用的是电影票房数据，数据的参考链接为http://58921.com/alltime，我们随机从中选取了6个数据，并将电影的名字和总票房数作为实践数据。 x = ['流浪地球','疯狂的外星人','飞驰人生','大黄蜂','熊出没·原始时代','新喜剧之王'] y = [38.13,19.85,14.89,11.36,6.47,5.93] 现在，需要绘制一张柱形图，用来描述每个电影的票房总数之间的对比。下面，我们就来一起体验一下这张图是如何绘制的。 经过前面的学习，我们知道绘制折线图使用plt.plot()方法，而绘制柱形图我们使用plt.bar()函数： plt.bar(x,height,width,color) 先来了解一下函数的常用参数： x：记录x轴上的标签； height：记录每个柱形的高度； width：设置柱形的宽度； color：设置柱形的颜色，传入颜色值的列表，例如：['blue','green','red']。 根据上面的数据和方法，我们尝试一下绘制出柱状图： 此处是代码 ————————————— ——————————— 终端 from matplotlib import pyplot as plt from matplotlib import font_manager a = ['流浪地球','疯狂的外星人','飞驰人生','大黄蜂','熊出没·原始时代','新喜剧之王'] b = [38.13,19.85,14.89,11.36,6.47,5.93] my_font = font_manager.FontProperties(fname='./data/STSONG.TTF') plt.figure(figsize=(20,8),dpi=80) # 绘制柱状图 rects = plt.bar(a,b,width=0.3,color=['red','green','blue','cyan','yellow','gray']) plt.xticks(a,fontproperties=my_font) plt.yticks(range(0,41,5),range(0,41,5)) # 在条形图上加标注(水平居中) for rect in rects: height = rect.get_height() plt.text(rect.get_x() + rect.get_width() / 2, height+0.3, str(height),ha=\"center\") plt.show() 我们得到了每个电影对应的票房柱形图，每个柱形的高度分别记录着票房的值。 但是，细心的同学会注意到，我们将柱形的高度数据标注在了柱形的上方。没错，我们使用了plt.text( )函数为每个柱形标注高度数值。 plt.text(x,y,s,ha,va) 函数中前两个参数分别为标注数据的坐标，x和y坐标，参数s记录标注的内容，参数ha和va分别用于设置水平和垂直方向的对齐方式。 rects是plt.bar()的返回值，里面包含了每一个柱形为每个柱形添加数值标注需要逐个添加，所以我们设置了一个循环来完成这项操作。 for rect in rects: height = rect.get_height() plt.text(rect.get_x() + rect.get_width() / 2, height+0.3, str(height),ha=\"center\") 通过get_height()、get_x()、rect.get_width()等方法可以分别拿到柱形图的高度，左侧边的x值，柱子的宽度。然后，使用plt.text添加上文字，这样就可以清晰地看出每个柱形的高度了。 1.1.3. 直方图 直方图一般用来描述等距数据，柱状图一般用来描述名称（类别）数据或顺序数据。直观上，直方图各个长条形是衔接在一起的，表示数据间的数学关系；条形图各长条形之间留有空隙，区分不同的类。 绘制直方图使用plt.hist()函数： plt.hist(data, bins, facecolor, edgecolor) 先来了解一下函数的常用参数： data：绘图用到的数据； height：直方图的条形数目； bins：设置柱形的宽度； facecolor：矩形的填充颜色； edgecolor：条形的边框颜色。 现有250部电影的时长，希望统计出这些电影时长的分布状态(比如时长为100分钟到120分钟电影的数量，出现的频率信息，你应该如何呈现这些数据？ # 电影时长数据 time = [131, 98, 125, 131, 124, 139, 131, 117, 128, 108, 135, 138, 131, 102, 107, 114, 119, 128, 121, 142, 127, 130, 124, 101, 110, 116, 117, 110, 128, 128, 115, 99, 136, 126, 134, 95, 138, 117, 111,78, 132, 124, 113, 150, 110, 117, 86, 95, 144, 105, 126, 130,126, 130, 126, 116, 123, 106, 112, 138, 123, 86, 101, 99, 136,123, 117, 119, 105, 137, 123, 128, 125, 104, 109, 134, 125, 127,105, 120, 107, 129, 116, 108, 132, 103, 136, 118, 102, 120, 114,105, 115, 132, 145, 119, 121, 112, 139, 125, 138, 109, 132, 134,156, 106, 117, 127, 144, 139, 139, 119, 140, 83, 110, 102,123, 107, 143, 115, 136, 118, 139, 123, 112, 118, 125, 109, 119, 133,112, 114, 122, 109, 106, 123, 116, 131, 127, 115, 118, 112, 135,115, 146, 137, 116, 103, 144, 83, 123, 111, 110, 111, 100, 154,136, 100, 118, 119, 133, 134, 106, 129, 126, 110, 111, 109, 141,120, 117, 106, 149, 122, 122, 110, 118, 127, 121, 114, 125, 126,114, 140, 103, 130, 141, 117, 106, 114, 121, 114, 133, 137, 92,121, 112, 146, 97, 137, 105, 98, 117, 112, 81, 97, 139, 113,134, 106, 144, 110, 137, 137, 111, 104, 117, 100, 111, 101, 110,105, 129, 137, 112, 120, 113, 133, 112, 83, 94, 146, 133, 101,131, 116, 111, 84, 137, 115, 122, 106, 144, 109, 123, 116, 111,111, 133, 150] 运行下方代码，来一起绘制这个直方图： from matplotlib import pyplot as plt from matplotlib import font_manager time = [131, 98, 125, 131, 124, 139, 131, 117, 128, 108, 135, 138, 131, 102, 107, 114, 119, 128, 121, 142, 127, 130, 124, 101, 110, 116, 117, 110, 128, 128, 115, 99, 136, 126, 134, 95, 138, 117, 111,78, 132, 124, 113, 150, 110, 117, 86, 95, 144, 105, 126, 130,126, 130, 126, 116, 123, 106, 112, 138, 123, 86, 101, 99, 136,123, 117, 119, 105, 137, 123, 128, 125, 104, 109, 134, 125, 127,105, 120, 107, 129, 116, 108, 132, 103, 136, 118, 102, 120, 114,105, 115, 132, 145, 119, 121, 112, 139, 125, 138, 109, 132, 134,156, 106, 117, 127, 144, 139, 139, 119, 140, 83, 110, 102,123, 107, 143, 115, 136, 118, 139, 123, 112, 118, 125, 109, 119, 133,112, 114, 122, 109, 106, 123, 116, 131, 127, 115, 118, 112, 135,115, 146, 137, 116, 103, 144, 83, 123, 111, 110, 111, 100, 154,136, 100, 118, 119, 133, 134, 106, 129, 126, 110, 111, 109, 141,120, 117, 106, 149, 122, 122, 110, 118, 127, 121, 114, 125, 126,114, 140, 103, 130, 141, 117, 106, 114, 121, 114, 133, 137, 92,121, 112, 146, 97, 137, 105, 98, 117, 112, 81, 97, 139, 113,134, 106, 144, 110, 137, 137, 111, 104, 117, 100, 111, 101, 110,105, 129, 137, 112, 120, 113, 133, 112, 83, 94, 146, 133, 101,131, 116, 111, 84, 137, 115, 122, 106, 144, 109, 123, 116, 111,111, 133, 150] my_font = font_manager.FontProperties(fname='./data/STSONG.TTF',size=10) # 2）创建画布 plt.figure(figsize=(20, 8), dpi=100) # 3）绘制直方图 # 设置组距 distance = 2 # 计算组数 group_num = int((max(time) - min(time)) / distance) # 绘制直方图 plt.hist(time, bins=group_num) # 修改x轴刻度显示 plt.xticks(range(min(time), max(time))[::2]) # 添加网格显示 plt.grid(linestyle=\"--\", alpha=0.5) # 添加x, y轴描述信息 plt.xlabel(\"电影时长大小\",fontproperties=my_font) plt.ylabel(\"电影的数据量\",fontproperties=my_font) # 4）显示图像 plt.show() 这样我们就绘制计出这些电影时长的分布状态直方图。我们看到电影时长最多的在110到112之间。 其实，绘制直方图的重点在于设置组距，然后分为若干组。用矩形的高度表示每一组数据的频数。 那么直方图和柱形图究竟有什么区别呢。 第一，柱形图中用柱形的高度表示各类别的数值，横轴表示类别，宽度是固定的；而直方图是用矩形的高度表示每一组的频数或频率，宽度则表示各组的组距，因此其高度与宽度均有意义。 第二，直方图主要用于展示连续型数值型数据，所以各矩形通常是连续排列的；而柱形图主要用于展示分类型数据，常常是分开排列的。 1.1.4. 散点图 散点图是判断变量之间是否存在数量关联趋势,展示离群点。每个点的坐标位置由变量的值决定，并由一组不连接的点完成，用于观察两种变量的相关性。例如，身高—体重、温度—维度。 绘制直方图使用plt.scatter()函数： plt.scatter(x,y,s,c,marker,alpha,linewidths) 先来了解一下函数的常用参数： x,y：数组； s：散点图中点的大小，可选； c：散点图中点的颜色，可选； marker：散点图的形状，可选； alpha：表示透明度，在 0~1 取值，可选； linewidths：表示线条粗细，可选； 之前我们收集4000份的身高和体重数据，数据文件的路径是./data/height_weight.csv，运行下方代码，了解数据基本情况： import pandas as pd df = pd.read_csv('./data/height_weight.csv') print(df.shape) print(df.head()) 共有4000条数据，包含：height和weight两列数据。 接下来我们绘制出身高和体重的散点图，观察两种变量的相关性。 import pandas as pd from matplotlib import pyplot as plt df = pd.read_csv('./data/height_weight.csv') # 设置图形大小 plt.figure(figsize=(20,8),dpi=80) # 使用scatter绘制散点图 plt.scatter(df['height'],df['weight'],alpha=0.5,c='red') plt.show() 将身高和体重数据分别作为散点图的x轴和y轴数据，并且将点的颜色设置为红色，透明度设置为0.5。这样我们就成功绘制计出身高和体重的散点图。 通过散点图我们可以判断出，体重和身高的相关性是正相关，身高越高体重越大。 1.1.5. 饼图 饼图是展示 分类数据的占比情况，就是反映某个部分占整体的比重，比如贫穷人口占总人口的百分比。 饼图的整个圆代表总数据，各个扇形表示每项数据，我们可以根据扇形的角度清楚地看出每个扇形占总数据的比例。 我们以拉勾网上海数据分析师职位数据为实验数据，数据的路径为./data/lagou.xlsx，运行下方代码，查看数据的基本情况： import pandas as pd df = pd.read_excel('./data/lagou.xlsx') print(df.shape) print(df.head()) 此数据共包含412条数据，包含：职位名称、详细链接、工作地点、薪资、学历、经验等10列信息。 那么，我们现在希望探索一下，这些招聘岗位中对不同学历要求的占比各是多少？ 绘制饼图我们使用plt.pie( )函数。 plt.pie(x, labels, autopct, shadow, startangle) 先来了解一下函数的常用参数： x：绘制用到的数据； labels：用于设置饼图中每一个扇形外侧的显示说明文字； autopct：设置饼图内百分比数据，可以使用format字符串或者format function，例如’%.1f%%’指小数点后保留1位小数； shadow：表示是否在饼图下面画阴影，默认值：False，即不画阴影； startangle：设置起始绘制角度，默认图是从x轴正方向逆时针画起，如果设定startangle=90，则从y轴正方向画起。 下面我们来一起尝试绘制招聘岗位中不同学历的占比饼图： import pandas as pd from matplotlib import pyplot as plt from matplotlib import font_manager my_font = font_manager.FontProperties(fname='./data/STSONG.TTF',size=10) df = pd.read_excel('./data/lagou.xlsx') plt.figure(figsize = (10,8)) num = df.groupby('学历').size() # 绘制饼图 patches, l_text, p_text = plt.pie(num,labels = num.index, autopct='%.1f%%',shadow=False,startangle=90) for t in l_text: t.set_fontproperties(my_font) plt.show() 这样我们就绘制出了一个完整的饼图，接下来，我们分析一下代码逻辑。 df.groupby('学历').size()按照类型变量学历对原数据分组，使用groupby函数，然后计算每组数据的数据量，使用size()函数，将输出的数据记录为num。 plt.pie()会有三个返回值： patches: matplotlib.patches.Wedge列表(扇形实例); l_text：label matplotlib.text.Text列表(标签实例); p_text：label matplotlib.text.Text列表(百分比标签实例) 所以，在每一个扇形外侧显示中文的时候，需要获取到每一个标签实例，然后通过set_fontproperties()方法设置自定义字体。 1.1.6. 本节总结 今天的内容就告一段落了，经过前面和本节课的学习，我们学习了如何绘制折线图、柱形图、直方图、饼图、散点图这些常见的统计图形。 最后，我们来总结一下绘制这些图像的知识点： 1.1.7. 练习1 题目：放不下的热爱--FIFA足球世界 题目要求： 《FIFA 19》是一款由EA加拿大、EA罗马尼亚开发由艺电发行的足球电子游戏。现在我们有一份包括最新版FIFA 2019球员属性的数据，数据路径为./data/FIFA19.xlsx,本数据共有10000条数据，数据的基本信息如下图： 现在根据上面的数据完成如下需求： 统计出这些球员年龄的分布状态； 统计出这些球员在球场位置的占比。 思路：获取球员年龄列数据，用直方图绘制球员年龄的分布状态；计算每个位置上球员的个数，用饼图绘制球场位置的占比； 参考答案： 统计出这些球员年龄的分布状态参考答案： import pandas as pd from matplotlib import pyplot as plt from matplotlib import font_manager my_font = font_manager.FontProperties(fname='./data/STSONG.TTF',size=10) df = pd.read_excel('./data/FIFA19.xlsx') age_list = df['Age'].values.tolist() # 设置组距 distance = 2 # 计算组数 group_num = int((max(age_list) - min(age_list)) / distance) # 用直方图绘制分布状态 plt.hist(age_list, bins=group_num) plt.xticks(range(min(age_list), max(age_list))[::2]) # 添加网格显示 plt.grid(linestyle=\"--\", alpha=0.5) # 添加x, y轴描述信息 plt.xlabel(\"年龄\",fontproperties=my_font) plt.ylabel(\"球员数\",fontproperties=my_font) plt.show() 统计出这些球员在球场位置的占比参考答案： import pandas as pd from matplotlib import pyplot as plt df = pd.read_excel('./data/FIFA19.xlsx') plt.figure(figsize = (10,8)) # 根据Position数据分组 num = df.groupby('Position').size() plt.pie(num,labels = num.index, autopct='%.1f%%',shadow=False,startangle=90) plt.show() 1.1.8. 练习2 题目：一入电商深似海 题目要求： 俗话说：一入电商深似海，从此妹子是路人；要想让自己网店营业额增加，不仅要耐得住寂寞，还要勤总结善分析。下面是一份某电商的销售数据，数据的路径为：./data/E-Business.xlsx，数据的基本信息如下图： 现在根据上面的数据完成如下需求： 统计不同地区的总销售额。 统计各个地区的订单量的占比。 思路：根据地区将数据进行分组，用柱状图绘制各个地区的总销售额；用饼图绘制订单量的占比； 参考答案： 不同地区的总销售额参考答案： import pandas as pd from matplotlib import pyplot as plt from matplotlib import font_manager my_font = font_manager.FontProperties(fname='./data/STSONG.TTF',size=10) df = pd.read_excel('./data/E-Business.xlsx') num = df.groupby('地区').size() x = num.index.tolist() y = num.values.tolist() plt.figure(figsize=(20,8),dpi=80) # 绘制柱状图 rects = plt.bar(x,y,width=0.3) plt.xticks(x,fontproperties=my_font) # 在条形图上加标注(水平居中) for rect in rects: height = rect.get_height() plt.text(rect.get_x() + rect.get_width() / 2, height+0.3, str(height),ha=\"center\") plt.show() 各个地区的订单量的占比参考答案： import pandas as pd from matplotlib import pyplot as plt from matplotlib import font_manager my_font = font_manager.FontProperties(fname='./data/STSONG.TTF',size=10) df = pd.read_excel('./data/E-Business.xlsx') df.head() num = df.groupby('地区').size() # 绘制饼图 patches, l_text, p_text = plt.pie(num,labels = num.index, autopct='%.1f%%',shadow=False,startangle=90) for t in l_text: t.set_fontproperties(my_font) plt.show() Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-25 15:57:56 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"第12课/python数据分析第十二课.html":{"url":"第12课/python数据分析第十二课.html","title":"绘制双Y轴坐标系、改变坐标轴的默认显示方式","keywords":"","body":"1.1.1. 课程介绍1.1.2. 绘制双Y轴坐标系1.1.3. 改变坐标轴的默认显示方式1.1.4. 本节总结1.1.5. 下节预告1.1.6. 练习11.1.7. 练习2题目：缤纷图像与你环环相扣 1.1.1. 课程介绍 Hello, 我是小K，很高兴又和大家见面了，我们一起继续学习Python数据分析。 为了让你能不受干扰的在学习数据分析路上饱览胜景，请将屏幕调整成全屏，Windows系统：请按F11（或Fn+F11)；苹果系统：请同时按control+command+F。 前面我们学习了Matplotlib的绘图流程和常用设置以及常见统计图的绘制方法。 同时，我们也发现Matplotlib绘制出的图形中会存在一些问题，例如：如何绘制双Y轴坐标系？如何去掉图形默认的边框？以及如何移动坐标到指定位置？ 本节课我们将着重解决上面的几个问题。 1.1.2. 绘制双Y轴坐标系 在进行数据分析时，有时候我们需要在同一个坐标图中比较两种数据在时间序列上的关系时，由于两种数据的单位和数据并不统一，也是不同的类型的数据，因此我们不能用一个Y轴来共同衡量两类不同的数据，这时候我们就需要绘制双Y轴图。 下面我们使用某上市公司股票日线部分数据，数据路径为./data/600001SH.xlsx。 运行下方代码，我们了解一下数据的基本情况： 此处是代码 ————————————— —————————— 终端 import pandas as pd datas = pd.read_excel('./data/600001SH.xlsx') print(datas.shape) datas.head() 我们的目的是研究二月份某公司的每日收盘价以及对应的成交量，所以方便分析，需要在一个双Y轴坐标图中同时绘制出收盘价和成交量的时间序列图。 首先，需要将日期列设置成数据的索引，方便我们后续按照日期获取数据。 # 将日期设置为index datas.index = pd.to_datetime(datas['日期']) 然后，将二月份的数据获取出来。 # 获取二月份的数据 feb_datas = datas['2015-02'] 请抄写上面代码到代码框，并运行。 此处是代码 ————————————— —————————— 终端 import pandas as pd 万事俱备，接下来看看双y轴绘制的关键函数：twinx()。 twinx()函数表示共享x轴，共享表示的就是x轴使用同一刻度线。 接下来，我们先把每日收盘价的折线图绘制出来： 此处是代码 ————————————— —————————— 终端 import pandas as pd from matplotlib import pyplot as plt from matplotlib import font_manager my_font = font_manager.FontProperties(fname='./data/STSONG.TTF',size=18) # 获取数据 datas = pd.read_excel('./data/600001SH.xlsx') datas.index = pd.to_datetime(datas['日期']) feb_datas = datas['2015-02'] # 绘制图形 fig = plt.figure(figsize=(20,8),dpi=80) ax = fig.add_subplot(111) lin1 = ax.plot(feb_datas.index.tolist(),feb_datas['开盘价(元)'].values.tolist(),label='开盘价',color='red') ax.legend(prop=my_font,loc=0) ax.set_ylabel(\"开盘价(元)\",fontproperties=my_font) ax.set_xlabel(\"日期\",fontproperties=my_font) plt.show() 大家可能已经注意到在代码中，我们使用add_subplot添加了Axes坐标轴实例。 因为，我们会使用这个Axes坐标轴实例去调用twinx()函数，从而实现两个Y轴共享一个X轴的效果。 ax2 = ax.twinx() ax.twinx()是在ax的坐标轴内创建一个共享X轴的的坐标轴实例。 所以我们可以在ax2的坐标轴实例中绘制每日成交量的折线图。 lin2 = ax2.plot(feb_datas.index.tolist(),feb_datas['成交量(股)'].values.tolist(),label='成交量(股)') 现在，大家用上面的方法，尝试在下方代码框中绘制双Y轴坐标系： 此处是代码 ————————————— —————————— 终端 下面是小K的代码供你参考： import pandas as pd from matplotlib import pyplot as plt from matplotlib import font_manager my_font = font_manager.FontProperties(fname='./data/STSONG.TTF',size=18) # 获取数据 datas = pd.read_excel('./data/600001SH.xlsx') datas.index = pd.to_datetime(datas['日期']) feb_datas = datas['2015-02'] # 绘制图形 fig = plt.figure(figsize=(20,8),dpi=80) ax = fig.add_subplot(111) lin1 = ax.plot(feb_datas.index.tolist(),feb_datas['开盘价(元)'].values.tolist(),label='开盘价',color='red') ax.set_ylabel(\"开盘价(元)\",fontproperties=my_font) ax.set_xlabel(\"日期\",fontproperties=my_font) ax.legend(prop=my_font) ax2 = ax.twinx() lin2 = ax2.plot(feb_datas.index.tolist(),feb_datas['成交量(股)'].values.tolist(),label='成交量(股)') ax2.legend(prop=my_font) ax2.set_ylabel(\"成交量(股)\",fontproperties=my_font) # 绘制网格 ax.grid() plt.show() 因为是共享X轴，所以只用ax.set_xlabel()就可以设置X轴的标题。 由于Y轴不共享，所以每一个坐标系的Y轴标题都要使用set_xlabel()方法设置一次。 代码中，我们设置了两次图例的显示，所以出现了两个图例重叠的现象，所以我们需要合并图例。 合并图例的方法就是仅使用一个轴的legend()函数。 # 合并图例 lns = lin1+lin2 labs = [l.get_label() for l in lns] ax.legend(lns, labs, prop=my_font) lin1和lin2分别是两个绘图方法plot()的返回值，即折线对象。需要注意的是，lin1和lin2的类型是list。 legend()方法可以指定图例中有哪些值，第一个参数lns表示将图中的多个线以列表的形势传进去，第二个参数labs表示将图例的名字以列表的形势传进去。 运行下面的代码，观察一下合并图例之后的图形： 此处是代码 ————————————— —————————— 终端 import pandas as pd from matplotlib import pyplot as plt from matplotlib import font_manager my_font = font_manager.FontProperties(fname='./data/STSONG.TTF',size=18) # 获取数据 datas = pd.read_excel('./data/600001SH.xlsx') datas.index = pd.to_datetime(datas['日期']) feb_datas = datas['2015-02'] # 绘制图形 fig = plt.figure(figsize=(20,8),dpi=80) ax = fig.add_subplot(111) lin1 = ax.plot(feb_datas.index.tolist(),feb_datas['开盘价(元)'].values.tolist(),label='开盘价',color='red') ax.legend(prop=my_font) ax2 = ax.twinx() lin2 = ax2.plot(feb_datas.index.tolist(),feb_datas['成交量(股)'].values.tolist(),label='成交量(股)') ax2.legend(prop=my_font) ax2.set_ylabel(\"成交量(股)\",fontproperties=my_font) ax.set_ylabel(\"开盘价(元)\",fontproperties=my_font) ax.set_xlabel(\"日期\",fontproperties=my_font) # 合并图例 lns = lin1+lin2 labs = [l.get_label() for l in lns] ax.legend(lns, labs, prop=my_font) # 绘制网格 ax.grid() plt.show() 1.1.3. 改变坐标轴的默认显示方式 上图中，一个是Matplotlib默认绘制出的图像，另一个是修改了Matplotlib的一些默认显示方式。 经过前面的学习我们发现，Matplotlib在绘制图形的时候会默认显示上面和右侧的边框，以及坐标轴的颜色默认是黑色。 如果想要去掉默认的边框，通过plt.gca()获得当前的Axes对象。 ax = plt.gca() 使用spines属性获取到对应的边框。 ax.spines['right'] right右边框、left左边框、top上边框、bottom下边框。 通过set_color('none')方法可以设置边框的颜色。 ax.spines['right'].set_color('none') 对于颜色的设置，none表示无色，也可以用red、blue等样式的英语单词或者是十六进制的颜色值#0000FF。 运行下面的代码，给边框换个颜色： 此处是代码 ————————————— —————————— 终端 import matplotlib.pyplot as plt y = range(0,14,2) x = [-3,-2,-1,0,1,2,3] # 获得当前图表的图像 ax = plt.gca() # 设置图型的包围线 ax.spines['right'].set_color('none') ax.spines['top'].set_color('none') ax.spines['bottom'].set_color('red') ax.spines['left'].set_color('#0000FF') plt.plot(x,y) plt.show() 我们已经成功的设置边框的颜色，但是还有一个问题就是坐标轴的交叉点也是默认设置的。 如果想要X轴的0点，和Y轴的0点交叉，需要使用set_position方法移动坐标轴的位置。 ax.spines['bottom'].set_position(('data', 0)) 设置底边的移动范围，移动到Y轴的0位置。 data:移动轴的位置到交叉轴的指定坐标 运行下面的代码，移动X轴和Y轴到（0，0）点： import matplotlib.pyplot as plt import numpy as np y = range(0,14,2) # x轴的位置 x = [-3,-2,-1,0,1,2,3] # plt.figure(figsize=(20,8),dpi=80) # 获得当前图表的图像 ax = plt.gca() # 设置图型的包围线 ax.spines['right'].set_color('none') ax.spines['top'].set_color('none') ax.spines['bottom'].set_color('blue') ax.spines['left'].set_color('red') ax.spines['bottom'].set_position(('data', 0)) ax.spines['left'].set_position(('data', 0)) plt.plot(x,y) plt.show() 1.1.4. 本节总结 本节课的内容到这里就结束了，我们主要讲解了如何绘制双Y轴坐标系，如何去掉图形默认的边框，以及如何移动坐标到指定位置。 下面，我们总结一下本节课的主要知识点： 1.1.5. 下节预告 1.1.6. 练习1 题目：弹起我心爱的正弦 题目要求： 绘制出一个段完整的正弦函数，如下图所示，不要显示坐标周以及刻度值。 下面是需要用到的函数： numpy.linspace(start, stop, num=50)在指定的间隔内返回均匀间隔的数字，返回num均匀分布的样本，在[start, stop]。 numpy.sin(x)是numpy的提供的计算正弦值的函数。 参考答案： import numpy as np import matplotlib.pyplot as plt # 在指定的间隔内返回均匀间隔的数字 x = np.linspace(-np.pi,np.pi,256) # 正弦函数 y = np.sin(x) #画图，使用不同的颜色和线条 plt.plot(x,y,color='blue',linewidth=1) # 获得当前图表的图像 ax = plt.gca() # 设置图型的包围线 ax.spines['right'].set_color('none') ax.spines['top'].set_color('none') ax.spines['bottom'].set_color('none') ax.spines['left'].set_color('none') # 设置不显示坐标轴刻度 plt.xticks([]) plt.yticks([]) plt.show() 1.1.7. 练习2 题目： 画出你最爱的折线 题目要求： 本练习继续使用某电商超市从2016年到2019年的部分销售数据，路径为：./data/Commerce.xls。 请用一张图绘制出2018年各地区销售总额及增长率。如下图： 参考答案： import pandas as pd import matplotlib.pyplot as plt from matplotlib import font_manager my_font = font_manager.FontProperties(fname='./data/STSONG.TTF',size=18) data = pd.read_excel('./data/Commerce.xls') # 将订单日期设置为数据的索引 data.index = data['订单日期'] # 2018年各季度各地区的总销售额 area_sales18 = data['2018'].groupby('地区')['销售额'].sum() # 2017年各季度各地区的总销售额 area_sales17 = data['2017'].groupby('地区')['销售额'].sum() # 增长率 = (area_sales18- area_sales17)/area_sales17 growth_rate = (area_sales18-area_sales17)/area_sales17 fig = plt.figure() ax = fig.add_subplot(111) lin1 = ax.bar(area_sales18.index,area_sales18.values) ax.set_ylabel(\"2018销售额\",fontproperties=my_font) ax.set_xlabel(\"地区\",fontproperties=my_font) plt.xticks(growth_rate.index,fontproperties=my_font) ax2 = ax.twinx() lin2 = ax2.plot(growth_rate.index,growth_rate.values,color='red',marker='o') ax2.set_ylabel(\"增长率\",fontproperties=my_font) # 绘制网格 ax.grid() plt.show() Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-25 15:57:53 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"第13课/":{"url":"第13课/","title":"Seaborn","keywords":"","body":"1. Seaborn1. Seaborn Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-23 12:26:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"第13课/python数据分析数据可视化--seaborn.html":{"url":"第13课/python数据分析数据可视化--seaborn.html","title":"Seaborn简介","keywords":"","body":"1.1.1. 课程介绍1.1.2. Seaborn简介1.1.3. 整体布局风格设置1.1.4. seaborn调色板及颜色设置1.1.5. 本节总结1.1.6. 下节预告1.1.7. 练习11.1.8. 练习2题目：数据可视化之Seaborn化妆术 1.1.1. 课程介绍 Hello, 我是小K，很高兴又和大家见面了，我们一起继续学习Python数据分析。 为了让你能不受干扰的在学习数据分析路上饱览胜景，请将屏幕调整成全屏，Windows系统：请按F11（或Fn+F11)；苹果系统：请同时按control+command+F。 前面我们学习了Pandas如何处理数据以及用Matplotlib对数据进行可视化，在今天的课程中我们再来感受一个更具魅力的绘图工具，它叫做Seaborn。 1.1.2. Seaborn简介 Seaborn 是基于 Python 且非常受欢迎的图形可视化库，并且在 Matplotlib 的基础上，进行了更高级的封装，使得作图更加方便快捷。可以通过极简的代码，做出具有分析价值而又十分美观的图形。 我们先来看一下Seaborn绘制的图形。 同样在使用Seaborn之前我们需要将其导入： import seaborn as sns 成功导入seaborn后，我们将开始seaborn学习之旅。 1.1.3. 整体布局风格设置 seaborn.set()设置风格 首先，我们先了解一下seaborn.set()函数： sns.set(context='notebook',style='darkgrid',palette='deep',font='sans-serif',font_scale=1,color_codes=True) context=''：参数控制着默认的画幅大小，分别有 {paper, notebook, talk, poster} 四个值。其中，poster > talk > notebook > paper。 style=''：参数控制默认样式，分别有 {darkgrid, whitegrid, dark, white, ticks}，你可以自行更改查看它们之间的不同。 palette=''：参数为预设的调色板。分别有 {deep, muted, bright, pastel, dark, colorblind} 等，你可以自行更改查看它们之间的不同。 font='' 用于设置字体。 font_scale= ''：设置字体大小。 color_codes=''： 不使用调色板而采用先前的 'r' 等色彩缩写。 然后，我们使用numpy的np.linspace()函数生成100个0到15的等间隔数列。 x = np.linspace(0, 15, 100) 最后用这个数列画出2条曲线： def sinplot(): x = np.linspace(0, 15, 100) for i in range(1, 3): plt.plot(x, np.sin(x + i)) sinplot() 请大家复制上面的代码，绘制2条曲线： 此处是代码 ————————————— —————————— 终端 import numpy as np import matplotlib.pyplot as plt import seaborn as sns 代码中，我们没有对风格做任何的设置。 接下来，我们调用sns.set()函数来改变style，看看效果如何： 此处是代码 ————————————— —————————— 终端 import numpy as np import matplotlib.pyplot as plt import seaborn as sns def sinplot(): x = np.linspace(0, 15, 100) for i in range(1, 3): plt.plot(x, np.sin(x + i)) sns.set() sinplot() plt.show() 根据结果，我们添加了sns.set()方法后，图形添加了网格，而且隐藏了坐标轴。 那么，问题来了，有人会说，这个set()函数这么多参数，只要改变其中任意一个参数的值，绘图效果就会发生变化，那我们怎么知道哪种搭配是最佳效果呢，难道我们要一个个去测试吗？ 当然不是，seaborn提供了5种默认的风格，我们在实际绘图中只要选择一种喜欢的风格就可以了，下面我们就看看这5种风格的用法及效果。 sns.set(style='white') sns.set(style='whitegrid') sns.set(style='darkgrid') sns.set(style='dark') sns.set(style='ticks') 请复制上面的代码，体验5这种风格： 此处是代码 ————————————— —————————— 终端 import numpy as np import matplotlib.pyplot as plt import seaborn as sns def sinplot(): x = np.linspace(0, 15, 100) for i in range(1, 3): plt.plot(x, np.sin(x + i)) # 设置图像风格 sinplot() plt.show() 当然，除了这5中内置风格以外，我们也可以通过其他函数进行个性化设置。 sns.despine()个性化设置 比如，当我们的风格设置为style='ticks'时，会有上部和右侧的坐标轴，我们可以使用seaborn.despine()函数进行去除。 运行下方代码，看看效果： 此处是代码 ————————————— —————————— 终端 import numpy as np import matplotlib.pyplot as plt import seaborn as sns def sinplot(): x = np.linspace(0, 15, 100) for i in range(1, 3): plt.plot(x, np.sin(x + i)) sns.set(style='ticks') sinplot() sns.despine() plt.show() sns.despine()函数默认移除了上部和右侧的轴，当然我们也可以移除其他轴。 对于是否移除某个轴，我们可以设置sns.despine()函数的top、right、left、bottom参数的值来控制，值为True时，会移除该轴，反之，保留该轴。 现在有同学会问道：在matplotlib中我们已经学过了，在一个figure对象中，我们可以添加多个子图，那么如何让我们不同的子图使用不同的风格呢？ 莫慌，我们可以使用with设置风格，在with下画的图都可以使用该种风格。 运行下方代码，查看不同的子图如何使用不同的风格： 此处是代码 ————————————— —————————— 终端 import numpy as np import matplotlib.pyplot as plt import seaborn as sns def sinplot(): x = np.linspace(0, 15, 100) for i in range(1, 3): plt.plot(x, np.sin(x + i)) # 设置子图风格 with sns.axes_style(\"darkgrid\"): plt.subplot(211) sinplot() plt.subplot(212) sinplot() plt.show() 我们看到第一个子图的风格成功设置成了darkgrid，而且在绘制第二个子图的时候并未受到影响。 sns.axes_style()的作用是临时设置绘图的参数，也就是只设置使用with打开的作用域内的绘图，不会对其他的图造成影响。 这就是常用seaborn库的风格设置，我们常会使用sns.set()设置图形风格，以及使用with sns.axes_style()函数给不同的子图设置不同的风格。 1.1.4. seaborn调色板及颜色设置 颜色在可视化中非常重要，用来代表各种特征，并且提高整个图的观赏性。 前面我们学习了如何设置seaborn画图的整体风格，接下来我们学习一下seaborn如何创建调色板以及使用调色板设置颜色。 seaborn调色板？此乃何物？ 调色板就像是装水彩笔的盒子，等我们把图绘制完成以后，使用相应颜色的水彩笔涂上颜色就好了。 color_palette()调色板 seaborn的seaborn.color_palette()函数提供了一组定义好的调色板，也就是我上面所说的装水彩笔的盒子。 下面我们了解一下这个函数： seaborn.color_palette(palette=None, n_colors=None, desat=None) 该函数的返回值： 是一个调色板定义的一个颜色列表。 palette：调色板，可以不写，可以填写字符串，也可以是一个序列。 n_colors：可以指定颜色的数量。 desat：按照比例降低每一种颜色的饱和度。 不带任何参数时，表示获取这个盒子里的全部水彩笔。 下面让我们打开这个盒子，看看里面都有什么颜色的水彩笔。 此处是代码 ————————————— —————————— 终端 import seaborn as sns # 获取默认调色板的颜色列表 current_palette = sns.color_palette() # 绘制调色板的颜色 sns.palplot(current_palette) color_palette()默认给我们提供了6种主题颜色去对应matplotlib中的10种颜色。 6个默认的颜色主题分别是： deep，muted，pastel，bright，dark，colorblind。 下面我们依次看看每种主题色的效果： 此处是代码 ————————————— —————————— 终端 import seaborn as sns theme_list=['deep', 'muted', 'pastel','bright', 'dark', 'colorblind'] for i in theme_list: sns.palplot(sns.color_palette(i)) 注意： 这六种主题形成的颜色列表中，最多含有10种，如果我们设置n_colors的值多余10中，就会用这10种颜色进行循环增加。 运行下方代码，你会发现12个颜色中，前两个和最后两个是一样的： 此处是代码 ————————————— —————————— 终端 import seaborn as sns sns.palplot(sns.color_palette(\"deep\", 12)) 如果我们想用不同的颜色表示不同的类别，有没有更多的颜色可供我们使用呢？ 最常用的方法是使用hls的颜色空间，这是RGB值的一个简单转换。 sns.palplot(sns.color_palette(\"hls\", 12)) hls：大家就可以看做是一个颜色足够丰富的色板。 运行下面代码，体验调色板： from matplotlib import pyplot as plt import seaborn as sns a = ['a','b','c','d','e','f'] b =[38.13,19.85,14.89,11.36,6.47,5.93] plt.figure(figsize=(20,8),dpi=80) # 绘制条形图 plt.bar(a,b,width=0.3,color=sns.color_palette(\"hls\", 6)) plt.show() 我们看到使用调色板成功的设置了条形图的颜色，如果调色板的颜色少于条形图的个数，将会循环调色板颜色。 1.1.5. 本节总结 在本节课中，我们学习了如何设置绘图风格和颜色画板，来看一下今天的知识点： 1.1.6. 下节预告 1.1.7. 练习1 题目：我的图我做主 首先来了解一下数据，这是一份从2000年到2008年每个月新生婴儿数据，数据路径为：./data/births.xlsx。 运行下方代码，查看数据具体信息： import pandas as pd birth=pd.read_excel('./data/births.xlsx') birth.head() 数据中共4个字段year（年）、month（月）、gender（性别）、births（出生数）。 使用matplotlib绘制出每年总出生数的柱状图，并使用seaborn设置一种风格。 参考答案： import pandas as pd import matplotlib.pyplot as plt import seaborn as sns # 读取数据 data = pd.read_excel('./births.xlsx') # 根据年份进行分组 groups = data.groupby(by = 'year') xticks = [] for group_name,group_df in groups: xticks.append(group_name) plt.bar(group_name,group_df['births'].sum()) # 设置x轴的显示范围 plt.xticks(xticks) plt.xlabel('year') plt.ylabel('births') sns.set(style='darkgrid') plt.show() 1.1.8. 练习2 题目要求：男孩 or 女孩 本练习继续使用上一个练习的数据集，数据路径为：./data/births.xlsx。 请用两张子图分别绘制出以下图形，并且不同的子图使用不同的风格： 绘制出每年出生的男孩柱状图； 绘制出每年出生的女孩柱状图； 参考答案： import pandas as pd import matplotlib.pyplot as plt import seaborn as sns # 读取数据 data = pd.read_excel('./births.xlsx') # 根据年份进行分组 groups = data.groupby(by = ['year','gender']) def subplot(gender): for group_name,group_df in groups: if gender in group_name: plt.bar(group_name[0],group_df['births'].sum()) with sns.axes_style(\"darkgrid\"): plt.subplot(211) subplot('F') with sns.axes_style(\"whitegrid\"): plt.subplot(212) subplot('M') plt.show() Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-25 15:57:16 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"第14课/python数据分析第十四节.html":{"url":"第14课/python数据分析第十四节.html","title":"变量分析绘图","keywords":"","body":"1.1.1. 课程介绍1.1.2. 单变量分析绘图1.1.3. 绘制双变量联合分布图1.1.4. 多变量关系分布图1.1.5. 本节总结1.1.6. 下节预告1.1.7. 练习11.1.8. 练习2题目：灵巧绘图小当家 1.1.1. 课程介绍 Hello, 我是小K，很高兴又和大家见面了，我们一起继续学习Python数据分析。 为了让你能不受干扰的在学习数据分析路上饱览胜景，请将屏幕调整成全屏，Windows系统：请按F11（或Fn+F11)；苹果系统：请同时按control+command+F。 前面我们已经学习了seaborn画图风格设定及颜色选取的基本函数，本节我们将了解一下seaborn的绘图方式，感受数据可视化的魅力。 1.1.2. 单变量分析绘图 下面我们先来了解一下什么是单变量，什么是单变量分析？ 单变量其实就是我们通常接触到的数据集中的一列数据。 单变量分析是数据分析中最简单的形式，其中被分析的数据只包含一个变量。因为它是一个单一的变量，它不处理原因或关系。 单变量分析的主要目的是描述数据并找出其中存在的模式，也就是“用最简单的概括形式反映出大量数据资料所容纳的基本信息”。 本节我们研究的是连续数值型数据的分布，那么什么样的数据是连续数值型数据呢？什么样的数据是离散型数据呢？ 连续型数据一般应用在计算机领域，在数据挖掘、数据分类时会遇到此类数据，因其数据不是单独的整十整百的数字，包含若干位小数且取值密集，故称为连续型数据，例如，身高、体重、年龄等都是连续变量。 由记录不同类别个体的数目所得到的数据，称为离散型数据。例如，某一类别动物的头数，具有某一特征的种子粒数，血液中不同的细胞数目等。所有这些数据全部都是整数，而且不能再细分，也不能进一步提高他们的精确度。 了解了这些概念以后，我们看看如何使用seaborn绘制单变量分布？ 首先，使用NumPy模块从标准正态分布中随机地抽取1000个数，作为我们的连续数值型数据。 data = np.random.normal(size=1000) random是NumPy的一个随机模块，在random模块中的normal方法表示从正态分布中随机产生size个数值。 运行下面的代码，查看数据的表现形式： import numpy as np # 从正态分布中随机地抽取数据 data = np.random.normal(size=1000) # 查看数据的表现形式 data size=1000，表示随机产生1000个数，它们组成的数据是一组连续型的数值型数据。 在seaborn里最常用的观察单变量分布的函数是distplot()，默认地，这个函数会绘制一个直方图，并拟合一个核密度估计。 sns.distplot()的使用方法如下所示： sns.distplot(data, bins, hist = True, kde = True) data参数记录绘图所用的数据，而bins参数在绘制直方图时可以进行设置，用于设置分组的个数，默认值时，会根据数据的情况自动分为n个组，若是想指定分组的个数，可以设置该参数，然后计算我们可以增加其数量，来看到更为详细的信息。 hist和kde参数用于调节是否显示直方图及核密度估计图，默认hist、kde均为True，表示两者都显示。我们可以通过修改参数为False选择是否将其中之一去掉。 下面，我们根据上面的数据，用seaborn的distplot()绘制出数据的分布的直方图和概率密度曲线情况： import numpy as np import seaborn as sns # 从标准正态分布中随机地抽取1000个数 data = np.random.normal(size=1000) sns.set(style='darkgrid') sns.distplot(data,kde=True) 在上面的结果中，横轴表示数据点的取值，纵轴表示概率密度值。 该结果中使用直方图描述了数据的分布：将数据分成若干个组，用柱形的高度记录每组中数据所占比率。 但是，在这个图中大家还会发现比我们之前学习的柱状图多一个曲线。 这条曲线叫做概率密度曲线。就是采用平滑的峰值函数来拟合观察到的数据点，从而对真实的概率分布进行模拟。 从上图中可以看出，在数字0周围，概率密度值是最大的，但是，随着向两侧的逐渐扩展，概率密度逐渐减小。这样的分布也是一个标准正态分布。 概率密度曲线的原理比较简单，在我们知道某一事物的概率分布的情况下，如果某一个数在观察中出现了，我们可以认为这个数的概率密度很大，和这个数比较近的数的概率密度也会比较大，而那些离这个数远的数的概率密度会比较小。 如果我们只想要显示概率密度曲线，不想显示柱状图，我们也可以使用sns.kdeplot()函数绘制数据的概率密度曲线图。 sns.kdeplot()函数的使用方法如下： sns.kdeplot(data1, data2, shade = False) data1和data2参数分别为绘制图像用到的数据，如果绘制单变量数据，只传入一个参数就好，得到概率密度曲线图。 shade参数用于设置图像下方的部分是否设置阴影，默认值为False，表示不绘制阴影。 请大家运行以下代码，绘制概率密度曲线图： import numpy as np import seaborn as sns data = np.random.normal(size=1000) sns.set(style='darkgrid') sns.kdeplot(data, shade = True) 以上就是连续数值型单变量数据常见的可视化方法，我们常会使用到直方图、核密度图来描述数据的分布。 在Seaborn中也集成了这两种图像，使用sns.distplot()函数可以将它们绘制在同一张图中。 1.1.3. 绘制双变量联合分布图 有时我们不仅需要查看单个变量的分布，同时也需要查看变量之间的联系，往往还需要进行预测等。这时就需要用到双变量联合分布了。 下面我们一起来看一下连续数值型数据双变量之间的可视化方法。 在Seaborn中绘制连续数值型双变量我们使用sns.jointplot(): seaborn.jointplot(x, y, data=None, kind='scatter') x、y：分别记录x轴和y轴的数据名称。 data：数据集，data的数据类型为DataFrame。 kind：用于设置图像的类型，可选的类型有：'scatter' | 'reg' | 'resid' | 'kde' | 'hex'，分别表示散点图、回归图、残差图、核密度图和蜂巢图。 双变量散点图 如果我们希望看一看数据中两个变量在二维平面上之间的关系时，则可以使用散点图，因为散点图可以帮助我们很容易地发现一些数据的分布规律。 现在我们同样使用np.random.normal()函数创建一个含有两列数据的DataFrame，然后根据该数据绘制双变量散点图。 运行下方代码，查看数据的创建： import seaborn as sns import numpy as np import pandas as pd # 创建dataframe: df df = pd.DataFrame({'x': np.random.normal(size=500), 'y': np.random.normal(size=500)}) df DataFrame中共有两列，列名为x、y，每列数据为从正态分布中抽取的500个数字组成。 现在，请同学在下面代码框中根据数据尝试使用seaborn.jointplot()函数绘制双变量散点图： import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns # 请开始绘制 可以参考一下小K的代码： import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns # 创建dataframe: df df = pd.DataFrame({'x': np.random.normal(size=500), 'y': np.random.normal(size=500)}) # 绘制双变量散点图 sns.jointplot(x='x', y='y', data=df,kind='reg') plt.show() 根据结果我们发现，sns.jointplot()函数可以显示两个变量之间的联合关系以及每个单变量的分布。 我们把函数中的kind参数设置为'reg'就可以做一些简单的线性模型拟合。 并且在坐标系的上方和左侧分别绘制了两个变量的直方图和核密度图。 双变量蜂巢图 上面我们根据数据绘制了联合散点图，但是你会发现两个数据并没有明确的线性关系，并且散点图有一个问题，就是相同的点会覆盖在一起，导致我们看不出来浓密和稀疏。 所以我们可以使用蜂巢图查看一下数据的分布情况。 蜂巢图的绘制还是使用seaborn.jointplot()函数，只是将kind参数更该为hex即可。 请运行下方代码，绘制蜂巢图： import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns %matplotlib inline df = pd.DataFrame({'x': np.random.randn(500), 'y': np.random.randn(500)}) sns.jointplot(x='x', y='y', data=df, kind='hex') plt.show() 蜂巢图中每个六边形表示一个范围，用颜色表示这个范围内的数据量，颜色越白的地方数据量越小，颜色越深的地方表示数据量越大。 当数据比较大的时候该种方式，更容易找出数据的分布情况。 双变量密度图 在单变量分析的时候，我们绘制了单变量的概率密度曲线，在双变量中我们也可以使用密度图来分析数据的分布情况。 密度图的绘制还是使用seaborn.jointplot()函数，只是将kind参数更该为kde即可。 请运行下方代码，绘制密度图： import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns %matplotlib inline df = pd.DataFrame({'x': np.random.randn(500), 'y': np.random.randn(500)}) sns.jointplot(x='x', y='y', data=df, kind='kde') plt.show() 根据图形可以看出，双变量密度图是使用一些封闭但是不规则的曲线来表示，数据密度越高的地方颜色越深，数据密度越低的地方颜色越浅。 1.1.4. 多变量关系分布图 我们在做数据分析时面对的数据集中往往有很多列数据，在我们还没有确定针对哪两个变量进行挖掘的时候，比较稳妥的做法就是将数据中的每两列都考虑一次，做一个完整的变量关系可视化。 以著名的iris数据集为例，iris数据集有4个特征，那么每两个特征都考虑一次，就有16种组合，路径为./data/iris.csv。 该数据集测量了所有150个样本的4个特征，分别是： sepal length（花萼长度） sepal width（花萼宽度） petal length（花瓣长度） petal width（花瓣宽度） species（花朵种类） 运行下方代码，产看数据的详情： import pandas as pd data = pd.read_csv('./iris.csv') data.head() 我们使用seaborn中的pairplot()方法，就可以绘制连续数值型多变量关系分布图。 sns.pairplot( data, hue, vars, kind, diag_kind) data表示绘图所用到的数据集。 hue参数表示按照某个字段进行分类。 vars参数可以用于筛选绘制图像的变量，用列表的形式传入列名称。 kind参数用于设置变量间图像的类型，可以选择'scatter'散点图，或者 'reg'回归图。 diag_kind用于设置对角线上的图像类型，可以选择'hist'直方图， 或者'kde'核密度图。 接下来，我们就来使用pairplot函数查看一下数据集中的每两个连续型变量的分布图： 运行下方代码，查看续型变量的分布图： import pandas as pd import matplotlib.pyplot as plt import seaborn as sns data = pd.read_csv('./iris.csv') sns.pairplot(data) plt.show() 从图中可以看出，在petal_length和petal_width散点图中，呈现了比较明显的线性关系。 接下来我们将分类变量species考虑在图中，看看不同类别的鸢尾花的数据有没有明显的差别，将hue参数设置为species。 运行下方代码，查看结果： import pandas as pd import matplotlib.pyplot as plt import seaborn as sns data = pd.read_csv('./iris.csv') sns.pairplot(data,hue='species') plt.show() 从图中可以看出，不同的颜色代表着花的不同种类，同一种的数据聚集在一起，并且与其他类别的数据交集比较少，表示三种花有明显的差别。 我们也可以使用pairplot函数绘制两个变量的关系分布图。 使用kind参数设置两个变量间使用回归图，使用diag_kind参数设置对角线上的图像类型为密度图。 运行下方代码，绘制sepal_length, sepal_width两个变量的关系分布图。 import pandas as pd import matplotlib.pyplot as plt import seaborn as sns data = pd.read_csv('./iris.csv') # 双变量图像设置为回归图，单变量（对角线图）设置为核密度图 sns.pairplot(data, hue='species',vars=['sepal_length', 'sepal_width'],kind='reg', diag_kind='kde') plt.show() 大家可以根据自己对于数据的理解，设置不同的图像样式，来继续发掘数据中的信息。 1.1.5. 本节总结 本节课中，我们学习了如何绘制连续数值型变量分布图，分别针对单变量、双变量和多变量数据进行了研究。 最后我们把本节的知识点总结一下： 1.1.6. 下节预告 学习了这么久，是该检验一下我们自己的掌握程度了，下节我们将整体体验一下分析的流程。 1.1.7. 练习1 题目：一抹祥云，定位用餐之人 本节练习我们将使用Seaborn模块内置数据集，数据中记录了顾客信息、顾客消费信息和支付小费信息。数据文件的路径为./tips.csv。 数据的基本信息为： total_bill：消费总金额； tip：小费； sex：性别； smoker：是否吸烟； day：用餐日期； time：用餐时间； size：用餐人数。 根据数据分别完成以下要求： 绘制出用餐人数的概率分布图； 绘制出用餐人数与小费的散点图； 参考答案： import pandas as pd import matplotlib.pyplot as plt import seaborn as sns data = pd.read_csv('./tips.csv') # 查看数据 data.head() # 绘制用餐人数的概率分布图 # 取出用餐人数 size = data['size'] sns.set(style='darkgrid') sns.distplot(size,kde=True) # 绘制出用餐人数与小费的散点图 # 取出用餐人数与小费的数据 data = data[['size','tip']] # 参数x_jitter，这个参数可以设置size值的偏离范围，这里size代表用餐人数，那么我们设置的x_jitter应该在0-1之间，我们设置为0.3,散点图显得更易观察 sns.jointplot(x='size', y='tip', data=data,kind='reg',x_jitter=0.3) 初步结论： 根据用餐人数的概率分布图可以看出，用餐的人数在2-4的概率居多，而2人用餐的概率最大。 从用餐人数与小费的散点图中可以看出，虽然用餐人数和小费之间也是一个线性增长的趋势。 1.1.8. 练习2 题目：小费消费，为何总爱相对 本练习我们继续使用Seaborn模块内置数据集，路径为：./tips.csv。 完成下面的要求： 绘制出每两列变量之间的关系； 不同性别的消费数据有没有明显的差别。 绘制消费总额与小费两个变量的关系分布图。 参考答案： import pandas as pd import matplotlib.pyplot as plt import seaborn as sns data = pd.read_csv('./tips.csv') # 绘制出每两列变量之间的关系 sns.pairplot(data) # 不同性别的消费数据有没有明显的差别 sns.pairplot(data,hue='sex') # 绘制消费总额与小费两个变量的关系分布图 sns.pairplot(data,vars=['total_bill', 'tip'],kind='reg', diag_kind='kde') plt.show() 初步结论： 不同性别的消费数据之间没有明显的差别。 小费金额会根据消费金额成线性增长关系。 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-25 15:57:08 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"第15课/python数据分析第十五节.html":{"url":"第15课/python数据分析第十五节.html","title":"数据清洗","keywords":"","body":"1.1.1. 案例介绍1.1.2. 分析内容1.1.3. 数据的清洗1.1.4. 整理数据和分析1.1.5. 总结题目：你了解数据分析师的薪水吗？ 1.1.1. 案例介绍 Hello, 我是小K，很高兴又和大家见面了，我们一起继续学习Python数据分析。 为了让你能不受干扰的在学习数据分析路上饱览胜景，请将屏幕调整成全屏，Windows系统：请按F11（或Fn+F11)；苹果系统：请同时按control+command+F。 细沙堆成山，滴水流成河。前面我们已经学习了数据分析江湖的Python技能，现在是时候身入江湖了，检验一下我们是否掌握了Python数据分析的技能。 一个专业的数据分析，他的定位应该是一个“谋士”，所谓谋士，应该运筹帷幄，决胜千里，不出五尺书堂，便知天下大势。 由于，我们现在已经从IT（Information Technology）时代进入了DT（Data Technology）时代。我们有能力低成本的收集和存储大量的数据，从而衍生出数据分析这个行业。 数据分析最重要的作用是从数据里面寻求真正有价值的信息，并帮助我们作出合理的决策。 为了更好的了解数据分析师这个岗位，本节课我们将以某招聘网站的2017年数据分析师职位数据为基础，进行数据分析。数据路径为：./data/analyse_spider.csv。 下面，我们了解一下数据的基本信息： 数据共包含14列，先看一下每一列的含义： city：城市 companyId：公司ID companySize：公司大小 businessZones：公司所在商区 firstType：职位所属一级类目 secondType：职业所属二级类目 education：教育要求 industryField：公司所属领域 positionId：职位ID positionAdvantage：职位福利 positionName：职位名称 positionLables：职位标签 salary：薪水 workYear：工作年限要求 运行下方代码，查看数据的具体情况： import pandas as pd data = pd.read_csv('./data/analyse_spider.csv',encoding='GBK') data.head() data.shape 因为csv文件中带有中文字符而产生字符编码错误，造成读取文件错误，在这个时候，我们可以尝试将pd.read_csv()函数的encoding参数设置为\"gbk\"。 1.1.2. 分析内容 数据分析的大忌是不知道分析方向和目的，拿着一堆数据不知所措。一切数据分析都是以业务为核心目的，而不是以数据为目的。 所以，我们应该先定分析的目标，然后在处理数据。 我们本案例的目标很简单，就是根据该数据，分析影响薪资的因素： 地区对数据分析师的薪酬的影响； 学历对数据分析师的薪酬的影响； 工作年限对数据分析师的薪酬的影响。 有了目标和方向后，后面就是将目标拆解为实际过程。 1.1.3. 数据的清洗 数据的缺失值 数据的缺失值在很大程度上会影响数据的分析结果，如果某一个字段缺失值超过一半的时候，我们就可以将这个字段删除了，因为缺失过多就没有业务意义了。 注意：并不是，只要含有有缺失值的时候，我们就要将数据删除，如果数据量比较少、缺失值不多，并且对我们的分析指标没有实际影响时，我们就可以将其保留。 运行下方代码，查看数据的缺失值情况： import pandas as pd data = pd.read_csv('./data/analyse_spider.csv',encoding='GBK') print(data.shape) data.info() 为了方便大家更好的理解，我们将结果提炼出来，如下图： 通过结果我们可以看出：一共有6876个数据，其中businessZones、firstType、secondType，positionLables都存在为空的情况。companyId和positionId为数字，其他都是字符串。 从数量上可以看出，businessZones列的数据缺失量比较大，需要将该列数据删除。 其他三列的缺失值的总数量为45，并不会影响整体分析效果，我们可以删除这45条数据。 运行下面代码，删除缺失值： import pandas as pd data = pd.read_csv('./data/analyse_spider.csv',encoding='GBK') # 删除businessZones列数据 data.drop(['businessZones'],axis=1, inplace=True) # 删除含有NaN的数据 data.dropna(inplace=True) data.info() 处理完空值之后，数据还剩6837条，13列。 删除重复值 处理完空值以后，我们还需要注意另外一个会影响我们分析结果的因素，就是重复值。 我们来看一下计算一下重复的数据，并将其删除。 使用data.duplicated()方法判断每一行是否重复，然后使用data.duplicated()[data.duplicated()==True]取出重复行，最后使用len()计算重复的数据。 下面运行下方代码，看一下是否有重复的数据，并删除。 import pandas as pd data = pd.read_csv('./data/analyse_spider.csv',encoding='GBK') # 删除businessZones列数据 data.drop(['businessZones'],axis=1, inplace=True) data.dropna(inplace=True) # 计算重复的数据数 print(len(data.duplicated()[data.duplicated()==True])) # 删除重复数据 data.drop_duplicates(inplace=True) data.info() 共有1830条重复的数据，使用data.drop_duplicates()删除后，还剩5000多条数据。 1.1.4. 整理数据和分析 数据的缺失值和重复值，是我们在分析之前必须要做，因为，他们的存在会很大程度上影响我们的分析结果。 接下来，我们需要做的事情就是，根据我们的分析需求去整理目标数据，从而方便我们的分析。 我们的第一个任务是薪酬分布情况，所以我们先来整理这个数据。 薪资字段格式基本分为15k-25k和15k以上这两种，并且都是字符串。 如果我们只想要薪资下限数据或者薪资上限数据时，怎么办呢？ 最好的方式就将salary薪资字段按照最高薪水和最低薪水拆成两列，并且薪水的话如果用几K表示，直接用于计算，所以将k去掉。 这里我们可以使用pandas中的apply方法，针对薪酬这一列数据进行操作，结果如下图。 下面是拆分的具体代码： # 定义拆分的函数 def split_salary(salary,method): # 获取'-'索引值 position = salary.upper().find('-') if position != -1: #salary值是15k-25k形式 low_salary = salary[:position-1] high_salary= salary[position+1:len(salary)-1] else: #salary值是15k以上形式 low_salary = salary[:salary.upper().find('K')] high_salary= low_salary # 根据参数用以判断返回的值 if method == 'low': return low_salary elif method == 'high': return high_salary elif method == 'avg': return (int(low_salary) + int(high_salary))/2 # 赋值 data['low_salary']=data.salary.apply(split_salary,method='low') data['high_salary']=data.salary.apply(split_salary,method='high') data['avg_salary']=data.salary.apply(split_salary,method='avg') data 下面我们具体分析一下代码的逻辑。 第一步，我们自定义了一个函数split_salary()函数，salary参数是使用apply函数必须要传的参数，其实就是data.salary的值。 第二步，使用salary.upper().find('-')判断salary值是15k-25k的形式还是15k以上形式，如果结果是-1，表示是15k以上形式，反之是15k-25k形式。为了避免k的大小写，我们用upper函数将k都转换为K，然后以K作为截取。 第三步，在split_salary函数增加了新的参数用以判断返回low_salary还是high_salary或者是avg_salary。 赋值上面的代码到代码框运行，查看拆分结果: import pandas as pd data = pd.read_csv('./data/analyse_spider.csv',encoding='GBK') # 删除businessZones列数据 data.drop(['businessZones'],axis=1, inplace=True) data.dropna(inplace=True) # 删除重复数据 data.drop_duplicates(inplace=True) # 复制代码，并运行 到此，我们数据整理部分完成，接下来我们看一下数据分析师的薪酬情况。 现在我们看一下，数据分析师薪资的分布情况。 import matplotlib.pyplot as plt import seaborn as sns sns.set(style='dark') plt.hist(data.avg_salary) plt.show() 图表中绘制了数据分析师薪资的分布，可以看出薪资的大部分在10k-30k之间，10k-20k这个范围最多。 现在观察不同城市、不同学历以及不同工作年限对薪资的影响。 首先，我们先按城市分组，然后对比每个城市的平均薪资。 import matplotlib.pyplot as plt from matplotlib import font_manager my_font = font_manager.FontProperties(fname='./data/STSONG.TTF') sns.set(style='dark') groups = data.groupby(by='city') xticks = [] for group_name,group_df in groups: xticks.append(group_name) plt.bar(group_name,group_df.avg_salary.mean()) plt.xticks(xticks,fontproperties=my_font) plt.show() 代码中我们用city进行分组，然后分别绘制了每个城市的平均薪资。 从图表中我们看出，北京的数据分析师薪资高于其他城市，上海和深圳稍次，广州甚至不如杭州和苏州。 接下来，我们再看看不同学历对薪资的影响。 我们同样按学历进行分组，然后对比不同学历的平均薪资。 import matplotlib.pyplot as plt from matplotlib import font_manager my_font = font_manager.FontProperties(fname='./data/STSONG.TTF') sns.set(style='dark') groups = data.groupby(by='education') xticks = [] for group_name,group_df in groups: xticks.append(group_name) plt.bar(group_name,group_df.avg_salary.mean()) plt.xticks(xticks,fontproperties=my_font) plt.show() 代码中我们用city进行分组，然后分别绘制了不同学历的平均薪资。 从图表中我们看出,博士薪资最高，硕士和本科基本持平，大专学历稍有弱势。 最后，我们再看看不同工作年限对薪资的影响。 我们同样按工作年年限进行分组，然后对比不同年限的平均薪资。 import matplotlib.pyplot as plt from matplotlib import font_manager my_font = font_manager.FontProperties(fname='./data/STSONG.TTF') sns.set(style='dark') groups = data.groupby(by='workYear') xticks = [] for group_name,group_df in groups: xticks.append(group_name) plt.bar(group_name,group_df.avg_salary.mean()) plt.xticks(xticks,fontproperties=my_font) plt.show() 从图表中我们看出，拥有10年以上的数据分析工作经验的人平均薪资最高，并且是年限越长薪资就越高。 分别拷贝上面的代码运行，查看图表绘制： import pandas as pd data = pd.read_csv('./data/analyse_spider.csv',encoding='GBK') # 删除businessZones列数据 data.drop(['businessZones'],axis=1, inplace=True) data.dropna(inplace=True) # 删除重复数据 data.drop_duplicates(inplace=True) # 定义拆分的函数 def split_salary(salary,method): # 获取'-'索引值 position = salary.upper().find('-') if position != -1: #salary值是15k-25k形式 low_salary = salary[:position-1] high_salary= salary[position+1:len(salary)-1] else: #salary值是15k以上形式 low_salary = salary[:salary.upper().find('K')] high_salary= low_salary # 根据参数用以判断返回的值 if method == 'low': return low_salary elif method == 'high': return high_salary elif method == 'avg': return (int(low_salary) + int(high_salary))/2 # 赋值 data['low_salary']=data.salary.apply(split_salary,method='low').astype('int') data['high_salary']=data.salary.apply(split_salary,method='high').astype('int') data['avg_salary']=data.salary.apply(split_salary,method='avg') # 复制代码，并运行 薪资我们就简单的分析到这里，我们简单的归纳一下我们数据展现的结果： 数据分析师的薪资的平均数是17k，最大薪资在75k，大部分分析师薪资在10k-20k之间。 北京的数据分析师薪资高于其他城市，上海和深圳稍次，杭州和苏州已经超过广州。 薪资最高的是博士，硕士和本科的薪资基本持平，大专学历稍有弱势。 工作年限越长，薪资就越高。 根据上面数据展现的结果可以得到这样的结论：北上广深依然是我们高薪就业地，同时工作年限和学历都是都与薪资成线性增长趋势。 1.1.5. 总结 本案例采用的是2017年的数据，分析的结果与当下数据分析师的实际薪酬有一定的差异。 本案例的目的是让大家更好的了解数据分析，以及数据分析的基本流程，最终结论仅供参考。 如果想要更深的挖掘数据中信息，我们还需要学习更多的挖掘以及统计学的相关知识。 Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-02-25 15:58:01 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"第16课/python数据分析第十六节.html":{"url":"第16课/python数据分析第十六节.html","title":"Python数据分析知识总结","keywords":"","body":"1.1.1. 导语1.1.2. Python数据分析知识总结1.1.3. 数据分析师的必备技能1.1.4. 结语题目：路漫漫其修远兮 1.1.1. 导语 Hello, 我是小K，我们能在这里相见，说明你已经学完了我们前面的全部课程。 为了让你能不受干扰的在学习数据分析路上饱览胜景，请将屏幕调整成全屏，Windows系统：请按F11（或Fn+F11)；苹果系统：请同时按control+command+F。 虽然说我们已经学完了基于Python数据分析的大部分技能，但依旧要认真对待这一关。因为我们依然有非常重要的事情尚待完成。 本节我们将主要讲解以下内容： Python数据分析知识总结 数据分析师的必备技能 1.1.2. Python数据分析知识总结 首先要对Python数据分析进行一个总复习，形成一个完整的知识框架。当你在后面拿到任何一个数据时，可以心怀不乱。 再前面的学习中，我们了解了什么是数据分析：就是从数据里面寻求真正有价值的信息，并对实际的工作或者生活有一定的指导作用，这个过程就叫数据分析。 由此，我们总结了数据分析的基本流程： 接下来，我们主要学习了Python最重要的数据分析工具包Pandas。 在Pandas中，我们首先了解了它的两种数据结构，一个Series数据就是Excel中的一条数据，一个DataFrame数据就是Excel中的一张表。 接着我们学习了，利用索引值以及切片我们可以获取两种数据结构的数据。 示例代码如下 from pandas import Series import pandas as pd emp=['001','002','003','004','005','006'] name=['亚瑟', '后裔','小乔','哪吒' ,'虞姬','王昭君'] series = Series(data=name,index=emp) # 获取多个不连续的数据 print('位置下标',series[[1,3]]) # 使用切片获取连续的数据 print('位置切片',series[0:3]) df_dict = { 'name':['ZhangSan','LiSi','WangWu','ZhaoLiu'], 'age':['18','20','19','22'], 'weight':['50','55','60','80'] } df = pd.DataFrame(data=df_dict,index=['001','002','003','004']) print(df) # 通过位置索引切片获取一行 print(df[0:1]) # 通过位置索引切片获取多行 print(df[1:3]) # 获取多行里面的某几列 print(df[1:3][['name','age']]) 此处需要注意：我们自定的index值被叫做索引下标，没有设置index值时会有一个默认的值叫做位置下标。 了解了如何获取数据之后，我们学习了如何利用Pandas读取本地csv和excel文件。 使用pandas.read_excel()和pandas.read_csv()方法，在指定文件路径后便可读取数据。 如果文件中包含多个数据表，可以通过sheet_name参数设置表的名字。 在使用这两个方法读取文件的时候，会默认将文件中第一行数据作为列索引值，可以通过header参数设置。 示例代码如下： import pandas as pd # 将第一行设置成索引 people = pd.read_csv('./data/People1.csv',header = 0) import pandas as pd # 不设置索引，使用索引默认值 people = pd.read_csv('./data/People1.csv',header = None) 读取数据之后，我们应该对数据进行整理和清洗。 在数据分析过程中，我们会有至少一半的时间都在整理和清洗数据。 Pandas中使用NaN来表示空值（缺失值），空值再参与计算时并不会报错，因为NaN类型是Float类型，但是计算出的结果都是NaN，会影响我们的计算结果。 所以，最好的方法就是含有空值的数据删除。 示例代码如下： # 只要含有NaN的整行数据删掉 df.dropna() # 想要删除整行都是空值的数据需要添加how='all'参数 df.dropna(how='all') 如果想要对列做删除操作，需要添加axis参数，axis=1表示列，axis=0表示行。 对于数据量比较大的时候，我们建议使用dropna()进行删除，并不会影响整体分析结果。 但是当我们的数据量比较少的时候，删除可能会影响整体分析结果，这时我们就可以使用填充的方式，对空值进行处理。 可以使用fillna()方法对空值进行填充。 df.fillna(value=None, method=None, axis=None, inplace=False, limit=None, downcast=None, **kwargs) value：需要用什么值去填充缺失值 axis：确定填充维度，从行开始或是从列开始 method： ​ ffill：用缺失值前面的一个值代替缺失值，如果axis =1，那么就是横向的前面的值替换后面的缺失值，如 果axis=0，那么则是上面的值替换下面的缺失值。 ​ bfill：缺失值后面的一个值代替前面的缺失值。 limit：确定填充的个数，如果limit=2，则只填充两个缺失值。 注意：method参数不能与value参数同时出现。 处理好空值以后，我们还需要考虑重复数据对数据分析结果准确度的影响。 重复数据比较多的时候，会降低分析的准确度，一会降低分析的效率。所以我们在整理数据的时候应该将重复的数据删除掉。 可以使用duplicated()方法判断是否有重复的数据，返回的是一个值为Bool类型的Series。 同时，我们也可以使用drop_duplicates()方法将重复数据进行删除。 当我们分析的数据在多个表中时候，为了方便分析就需要我们将数据进行合并。 数据合并主要包括下面两种操作： 轴向连接（concatenation），pd.concat()可以沿一个轴将多个DataFrame对象连接在一起，形成一个新的DataFrame对象 融合（merging），pd.merge()方法可以根据一个或多个键将不同DataFrame中的行连接起来 同时，我们也可以用逻辑运算的方式对数据进行筛选。例如： # 准确获取到所有关注者超过100的用户数据 bools= df['关注者']>100 df1 = df[bools] 并且，可以使用sort_index()、sort_values()两个方法对数据进行排序，并且这两个方法Series和DataFrame都支持。 俗话说“物以类聚，人以群分”，我们在分析的时候，一般会将数据进行分类，然后针对某一类数据进行具体分析。 Pandas提供了一个灵活高效的groupby功能，它使你能以一种自然的方式对数据集进行切片、切块、摘要等操作。 示例代码如下： import pandas as pd df = pd.read_excel('./data/forbes_2018.xlsx') # 根据gender列进行分组 groups = df.groupby('gender') print(groups) 使用遍历，我们可以获取到每一组的数据信息： for group_name,group_df in groups: print(group_name,group_df.shape) 并且，可以分组后数据使用mean()、max()、min()等统计函数快速获取我们的指标值。 pandas里常用的统计函数包括： count( )：统计列表中非空数据的个数 nunique( )：统计非重复的数据的个数 sum( )：统计列表中所有数值的和 mean( )：计算列表中数据的平均值 median( )：统计列表中数据的中位数 max( )：求列表中数据的最大值 min( )：求找列表中数据的最小值 如果根据多列数据进行分组后，会出现多层索引情况。 对于多层级Series的取值，可以直接使用[]的方式取值。 示例代码如下： s['张三','期末'] s[:,'期中'] 取值的方式我们可以根据剥洋葱原则，从外到内一层一层的剥。 在对多层索引DataFrame的取值是，我们推荐使用loc()函数。 示例代码： df.loc['张三','期中'] df.loc['张三'].loc['期中'] df.loc[('张三','期中'),:] DataFrame和Series有一个同样的注意点，就是无法直接对二级索引直接进行索引，必须让二级索引变成一级索引后才能对其进行索引！ 在金融、经济、物理学等领域，都需要在多个时间点观测或者测量数据，这样就产生了关于时间序列的数据。 我们在分析的时候，可以将时间列数据设置成数据的索引，然后选出一定时间段内的数据进行分析。 代码示例如下： import pandas as pd import numpy as np time_index = pd.date_range('2019-01-01', periods=400) time_data = np.random.randint(100,size=400) date_time = pd.Series(data=time_data,index=time_index) 可以依据年份进行索引： date_time['2020'] 可以依据年和月进行索引： date_time['2019-10'] 可以使用时间戳进行切片获取数据 date_time['2019-10-05':'2019-10-10'] 有的时候用csv导入到时间数据时，默认的是字符串的数据类型 ，当可视化的时候，会出现没有按时间先后顺序的方式绘图 ，所以需要将字符串解析为时间类型的数据类型。 使用Pandas的to_datetime()方法可以将字符串形式的日期转换成时间格式。 pd.to_datetime(arg,format=None) arg：需要修改的数据 format：数据的格式 以上是我们对数据的获取以及整理的基本操作，俗话说：“文不如表，表不如图”，如果我们将海量的数据绘制成图，就可以让我们的数据更加直观的呈现，更具说服力。 所以，我紧接着又学习了Python中另外一个库Matplotlib，它的功能非常强大，可以通过调用函数轻松方便地绘制数据分析中常见的各种图像，比如折线图、条形图、柱状图、散点图、饼图等。 在Matplotlib的学习中我们首先要了解常见图形种类及意义。 折线图：以折线的上升或下降来表示统计数量的增减变化的统计图 ​ 特点：能够显示数据的变化趋势，反映事物的变化情况。(变化) 散点图：用两组数据构成多个坐标点，考察坐标点的分布,判断两变量之间是否存在某种关联或总结坐标点的分布模式。 特点：判断变量之间是否存在数量关联趋势,展示离群点(分布规律) 柱状图：排列在工作表的列或行中的数据可以绘制到柱状图中。 特点：绘制连离散的数据,能够一眼看出各个数据的大小,比较数据之间的差别。(统计/对比) 直方图：由一系列高度不等的纵向条纹或线段表示数据分布的情况。 一般用横轴表示数据范围，纵轴表示分布情况。 特点：绘制连续性的数据展示一组或者多组数据的分布状况(统计) 饼图：用于表示不同分类的占比情况，通过弧度大小来对比各种分类。 特点：分类数据的占比情况(占比) 想要学好用好Matplotlib是特别简单的，前提就是要必须清楚的了解Matplotlib图像组成。 同时，我们还要清楚每种图形的绘制方法，折线图：plt.plot()；柱状图：plt.bar()；直方图：plt.hist()；散点图：plt.scatter();饼图：plt.pie()。 在使用Matplotlib时候需要注意，Matplotlib画的图不显示中文，所以我们的处理方式是添加字体属性。 示例代码如下： from matplotlib import pyplot as plt from matplotlib import font_manager import random # 创建字体对象 my_font = font_manager.FontProperties(fname='./data/STSONG.TTF',size=18) x = range(0,120) y = [random.randint(10,30) for i in range(120)] # 添加字体属性 plt.ylabel(\"次数\",fontproperties=my_font) plt.xlabel(\"时间\",fontproperties=my_font) # 设置标题 plt.title('每分钟跳动次数',fontproperties=my_font) plt.plot(x,y) plt.show() 并且，我们还可以通过xticks()和yticks()自定义x轴和y轴的刻度值。 下面我们总结一下Matplotlib常用的方法： Seaborn和Matplotlib是Python最强大的两个可视化库。Seaborn其默认主题让人惊讶，而Matplotlib可以通过其多个分类为用户打造专属功能。 Seaborn的底层是基于Matplotlib的，他们的差异有点像在点餐时选套餐还是自己点的区别，Matplotlib是独立点菜，可能费时费心（尤其是对我这种选择困难症患者...）但最后上桌的菜全是特别适合自己的；而Seaborn是点套餐，特别简单，一切都是配好的，虽然省时省心，但可能套餐里总有些菜是不那么合自己口味的。 所以，在需要绘制图形的时候，我们可以根据自己的喜好自行选择。 以上，就是我们整个Python数据分析基础内容。 下面，我们来了解一下数据分析师需要还需要掌握哪些技能？ 1.1.3. 数据分析师的必备技能 俗话说“台上一分钟，台下十年功”。任何人取得的任何成就都不是一蹴而就的，学习之路更应如此，那么学习数据分析你需要的基本功是什么呢？ 千里之行，始于足下，数据分析，始于Excel。数据分析的第一步，就是能够使用Excel进行各种业务数据研究。 数据分析中最常用的语言就是SQL，无论是数据的提取、转换，还是各种数据计算，SQL都是最好的武器。 基础数学和统计学可以提高你的分析能力，了解为什么和在哪里使用平均值，中位数和模式。 在数据可视化方面，除了Excel、matplotlib以外，还有一个常用的就是Tableau，通过简单的拖拽数据处理方式，迅速对数据进行初级透视。 数据报告的撰写，是数据分析的最后一步，也是最重要的一步，好的分析报告是你升值加薪的法宝。 以上，给大家提供了一些数据分析中要掌握的技能，以供大家后续的学习。 1.1.4. 结语 到此，我们的Python数据分析基础课就将告一段落了。 我知道你在首次使用代码拿到数据的欣喜，我知道你初次接触Pandas时候的困惑，我知道你接触Matplotlib时的不解…… 因为，我们曾经都是一个初学者，与你经历过同样的过程。 路漫漫其修远兮，数据分析的路还很长，重要的是坚持和练习。 “乘风破浪会有时，直挂云帆济沧海”，祝你在学习数据分析的道路上越走越远！ “青山不改，绿水长流”，我们有缘江湖再会！ Copyright © 賈誌翔 2020 all right reserved，powered by Gitbook文章修订时间： 2020-03-23 12:30:19 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}